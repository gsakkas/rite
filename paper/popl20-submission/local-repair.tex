\begin{algorithm}
    \caption{Local Repair Algorithm}
    \label{local-repair-algo}
    \renewcommand{\algorithmicrequire}{\textbf{Input:}}
    \renewcommand{\algorithmicensure}{\textbf{Output:}}
    \begin{algorithmic}[1]
    \Require{Language Grammar \lang, Program $P$, Template $T$, Repair Location $L$, Max Repair Depth $D$}
    \Ensure{Local Repairs $R$}
    \Procedure{Enumerate}{$\lang, P, T, L, D$}
    \State $R \gets \emptyset$
    \ForAll{$d \in [1 \dots D]$}
      \State $\tilde{\alpha} \gets$ \Call{NonTerminalsAt}{$T, d$}
      \ForAll{$\alpha \in$ \Call{RankNonTerminals}{$\tilde{\alpha}, P, L$}}
        \If{\Call{IsHole}{$\tilde{\alpha}$}}
          \State $R \gets$ \Call{GrammarRules}{$\lang$}
          \State $\tilde{\beta} \gets \{\beta\:|\:(\alpha, \beta) \in R\}$
          \ForAll{$\beta \in$ \Call{RankRules}{$\tilde{\beta}, T$}}
            \State $\hat{T} \gets$ \Call{ApplyRule}{$T, (\alpha, \beta)$}
          \EndFor
        \Else
          \ForAll{$\sigma \in$ \Call{GetTerminals}{$P, \alpha, \lang$}}
            \State $\hat{T} \gets$ \Call{ReplaceNode}{$T, \alpha, \sigma$}
          \EndFor
        \EndIf
        \State $\hat{P} \gets$ \Call{ReplaceExprAt}{$P, L, \hat{T}$}
        \If{\Call{TypeCheck}{$\hat{P}$}}
          \State $R \gets R \cup \{\hat{P}\}$
        \EndIf
      \EndFor
    \EndFor
    \State \Return{$R$}
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
