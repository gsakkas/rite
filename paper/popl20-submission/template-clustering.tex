\section{Learning Fix Templates}
\label{sec:templ-cluster}

In this section, we introduce our approach to extracting useful fix schemas ---
or \emph{fix templates} --- from a given dataset of already fixed programs. We
represent those templates in terms of a simple language \repairLang
(\autoref{fig:rtl-syntax}). \repairLang is a simple lambda calculus with integers,
booleans, pairs, and lists, but also with some abstractions that allow us to
represent more general abstract fix schemas, that simultaneously capture the
core structure of various fix patterns that novices use.

A template over \repairLang is a \emph{Generic Abstract Syntax Tree (GAST)}.
Those GASTs will then be used to predict and generate possible repairs for new
erroneous programs, as described in the next two sections. However, having a
single fix template for each program pair that appears in the dataset can lead
in large number of templates, rendering it impossible to train predictive models
that will choose from so many options.

Therefore, we define a \emph{GAST similarity metric} that will enable us
classify fix patterns that don't have the exact same syntax tree but appear to
be of the same nature, to be represented by the same fix template. For example,
changing different arguments of a function application should be represented by
the same fix template. We achieve that by \emph{clustering} the existing
extracted fix templates into a smaller set, using that similarity metric.

\input{syntax-loc.tex}

\subsection{RTL: Repair Template Language}
\label{subsec:lang}

In this section, we define the language we are going to use to represent
templates and how we can acquire those templates from our dataset.

\mypara{Syntax of RTL}
We define here our Repair Template Language (RTL) as a simple lambda calculus
(\repairLang in \autoref{fig:rtl-syntax}) with integers, booleans, pairs, and lists.
This language will be used to abstract and define repair templates $\T$. Our RTL
contains all the expressions that \lang included, but with four significant
changes.

\begin{enumerate}
    \item Variable names $x$ used for functions, variables and patterns are left
    \emph{unspecified}. That means that $x$ denotes that that place of the code
    has a variable name, but it is unknown at that point.
    \item Literal values $n$ can be any integer or floating point number,
    boolean value or character and string. Same as variables, these are left
    unspecified.
    \item Operators $\oplus$ are also left unspecified.
    \item A \emph{wildcard} expression $\_$ is added, which is used to denote
    that \emph{any} expression in \repairLang can be used to replace it.
\end{enumerate}

\mypara{Generic ASTs (GASTs)}
Using our RTL, we can now define \emph{Generic ASTs}. GASTs are abstract syntax
trees that represent expressions that can have unspecified details, like
variable names or numerical values. Therefore, GASTs can represent templates
$\T$, defined as expressions in \repairLang. GASTs are used here to capture the
high-level \emph{structure} of an expression, as a more appropriate means to
define templates. GASTs are extracted from the original ASTs representing
programs in \lang, by removing all the necessary information so \repairLang can
be used. Then these trees can be further \emph{pruned} at a depth $d$ to keep
only the higher level expressions and formulate the templates.


\mypara{Extracting Templates from Dataset Repairs}
% TODO: Needs rewriting
Templates $\T$ are extracted by the function $\templatesym$ from our program
pair dataset. Using the $\diffsym$ function first, we acquire the changed
expressions of the dataset. These changes are potentially the templates we are
going to use. However, they contain a lot of \emph{local} information to the
specific program that they were extracted from. So $\templatesym$ takes the
changed expressions defined in \lang and \emph{transforms} them into expressions
in \repairLang, essentially making them into templates $\T$. Those templates are
represented as GASTs and are pruned at a pre-defined depth $d$. The value of $d$
can be as low as 1, but to capture more structure to our templates, slightly
bigger values would work better. We then see in \autoref{subsec:clustering} how
we can group together all these templates.

We identify the fixes for each ill-typed program with an expression-level
$\diffsym$~\citep{Lempsink2009-xf}. We consider two sources of changes. First,
if an expression has been removed wholesale, \eg if $\eapp{f}{x}$ is rewritten
to $\eapp{g}{x}$, we will mark the expression $f$ as changed, as it has been
replaced by $g$. Second, if a new expression has been inserted \emph{around} an
existing expression, \eg if $\eapp{f}{x}$ is rewritten to
$\eplus{\eapp{f}{x}}{1}$, we will mark the application expression $\eapp{f}{x}$
(but not $f$ or $x$) as changed, as the $+$ operator now occupies the original
location of the application.

\mypara{Example}
TODO: give an example


\subsection{Clustering the Templates}
\label{subsec:clustering}

% TODO: Should we give a better name than "similarity metric"
\mypara{GAST Similarity Metric}
Having programs written over \repairLang, forces similar changes, \ie changing a
variable name, to have the same GAST. This is really helpful when we try to
group different changes together into some templates $\T$. We want to extend and
generalize this ``similarity'' of program changes, in order to get a small but
generally applicable number of repair templates.

Therefore, two expressions over \repairLang are considered \emph{similar} when
the following simple rules hold:
\begin{enumerate}
    \item Their pruned GASTs (at a pre-defined depth $d$) are exactly the same.
    \item A wildcard expression is considered similar with any possible
    expression over \repairLang.
    \item Two applications, operators, cases, lists or tuples are considered
    similar when there is a total bijective relation between their children
    expressions, such that the related expressions are themselves similar.
    % TODO: maybe explain better and separate apps, and include ifs and lets
\end{enumerate}


\mypara{Clustering}
The main goal of clustering is to eliminate the possibility of equivalent
expressions to be considered as different templates and thus making our
predictive models more scalable and applicable to more programs. We define
clustering as the task of grouping together similar expressions over \repairLang
that each group can then be used as a fix template to produce repairs for
ill-typed programs. Each group can consist of several \emph{member-expressions}
and each one of them can be used as the cluster \emph{representative}.

The clustering algorithm uses the extracted fix templates and groups together
the templates that are similar based on our ealrier definition of expression
similarity. It then returns the Top-$N$ based on their popularity on their
training set. $N$ is considered a parameter of algorithm that can be defined
prior the training and clustering process, and is usually around 30 to 50 [TODO:
cite similar template papers].

\mypara{Example}
TODO: give an example
