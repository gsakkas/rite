\section{Overview}
\label{sec:overview}

We begin with an overview of our approach to suggesting fixes for various faulty
programs by collectively learning from the processes novice programmers follow
to fix errors in their programs.

\begin{figure}[ht]
\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> (hd * i) @ (mulByDigit i tl)
\end{ecode}

\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> [hd * i] @ (mulByDigit i tl)
\end{ecode}
\caption{(top) An ill-typed \ocaml program that should multiply each element
of a list with an integer. (bottom) The fixed version by the student.}
\label{fig:mulByDigit}
\end{figure}


\mypara{The Problem.} Consider the program \texttt{mulByDigit} shown at 
the top of \autoref{fig:mulByDigit}, written by a student in an undergraduate 
Programming course. The program is meant to multiply all the numbers in a list
with an integer digit. The student accidentally misuses the list append
operator (\texttt{@}), applying it to a number and a list rather than two lists.
%
Novice students who are still building a mental model of how the type checker
works, are often perplexed by the compiler's error message \cite{fixme}. 
Hence a novice will often take a long time to arrive at a suitable fix 
such as the one shown at the bottom of \autoref{fig:mulByDigit}, where 
the append operator is still used, but now, with a singleton list 
containing the multiplication of the head \texttt{hd} and \texttt{i}.
%
Our goal is to use historical data of how previous programmers have fixed
similar errors in their programs to automatically and rapidly guide the novice
to can candidate solutions like the one above.

\mypara{Solution: Analytic Program Synthesis.}
%
One approach is to view the search for candidate repairs as a 
synthesis problem: synthesize (some small set of edits) to the 
program that yields a good one \cite{rishabh2013,fixme}.
%
Of course, to ensure that synthesis is tractable, the search must be 
carefully restricted to a relatively small, manually constructed 
``repair model'' that may not include the ``right'' fixes for an
erroneous program.
%
In this work, we present a novel strategy called 
\emph{Analytic Program Synthesis} which breaks the 
problem into three parts: 
%
First, \emph{learn} a set of widely used \emph{repair templates}.
%
Second, \emph{predict}, from an erroneous program, the correct repair template \emph{to apply}.
%
Third, \emph{synthesize} candidate repairs from the predicted template.

In the remainder of this section, we give a high-level overview of our approach 
by describing how to:

\begin{enumerate}

  \item Represent repairs abstractly via \emph{repair templates} 
        (\autoref{sec:overview:templates}), 

  \item Acquire a \emph{training set} of labeled ill-typed programs and fixes 
        (\autoref{sec:overview:data}),

  \item Learn a small set of candidate repair templates by \emph{clustering} 
        the training set (\autoref{sec:overview:learn}),

  \item Predict the appropriate template to apply by training a \emph{multi-class classifier} 
        from the data set (\autoref{sec:overview:predict}), and  

  \item Synthesize repairs by enumerating-and-checking terms from the 
        predicted templates to give the programmer localized feedback 
        (\autoref{sec:overview:synthesis}).

\end{enumerate}

\begin{comment}
\emph{fixing} an erroneous program as a \emph{supervised multi-class classification problem}, whose results
are then fed to a \emph{program synthesizer}. A multi-class classification
problem entails learning a function that maps inputs to a discrete set of
usually more than two output labels. A supervised learning problem is one in
with an available training set where the inputs and labels are known, and the
task is to learn a function that accurately maps the inputs to output labels and
generalizes to future inputs. Finally, program synthesis is a problem where,
given a input high-level specification, a new program over some language is
requested as output.
\end{comment}

\subsection{Representing Repairs}
\label{sec:overview:templates} 

We represent different fixes --- \ie common repair 
strategies found in our dataset --- via an abstract 
fix schema, that we refer to as \emph{fix templates}. 
We focus on AST-level templates that are easy for 
novices to understand.

\mynote{WHAT IS A REPAIR?}

\mynote{WHAT IS A REPAIR TEMPLATE?}

\mypara{Generic Abstract Syntax Trees.}
%
Fixes in our dataset are represented as the ASTs of 
the expressions that changed in the ill-typed programs 
and transformed the program to the correct solution.
%
To enable \emph{similar fixes} in different ill-typed 
programs to be clustered together and thus get a smaller 
number of clusters of better quality, we propose a 
further simplification of the changed ASTs: the 
\emph{Generic Abstract Syntax Trees} (GASTs). 
%
GASTs are obtained from concrete ASTs in two steps.
%
First, we abstract all concrete variable, function, 
and operator names. 
%
Next, we prune these GASTs at a certain depth $d$ 
to keep only the top-level changes of the fix. 
Pruned sub-trees are replaced with \emph{holes}, 
which can represent that \emph{any} possible 
expression in our language.
%
Together, these steps ensure that GASTs only contain 
information about the \emph{fix's structure} rather 
than the specific changes in variables and functions. 


\mynote{TODO: Make figure of GAST for running example.}

% The ASTs of the fixes is a good start, but those still contain too much
% information. See our running example. |[hd * i]| is a list that includes a
% multiplication of the variables |hd| and |i|. While we care about the list and
% the binary operator, all the rest information is not that important. T


% TODO: Show template for running example.
% For our example, the GAST would be a list with a binary operator as a child,
% whose children in return would be holes, if we were to prune GASTs at a depth $d
% = 2$. The binary operator would also be unknown at this point, thus creating a
% template of the form |[_ # _]|. We see in \autoref{fig:suggestion} how that
% template would work to provide feedback to programmers, but we discuss later how
% we can complete the template with program synthesis.

\mynote{is the below \autoref{fig:suggestion} the TEMPLATE? It looks like PROGRAM + TEMPLATE}

\begin{figure}[ht]
\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> [_ (*@$\oplus$@*) _] @ (mulByDigit i tl)
\end{ecode}
\caption{A possible template for the \texttt{mulByDigit} program.}
\label{fig:suggestion}
\end{figure}

\subsection{Acquiring a Repair-Labeled Training Set}
\label{sec:overview:data}

Previous work has used experts to create a set of ill-typed programs 
and their fixed versions~\citep[][]{Lerner2007-dt, Loncaric2016-uk},
or to manually create \emph{fix templates} that can yield 
\emph{repair patches}~\citep[][]{martinez2013automatically,martinez2015mining}.
%
This approach is hard to scale upto yield data sets suitable for 
machine learning. Worse, manual inspection misses the \emph{frequency} 
of particular classes of novice mistakes and their fixes.
%
In contrast, we show that such fix templates can be 
\emph{learned} from a labeled data set comprising pairs 
of ill-typed and fixed programs, from a large, automatically 
constructed training set of ill-typed programs labeled with repairs.


\mypara{Interaction Traces.} 
%
Following \citep{Seidel:2017} we XXX \mynote{you CANNOT plagiarize text please rewrite para}.
%
%% We solve both the scale and frequency problems by
%% instead extracting blame-labeled data sets from \emph{interaction traces}.
%% Software development is an iterative process. Programmers, perhaps after a
%% lengthy (and sometimes frustrating) back-and-forth with the type checker,
%% eventually end up fixing their own programs. Previous work has used an
%% instrumented \ocaml compiler to record this conversation, i.e. record the
%% sequence of programs submitted by each programmer and whether or not it was
%% deemed type-correct. For each ill-typed program in a particular programmer's
%% trace, they found the first subsequent program in the trace that type-checks and
%% declare it to be the fixed version. In our case, we used an existing
%% dataset~\citep[][]{yunounderstand, Seidel:2017} of ill-typed programs and their
%% fixes, that was extracted using that method. From these pairs, we can produce a
%% \emph{diff} of the abstract syntax trees (ASTs), and then assign the blame
%% labels to the \emph{smallest} sub-tree in the diff.

\mypara{Example.} Suppose our student fixed the |mulByDigit| program as shown
above by adding a |[]| around the result of the multiplication. For this
example, the produced diff would include the new list expression |[hd * i]|.
Thus, we determine that this expression is the repair that ``fixes'' the program.

% \mypara{Bags-of-Abstracted-Terms.} Our representation of programs is
% parameterized by a set of feature abstraction functions, (abbreviated to feature
% abstractions) $f_1, \ldots, f_n$ , that map terms to a numeric value (or just
% $\{0, 1\}$ to encode a boolean property). Given a set of feature abstractions,
% we can represent a single program's AST as a \emph{bag-of-abstracted-terms}
% (BOAT) by:
% %
% (1) decomposing the AST (term) $t$ into a bag of its constituent sub-trees
% (terms) $\{t_1, \ldots, t_m\}$; and then
% %
% (2) representing each sub-term $t_i$ with the $n$-dimensional vector $[f_1(t_i),
% \ldots, f_n(t_i)]$. Working with ASTs is a natural choice as type-checkers
% operate on the same representation.

% \mypara{Modeling Contexts.} Each expression occurs in some surrounding
% \emph{context}, and we would like the classifier to be able make decisions based
% on the context as well. The context is particularly important for our task as
% each expression imposes typing constraints on its neighbors. For example, a |@|
% operator tells the type checker that both children must have type |'a list| and
% that the parent must accept an |'a list|. The BOAT representation makes it easy
% to incorporate contexts: we simply \emph{concatenate} each term’s feature vector
% with the \emph{contextual features} of its parent and children.

% \mypara{Type features.} Another way to summarize the context in which an
% expression occurs is with types. Of course, the programs we are given are
% untypeable, but we can still extract a partial typing derivation from the type
% checker and use it to provide more information to the model. However, to help
% later our classifier give better predictions of the possible fixes, we want
% those types to be as close as possible to the types that correct program would
% have or at least be a super-type of them. To achieve that, we replace each time
% one location of the program with a typed hole and extend the type checker to
% infer the type of that hole from the context of the program. This procedure
% would give more accurate super-types than getting partial typing derivation from
% the untypeable original program.


\subsection{Learning Candidate Repair Templates}
\label{sec:overview:learn}

\mynote{dumped here}
A GAST representative of a cluster can be used as 
a fix template in order to produce a program repair 
or provide feedback for the type-error that a faulty 
program raises.

Abstract fix schemas gathered from a dataset of ill-typed 
programs and their respective fixed version can introduce 
a huge set of fix templates, which can be inappropriate 
for predicting the correct one to be used for the final 
program repair. 

Therefore, the next step in our approach is to learn 
a set of fix templates, that is \emph{small enough} to 
permit automatically predicting which template to apply 
to a given erroneous program, but nevertheless \emph{covers}
most of the fixes that arise in practice.

\mynote{HEREHEREHEREHERE}

\mypara{Clustering the Fixes.} Our dataset contains erroneous programs and the
corresponding user-written fixes. Those fixes can be arbitrary code
modifications with different lengths, variable names, functions, and so on. We
propose to automatically cluster the extracted fix templates to a small set of
more abstract fix schemas. This clustering serves two purposes. First, it
enables the subsequent use of discrete classification algorithms to find the
most common fix schema. Second, it allows for the principled removal of
outliers. Outliers are a relevant problem because student datasets often contain
non-standard or idiosyncratic solutions. We propose to use a simple clustering
algorithm applied atop a similarity metric for fixes.

\subsection{Training Predictive Models}
\label{sec:overview:predict}

Next, we need to train models that can predict correctly the error location and
the template that will be used to repair that location of a given program. Our
dataset's labels can be updated with the corresponding template that fixes each
location, drawn from a minimal set of fix templates that were acquired through
our clustering method. Therefore, error localization and template prediction can
be summed to \emph{binary} and \emph{multi-class classification} problems
respectively.

\mypara{Error Localization.} Previous work has shown to give excellent accuracy
on localizing type-errors using \emph{machine learning} techniques. In order to
reduce the complexity of predicting the correct fix and the location that it
should be applied, we separate those two problems. We train a \emph{Deep Neural
Network (DNN)} classifier to associate locations with their probability to be
fixed. Then, in a descending order of probabilities, we try to repair them using
template predictions for those locations.

\mypara{Multi-class Classification.} We choose models that can handle multiple
classes as labels. Such models are DNNs, but they not only predict a
template-class, but also associate a metric that can be interpreted as the
classifier’s confidence in its prediction. We use deep and dense architectures
to give a better confidence to each template, aiming for a higher accuracy for
template predictions.

\subsection{Synthesizing Feedback from Predicted Templates}
\label{sec:overview:synthesis}

Next, we want to exploit existing program synthesis techniques to \emph{generate
repairs} that will be used to provide feedback to users. Our approach exploits
template predictions and a set of possible error locations to guide program
synthesis for a more efficient algorithm. We then want to provide a small set of
\emph{minimal} repairs back to users as feedback.

\mypara{Program Synthesis.} Given a set of locations and candidate templates for
those locations, we are trying to solve a problem of synthesis, meaning that we
try to generate code that would match the template’s GAST and make the program
type-check. For each location, we enumerate all possible expressions that match
a given template, until we find a small set that makes the program to
type-check. We also try to use existing code in our synthesis algorithm to
further prune the search space, by considering subexpressions of the erroneous
expressions we try to repair.

\mypara{Synthesis for Multiple Locations.} Using our error localization
predictions, we get a confidence for each location in the type-error slice.
Previous work has shown that just the top 3 locations from this set can solve up
to 90\% of type-errors. But it is often the case, that more than one location
needs to be fixed. Therefore, in practice we don't only consider the ordered set
of single error locations, but rather its powerset. The confidence for a subset
of locations can be acquired by the product of each location’s confidence in the
subset. This holds because we consider each location’s probability that needs to
be fixed, as independent from other locations.

% Finally, having generated automatic repairs for a given ill-typed program using
% our predictive models and program synthesis, we want to use that to help users
% repair their programs and understand what the program error was. To do so, we
% want to provide \emph{minimal} repairs to students, meaning repairs that are as
% close to their original program but also catch the programmers intent for that
% piece of code. Since we have multiple fix templates to choose from and many
% candidate locations to fix in a program, users would find it most useful to get
% more than one suggestion, and those suggestions to be ranked according to some
% metric.

\mypara{Ranking Fixes.} Finally, we rank each solution by two metrics, the
\emph{tree-edit distance} and the \emph{string-edit} distance. Previous work has
used those metrics to consider minimal changes, i.e. changes that are as close
as possible to the original programs, so novice programmers can better
understand feedback. However, different metrics may give better fixes as we
discuss later. Programmers usually have in mind what the \emph{type signature}
the functions that they write are supposed to have. So, it is reasonable to
provide the user with the option to give the intended type for the program's
functions we are trying to repair. In our case, we acquire the intended types
from the fixed versions of the dataset.

\mypara{Example.} In \autoref{fig:repair} we can see a minimal repair that our
method could return, using the template and error location discussed in
\autoref{subsec:step2} to synthesize this solution. However, this solution is
not the highest-ranked that our implementation would return (that would be
identical to the solution the programmer gave) and we use this repair to
demonstrate different aspects of the synthesizer. We can see that this solution
is very close to the one that the programmer finally came up with, but still has
some holes. However, there are some indications as to what these holes should
be. Here our synthesizer suggests that two different variables, $v_1$ and $v_2$,
should be used to fill those expression holes.

\begin{figure}[ht]
\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> [(*@$v_1$@*) * (*@$v_2$@*)] @ (mulByDigit i tl)
\end{ecode}
\caption{A candidate repair for the \texttt{mulByDigit} program.}
\label{fig:repair}
\end{figure}
