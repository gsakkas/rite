\section{Learning Fix Templates}
\label{sec:templ-cluster}

We start by introducing our approach for extracting 
useful \emph{fix templates} --- from a training dataset 
of comprising erroneous-and-fixed programs. 
%
We represent those templates in terms of a language 
that allow us to succinctly represent fixes in way 
that captures the essential structure of various fix 
patterns that novices use in practice.
%
Having a single fix template for \emph{each} program 
pair in the dataset yields too many templates to perform 
accurate prediction. 
%
Hence, we define a \emph{similarity} relation between 
templates, to let us \emph{partition} the extracted 
templates into a smaller set that makes it possible 
to train precise predictive models to predict fixes.

\input{syntax.tex}

\subsection{Representing User Fixes}
\label{sec:templ-cluster:lang}

\paragraph{Repair Template Language.}
\autoref{fig:rtl-syntax} describes our Repair Template Language (RTL)
which is a lambda calculus with integers, booleans, pairs,
and lists, that extends our core ML language \lang (\autoref{fig:ml-syntax})
with several syntactic abstraction forms:

\begin{enumerate}
    \item \emph{Abstract variable} names $\hat{x}$  are used to denote variable 
    occurences for for functions, variables and binders, \ie $\hat{x}$ denotes 
    an unknown variable name in \repairLang;

    \item \emph{Abstract literal} values $\hat{n}$ can represent \emph{any} 
    integer or floating point number, boolean value or character and string;

    \item \emph{Abstract operators} $\oplus$ similarly denote unknown unary or binary 
    operators; 

    \item \emph{Wildcard} expressions $\_$ are used to represent \emph{any} 
    expression in \repairLang, \ie a program \emph{hole}.
\end{enumerate}

Recall from \autoref{sec:overview:templates} that we define fixes as
replacements of expressions with new candidate expressions at specific 
program locations. Therefore, a fix template $\T$ will represent such 
candidate expressions over \repairLang.

\paragraph{Generalizing ASTs.}
A \emph{Generic Abstract Syntax Tree} (GAST) is a term from \repairLang that 
represents many possible expressions from \lang. GASTs are extracted from regular 
terms (ASTs) over the core language \lang using the $\abstrsym$ function that takes 
as input an expression $e^{ML}$ over \lang and a depth $d$ and returns an expression 
$e^{RTL}$ over \repairLang, \ie a GAST with all variables, literals and operators of 
$e^{ML}$ abstracted and all subexpressions starting at depth greater than $d$ pruned 
and replaced with holes $\_$.

\input{gast-example.tex}

\paragraph{Example.}
Recall our example program \mbd at \autoref{fig:mulByDigit}. 
%
The expression |[hd * i]| replaces |(hd * i)| in line 4, and hence, is the user's \emph{fix},
whose AST is given in \autoref{fig:fix_ast}. 
%
The output of $\abstrsym$, given this AST and a depth $d = 1$ as input, would be the 
GAST in \autoref{fig:templ_gast}, where the operator |*| has been replaced with an 
abstract operator, and where the sub-terms |hd| and |i| at depth 2 have been 
abstracted to wildcard expressions $\_$.
%
Hence, the \repairLang term |[_ # _]| represents a potential fix template for \mbd.

\subsection{Extracting Fix Templates from a Dataset}
\label{sec:templ-cluster:templates}

Our approach fully automates the prediction of repairs 
by harvesting a set of fix template from a training set 
of program pairs.
%
Given a program pair $(\pbad, \pfix)$ from the dataset, 
we extract a unique fix for each location in $\pbad$ 
that changed in $\pfix$. 
%
We do so with an expression-level $\diffsym$~\citep{Lempsink2009-xf} 
function, which extracts all changes between a program pair 
$(\pbad, \pfix)$. 
%
Recall again that we consider fixes to be replacements 
of expressions, and therefore we use the extracted
changes as our fix templates.

\paragraph{Contextual Repairs.}
%
Following \cite{Felleisen92} let 
$\econtext{}$ be the \emph{context} that 
an expression $e$ appears in a program $p$, 
\ie the program $p$ with expression $e$ 
replaced with a hole $\_$.
%
We write that $p = \context{}{e}$, meaning 
that if we fill the hole with the original 
expression $e$ we get the original program 
$p$. 
%
In this fashion, $\diffsym$ finds
a \emph{minimal} (in number of nodes) 
expression replacement $\efix$ for an
expression $\ebad$ in $\pbad$, such 
that $\pbad = \context{\pbad}{\ebad}$ 
and $\context{\pbad}{\efix} = \pfix$. 
%
There may be several such expressions 
in a program, and $\diffsym$ returns 
all such changes between the erroneous 
program $\pbad$ and its fixed counterpart 
$\pfix$.

\paragraph{Example.}
%
For example, if a new expression has been inserted \emph{around} an existing
expression, \eg if $\eapp{f}{x}$ is rewritten to $\eapp{g}{x}$, we will have
that the context is $\econtext{} = \eapp{\_}{x}$, where $\_$ represents the
hole, and then the fix will be $g$, since $\context{}{g} = \eapp{g}{x}$. 

If instead, an expression has been replaced wholesale with 
another expression, \eg if $\eapp{f}{x}$ is rewritten to 
$\eplus{(\eapp{f}{x})}{1}$, the \emph{context} will be 
more general where $\econtext{} = \_$, since we consider 
the application expression $\eapp{f}{x}$ (but not $f$ or $x$) 
to be replaced with the $+$ operator, and therefore 
the \emph{fix} will be the whole expression, thus
$\context{}{\eplus{(\eapp{f}{x})}{1}} = \eplus{(\eapp{f}{x})}{1}$.
% TODO: maybe talk about the drawback of the last choice

\subsection{Clustering the Templates}

Having programs written over \repairLang forces similar 
fixes, \ie changing a variable name, to have identical GASTs.
We want to further extend and generalize the notion of 
``similarity'' of program fixes, to let us reduce the 
gathered fixes into a small but widely applicable set 
of fix templates, which can then be used to train 
a repair predictor.


\label{subsec:clustering}
\begin{figure*}
\begin{minipage}{\textwidth}
\begin{lstlisting}[language=haskell, frame=single]
data Expr = Var | App Expr [Expr] | Bop Op Expr Expr | Hole | ..

sim :: Expr -> Expr -> Bool
sim e              Hole           = True
sim (Var x)        (Var y)        = x == y
sim (App f xs)     (App g ys)     = sim (f:xs) (g:ys)
sim (Bop o1 x1 y1) (Bop o2 x2 y2) = o1 == o2 && sim [x1,x2] [y1, y2]
sim _              _              = False

sim :: [Expr] -> [Expr] -> Bool
sim (e1:e1s) (e2:e2s)             = sim e1 e2 && sim e1s e2s
\end{lstlisting}
\end{minipage}
\caption{$\simil{e_1}{e_2}$ denotes when the GAST $e_1$ is similar to $e_2$.} 
\label{fig:similar}
\end{figure*}

\paragraph{GAST Similarity.}
%
\autoref{fig:similar} formalizes a relation that states when 
an expression $e_1$ is \emph{similar to} $e_2$  (written \simil{e_1}{e_2}).
%
Intuitevely, $e_1$ is similar to $e_2$ when at least one
of the following rules hold
\begin{enumerate}
    \item every expression is similar to a wildcard $\_$;

    \item the top-level non-terminal is the same their 
          sub-expressions are all pair-wise similar, \eg 
          two binary operator expressions are the same 
          if their operands are similar;

    \item a terminal expression is similar to another, only when 
    they are the same, \eg two variables are similar.
\end{enumerate}
%

\paragraph{Clustering.}
%%
The similarity relation defines a partial order on GAST 
terms. For example, $x + \_$ and $(x + y) + \_$ are both 
similar to $\_ + \_$, but they are not similar to each other. 
%
However, $\_ + \_$ will be chosen as the cluster representative 
(fix template) and all three will be in the same cluster.
%
\RJ{this is vague and doesn't make sense; TBD}
%%
The main goal of \emph{clustering} is to make our predictive models scalable and
applicable to more programs by avoiding assigning different templates to
equivalent expressions. We define clustering as the task of grouping together
similar expressions over \repairLang such that each group can then be used as a
fix template to produce repairs for ill-typed programs. Each group can consist
of several \emph{member-expressions} and one of them is the cluster
\emph{representative}.

The clustering algorithm uses the extracted fix templates and groups together
the templates that are similar based on our ealrier definition of expression
similarity. The most generic expression, \ie the expression whose GAST has the
smallest size (which in this context means the one with least number of nodes),
is the cluster representative. Holes $\_$ have a size of $0$, thus they don't
add up to the total size of a GAST.

For example, the following expressions: $\hat{x} \oplus \_$, $\_ \oplus \hat{x}$
and $\_ \oplus \_$ are all similar to one another and therefore will be placed
in the same cluster. However, $\_ \oplus \_$ is the smallest in size and thus
will be the cluster representative.

Finally, our clustering algorithm actually returns the top $N$ clusters based on
their member-expressions frequency in the dataset. $N$ is a parameter of the
algorithm that is chosen in a manner that the top $N$ clusters will
representative a large percentage of the dataset. We discuss more of its value
in \autoref{sec:eval}.
