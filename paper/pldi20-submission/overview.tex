\section{Overview}
\label{sec:overview}

We begin with an overview of our approach to suggesting fixes for various faulty
programs by collectively learning from the processes novice programmers follow
to fix errors in their programs.

\begin{figure}[ht]
\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> (hd * i) @ mulByDigit i tl
\end{ecode}

\begin{ecode}
let rec mulByDigit i l =
  match l with
  | []     -> []
  | hd::tl -> [hd * i] @ mulByDigit i tl
\end{ecode}
\caption{(top) An ill-typed \ocaml program that should multiply each element
of a list by an integer. (bottom) The fixed version by the student.}
\label{fig:mulByDigit}
\end{figure}


\paragraph{The Problem.} Consider the program \mbd shown at the top of
\autoref{fig:mulByDigit}, written by a student in an undergraduate Programming
course. The program is meant to multiply all the numbers in a list with an
integer digit. The student accidentally misuses the list append operator
(\texttt{@}), applying it to a number and a list rather than two lists.
%
Novice students who are still building a mental model of how the type checker
works are often perplexed by the compiler's error message \cite{FIXME}. Hence a
novice will often take a long time to arrive at a suitable fix, such as the one
shown at the bottom of \autoref{fig:mulByDigit}, where the append operator is
used with a singleton list containing the multiplication of the head \texttt{hd}
and \texttt{i}.
%
Our goal is to use historical data of how previous programmers have fixed
similar errors in their programs to automatically and rapidly guide the novice
to come up with candidate solutions like the one above.


\paragraph{Solution: Analytic Program Repair.}
%
One approach is to view the search for candidate repairs 
as a synthesis problem: synthesize a (small) set of edits 
to the program that yields a good (\eg type-correct) one.
%
To ensure that synthesis is tractable, the search must be 
carefully restricted to a relatively small, manually constructed 
``repair model'' that may not include the ``right'' fixes for 
an erroneous program.
%
In this work, we present a novel strategy called 
\emph{Analytic Program Repair} which breaks the 
problem into three parts:
%
First, \emph{learn} a set of widely used \emph{fix templates}.
%
Second, \emph{predict}, for each erroneous program, the correct fix template to apply.
%
Third, \emph{synthesize} candidate repairs from the predicted template.

In the remainder of this section, we give a high-level overview 
of our approach by describing how to:

\begin{enumerate}

  \item Represent fixes abstractly via \emph{fix templates}
        (\autoref{sec:overview:templates}),

  \item Acquire a \emph{training set} of labeled ill-typed programs and fixes
        (\autoref{sec:overview:data}),

  \item Learn a small set of candidate fix templates by \emph{partitioning}
        the training set (\autoref{sec:overview:learn}),

  \item Predict the appropriate template to apply by training a
        \emph{multi-class classifier} from the training set
        (\autoref{sec:overview:predict}), and

  \item Synthesize fixes by enumerating and checking terms from the
        predicted templates to give the programmer localized feedback
        (\autoref{sec:overview:synthesis}).
\end{enumerate}

\subsection{Representing Fixes}
\label{sec:overview:templates}

Our notion of a fix is defined as a \emph{replacement} of an existing expression
with a new \emph{candidate} expression at a specific program location. For
example, the \mbd program is fixed by replacing |(hd * i)| with the candidate
expression |[hd * i]| on line 4. We focus on AST-level replacements as it is
easy for novices to understand them and they are expressive enough to represent fix
templates. \BC{are they expressive enough to represent *fixes*? I ultimately
don't care about templates}


\paragraph{Generic Abstract Syntax Trees.}
%
We represent the different possible candidate expressions via abstract fix
templates called \emph{Generic Abstract Syntax Trees} (GAST) which each correspond to
many possible candidate expressions.
%
GASTs are obtained from concrete ASTs in two steps.
%
First, we abstract concrete variable, function, and operator names.
%
Next, we prune these GASTs at a certain depth $d$ to keep only the top-level
changes of the fix. Pruned sub-trees are replaced with \emph{holes}, which can
represent \emph{any} possible expression in our language.


Together, these steps ensure that GASTs only contain information about a fix's
\emph{structure} rather than the specific changes in variables and functions.
%
For example, the candidate expression |[hd * i]| in the \mbd example would be
represented by the GAST of the expression |[_ $\oplus$ _]|, where variables |hd|
and |i| are abstracted into holes (e.g. by pruning the GAST at a depth $d=2$)
and |*| is represented by an abstract binary operator. Our GAST approach
is somewhat similar to the template approach of FIXME, but we FIXME instead
of FIXME~\cite{FIXME}.


\subsection{Acquiring a Fix-Labeled Training Set}
\label{sec:overview:data}

Previous work has used experts to create a set of ill-typed programs and their
fixed versions~\citep[][]{Lerner2007-dt, Loncaric2016-uk}, or to manually create
\emph{fix templates} that can yield \emph{repair
patches}~\citep[][]{martinez2013automatically,martinez2015mining}.
%
This approach is hard to scale up to yield data sets suitable for machine
learning. Worse, manual inspection misses the \emph{frequency} of particular
classes of novice mistakes and their fixes. \BC{why? if I'm manually inspecting
anyway I can totally count how often things happen}
%
In contrast, we show that such fix templates can be \emph{learned} from a large,
automatically constructed training set of ill-typed programs labeled with their
repairs.
%
Fixes in our dataset are represented as the ASTs of the expressions that changed
in the ill-typed programs and transformed the program to the correct solution.
% and can be acquired via \emph{interaction traces}.

\paragraph{Interaction Traces.}
Following \citep{Seidel:2017} we extract a labeled dataset of erroneous programs
and their fixed versions from \emph{interaction traces}. Usually students write
several versions of their programs until they reach the correct solution for a
programming assignment. Previous work has used instrumented compilers to capture
such sequences (or \emph{traces}) of student programs. \BC{This sentence about
previous work is confusing - is it what you are doing as well, or is it in contrast?}
The first type-correct
solution in this sequence of program attempts is considered to be the fixed
version of all the previous ones and thus a pair for each of them is added to
the dataset.
% In our case, we used an existing dataset
% ~\citep[][]{yunounderstand, Seidel:2017} of ill-typed \ocaml programs
% \WRW{notes: this is the first thing you've written that has limited you to
% OCaml only --- everything before this was generic}
% \WRW{notes: why are you now talking about datasets in the algorithm
% overview section? shouldn't this be more like ``we require a dataset that
% has properties X, Y and Z'' and then later we can say ``for our evaluation,
% we trained on this ocaml dataset''?}
% and their fixes that were extracted using the aforementioned method.
For each program pair, we then produce a \emph{diff} of the abstract syntax
trees (ASTs), and assign as the dataset's fix labels, the \emph{smallest}
sub-tree that changed between the correct and ill-typed attempt of the program.


\subsection{Learning Candidate Fix Templates}
\label{sec:overview:learn}

Each labeled program in our dataset contains a fix, which we abstract to a fix
template. For example, in the \mbd program from \autoref{fig:mulByDigit} we get
the fix candidate |[hd * i]| and hence the fix template |[_ $\oplus$ _]|.
However, a large data set of fix-labeled programs, which may include many
diverse solutions, can introduce a huge set of fix templates, which can be
inappropriate for predicting the correct one to be used for the final program
repair.

Therefore, the next step in our approach is to learn a set of fix templates
that is \emph{small enough} to automatically predict which template to apply to
a given erroneous program, but nevertheless \emph{covers} most of the fixes that
arise in practice.

\paragraph{Partitioning the Fixes.} We learn a suitable small set of fix
templates by \emph{partitioning} all the templates obtained from our data set,
and then selecting a single GAST to represent the fix templates from each fix
template set.
%
The partitioning serves two purposes.
%
First, it identifies a small set of the most common fix templates which then
enables the use of discrete classification algorithms to predict which template
to apply to a new program.
%
Second, it allows for the principled removal of outliers that arise because
student submissions often contain non-standard or idiosyncratic solutions that
we do not wish to use for suggesting fixes.

Unlike previous repair approaches that have used clustering to make fix
templates (e.g.,~\cite{FIXME}), we partition our set of fix templates into
\emph{equivalence classes} based on a similarity relation over fix templates.


\subsection{Predicting Templates via Multi-class Classification}
\label{sec:overview:predict}

Next, we train models that can correctly predict error locations and fix
templates for a given ill-typed program. These models will be used to generate
candidate expressions as possible program fixes. In order to reduce the
complexity of predicting the correct fix templates and error locations, we
separate these problems and encode them into two distinct \emph{supervised
classification} problems, exploiting recent advances in machine learning.

\paragraph{Supervised Multi-Class Classification.}
We propose using a \emph{supervised multi-class classification} problem for
predicting fix templates. A \emph{supervised} learning problem is one
where,
given a labeled training set, the task is to learn a function that accurately
maps the inputs to output labels and generalizes to future inputs. In a
\emph{classification} problem, the function we are trying to learn maps inputs
to a discrete set of two or more output labels, called \emph{classes}.
Therefore, learning a function that will map subexpressions of ill-typed
programs to a small set of fix templates entails a \emph{multi-class}
classification (MCC) problem~\cite{FIXME}.

\paragraph{Feature Extraction.} The machine learning models that we will train to
solve our MCC problem expect datasets of labeled \emph{fixed-length vectors} as
inputs. Therefore, we define a transformation of fix-labeled programs to
fixed-length vectors. Similarly to previous work ~\citep{Seidel:2017}, we define
a set of feature extraction functions $f_1, \ldots, f_n$, that map program
subexpressions to a numeric value (or just $\{0, 1\}$ to encode a boolean
property). Given a set of feature extraction functions, we can represent a
single program's AST as a set of fixed-length vectors by decomposing a program
AST $e$ into a set of its constituent subexpressions $\{e_1, \ldots, e_m\}$ and
then representing each $e_i$ with the $n$-dimensional vector $[f_1(e_i), \ldots,
f_n(e_i)]$. This method is known as a \emph{bag-of-abstracted-terms} (BOAT)
representation in previous work.

\paragraph{Predicting Templates via MCC.}
Our fix-labeled data set can be updated so the labels represent the
corresponding template that fixes each location, drawn from the minimal set of
fix templates that were acquired through partitioning. We then train a
\emph{Deep Neural Network (DNN)} classifier on the updated template-labeled data
set, a popular choice for classification problems.

Neural networks have the advantage of associating each class with a
\emph{confidence score} that can be interpreted as the model's confidence of
each class being correct for a given input. This confidence score can be
used to rank fix-template predictions for new programs and use them in that
order to synthesize repairs until our high-level goal is reached. Finally, we
used deep and dense architectures~\cite{FIXME} to give a better confidence
to each template
\WRW{notes: do these D\&D architectures give us better precision on
the confidence value reported, or give us higher confidence overall?},
aiming for a higher accuracy for template predictions.

\paragraph{Error Localization.} We view the problem of finding error locations in a
new program as a \emph{binary} classification problem. In contrast with the
template prediction problem, we want to learn a function that maps a program's
subexpressions to a binary output representing the presence of an error or not.
Therefore, this problem is a equivalent to a MCC with only two classes and thus,
we use similar deep architectures of neural networks. For each expression in a
given program, the learned model outputs
a confidence score representing how likely it is an error location
that needs to be fixed. We exploit those scores to synthesize candidate
expressions for each location in descending order of confidence. We use
this approach, rather than standard fault localization, because FIXME.

\subsection{Synthesizing Feedback from Predicted Templates}
\label{sec:overview:synthesis}

Next, we utilize existing program synthesis techniques to \emph{synthesize}
candidate expressions that will be used to provide feedback to users. For efficiency, our
approach exploits the fix template predictions and a set of possible error
locations to guide program synthesis. We then
return a ranked list of \emph{minimal} repairs to users as feedback.

\paragraph{Program Synthesis.} Given a set of locations and candidate templates for
those locations, we are trying to solve a problem of \emph{program synthesis}.
For each program location, we search over all possible
expressions in the language's grammar for a small set of candidate
expressions that match the fix template and make the program type-check.
Expressions from the ill-typed program are also used in our synthesis algorithm
to further prune the search space of candidate expressions.

\paragraph{Synthesis for Multiple Locations.}
It is often the case that more than one location
needs to be fixed. Therefore, we do not only consider the ordered set
of single error locations for synthesis, but rather its power set.
For simplicity we treat the probabilities that different locations need to be fixed
as independent; the probability we assign that a set of locations needs to be fixed
is thus the product their individual confidence scores. This is unlike
recent approaches to multi-hunk program repair, such as
Hercules~\cite{FIXME}, in that we FIXME.

\paragraph{Ranking Fixes.} Finally, we rank each solution by two metrics, the
\emph{tree-edit distance} and the \emph{string-edit} distance. Previous work has
used those metrics to consider minimal changes, i.e. changes that are as close
as possible to the original programs, so novice programmers can better
understand feedback~\cite{FIXME}. However, different metrics may yield better
fixes, as we discuss later in Section FIXME. Some more experienced programmers
might have in mind what \emph{type} they want their functions to be. We thus
provide the user with the option to give the intended type for the program's
functions we are trying to repair. In our evaluation, we acquire the intended
types from the fixed versions of the dataset (see Section FIXME).

\begin{figure}[ht]
  \begin{ecode}
  let rec mulByDigit i l =
    match l with
    | []     -> []
    | hd::tl -> [(*@$v_1$@*) * (*@$v_2$@*)] @ mulByDigit i tl
  \end{ecode}
  \caption{A candidate repair for the \mbd program.}
  \label{fig:repair}
  \end{figure}

\paragraph{Example.} In \autoref{fig:repair} we can see a minimal repair that
our method could return (|[$v_1$ * $v_2$]| in line 4), using the template
discussed in \autoref{sec:overview:learn} to synthesize this solution. While
this solution is not the highest-ranked that our implementation returns (which
would be identical to the human solution), it demonstrates relevant aspects of
the synthesizer. In particular, this solution is very close to the human
solution, but it still has some abstracted variables, $v_1$ and $v_2$. Our
algorithm suggests to the user that they can replace the two abstracted
variables with two different variables in order to obtain the correct program.
We hypothesize that such solutions produced by our algorithm can provide
valuable feedback to novices, and we investigate that claim empirically in
Section FIXME.
