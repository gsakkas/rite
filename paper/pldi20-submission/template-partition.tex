\section{Learning Fix Templates}
\label{sec:templ-partition}

We start by introducing our approach for extracting useful \emph{fix templates}
from a training dataset comprising of erroneous-and-fixed programs.
%
We express those templates in terms of a language that allow us to succinctly
represent fixes in a way that captures the essential structure of various fix
patterns that novices use in practice.
%
However, extracting a single fix template for \emph{each} fix in the program
pair dataset yields too many templates to perform accurate predictions.
%
Hence, we define a \emph{similarity} relation between templates, which we use to
\emph{partition} the extracted templates into a smaller set, that will make it
easier to train precise models to predict fixes.

\input{syntax.tex}

\subsection{Representing User Fixes}
\label{sec:templ-partition:lang}

\paragraph{Repair Template Language.}
\autoref{fig:rtl-syntax} describes our Repair Template Language, \repairLang,
which is a lambda calculus with integers, booleans, pairs, and lists, that
extends our core ML language \lang (\autoref{fig:ml-syntax}) with several
syntactic abstraction forms:

\begin{enumerate}
    \item \emph{Abstract variable} names $\hat{x}$  are used to denote variable
    occurrences for functions, variables and binders, \ie $\hat{x}$ denotes
    an unknown variable name in \repairLang;

    \item \emph{Abstract literal} values $\hat{n}$ can represent \emph{any}
    integer or floating point number, boolean value or character and string;

    \item \emph{Abstract operators} $\oplus$ similarly denote unknown unary or
    binary operators;

    \item \emph{Wildcard} expressions $\_$ are used to represent \emph{any}
    expression in \repairLang, \ie a program \emph{hole}.
\end{enumerate}

Recall from \autoref{sec:overview:templates} that we define fixes as
replacements of expressions with new candidate expressions at specific program
locations. Therefore, we express candidate expressions over \repairLang as means
to represent our fix templates $\T$.

\paragraph{Generalizing ASTs.}
A \emph{Generic Abstract Syntax Tree} (GAST) is a term from \repairLang that
represents many possible expressions from \lang. GASTs are abstract from
standard ASTs over the core language \lang using the $\abstrsym$ function that
takes as input an expression $e^{ML}$ over \lang and a depth $d$ and returns an
expression $e^{RTL}$ over \repairLang, \ie a GAST with all variables, literals
and operators of $e^{ML}$ abstracted and all subexpressions starting at depth
greater than $d$ pruned and replaced with holes $\_$.

\input{gast-example.tex}

\paragraph{Example.}
Recall our example program \mbd in \autoref{fig:mulByDigit}.
%
The expression |[hd * i]| replaces |(hd * i)| in line 4, and hence, is the
user's \emph{fix}, whose AST is given in \autoref{fig:fix_ast}.
%
The output of $\abstrsym$, given this AST and a depth $d = 2$ as input, would be
the GAST in \autoref{fig:templ_gast}, where the operator |*| has been replaced
with an abstract operator $\oplus$, and the sub-terms |hd| and |i| at depth 2
have been abstracted to wildcard expressions $\_$.
%
Hence, the \repairLang term |[_ $\oplus$ _]| represents a potential fix template
for \mbd.

\subsection{Extracting Fix Templates from a Dataset}
\label{sec:templ-partition:templates}

Our approach fully automates the extraction of fixes by harvesting a set of fix
templates from a training set of program pairs.
%
Given a program pair $(\pbad, \pfix)$ from the dataset, we extract a unique fix
for each location in $\pbad$ that changed in $\pfix$.
%
We do so with an expression-level $\diffsym$~\citep{Lempsink2009-xf} function.
%
Recall again that we consider fixes to be replacements of expressions, and
therefore we use the extracted changes as our fix templates.

\paragraph{Contextual Repairs.}
%
Following \cite{Felleisen92} let $\econtext{}$ be the \emph{context} that an
expression $e$ appears in a program $p$, \ie the program $p$ with expression $e$
replaced with a hole $\_$.
%
We write that $p = \context{}{e}$, meaning that if we fill the hole with the
original expression $e$ we obtain the original program $p$.
%
In this fashion, $\diffsym$ finds a \emph{minimal} (in number of nodes)
expression replacement $\efix$ for an expression $\ebad$ in $\pbad$, such that
$\pbad = \context{\pbad}{\ebad}$ and $\context{\pbad}{\efix} = \pfix$.
%
There may be several such expressions in a program, and $\diffsym$ returns all
such changes.

\paragraph{Example.}
If a new expression has been inserted \emph{around} an existing expression, \eg
if $\eapp{f}{x}$ is rewritten to $\eapp{g}{x}$, we will have that the context is
$\econtext{} = \eapp{\_}{x}$, where $\_$ represents the hole, and then the fix
will be $g$, since $\context{}{g} = \eapp{g}{x}$.

If instead, an expression has been replaced wholesale with another expression,
\eg if $\eapp{f}{x}$ is rewritten to $\eplus{(\eapp{f}{x})}{1}$, the
\emph{context} will be the more general $\econtext{} = \_$, since we consider
the application expression $\eapp{f}{x}$ (but not $f$ or $x$) to be replaced
with the $+$ operator, and therefore the fix will be the whole expression, thus
$\context{}{\eplus{(\eapp{f}{x})}{1}} = \eplus{(\eapp{f}{x})}{1}$.
% TODO: maybe talk about the drawback of the last choice

\subsection{Partitioning the Templates}

Programs over \lang force similar fixes, such as changes to variable names, to
have identical GASTs. Our next step is to define a notion of program fix
\emph{similarity}. Our definition supports the formation of a small but widely
applicable set of fix templates. This small set is used to train a repair
predictor.

\label{subsec:partitioning}
\begin{figure*}
\begin{minipage}{\textwidth}
\begin{haskellcode}
==data Expr== = Var | Bop Expr Expr | App [Expr] | Hole | ..

==sim :: Expr -> Expr -> Bool==
sim e           Hole        = True
sim Var         Var         = True
sim (Bop x1 y1) (Bop x2 y2) = sim [x1, x2] [y1, y2] ==||== sim [y1, y2] [x1, x2]
sim (App xs)    (App ys)    = any (\ys' -> any (\xs' -> sim xs' ys') xss) yss
    where
        xss = permutations xs
        yss = permutations ys
sim _           _           = False

==sim :: [Expr] -> [Expr] -> Bool==
sim (x:xs) (y:ys) = sim x y && sim xs ys
\end{haskellcode}
\end{minipage}
\caption{$\simil{e_1}{e_2}$ denotes when the GAST $e_1$ is similar to $e_2$.}
\label{fig:similar}
\end{figure*}

\paragraph{GAST Similarity.}
%
\autoref{fig:similar} formalizes a relation that states when
an expression $e_1$ is \emph{similar to} $e_2$  (written \simil{e_1}{e_2}).
%
Intuitively, $e_1$ is similar to $e_2$ when at least one of the following rules
hold
\begin{enumerate}
    \item every expression is similar to a wildcard $\_$;

    \item the top-level non-terminal is the same and there is a total bijective
        relation between their sub-expressions \st they are all pair-wise
        similar, \eg two binary operator expressions are the same if their
        operands are similar;
        % \eg $e_{11} \oplus e_{12}$ and $e_{21} \oplus e_{22}$ are
        % similar \textit{iff} $(e_{11}, e_{21})$ and $(e_{12}, e_{22})$ or
        % $(e_{11}, e_{22})$ and $(e_{12}, e_{21})$ are pair-wise similar.

    \item a terminal expression is similar to another, only when they are the
    same, \eg two variables are similar.
\end{enumerate}
%


% TODO: partition is novel? compare to previous work
\paragraph{Partitioning.}
The GAST similarity we defined is both symmetric and transitive and thus is an
\emph{equivalence} relation. We can now define \emph{partitioning} as the
computation of all possible \emph{equivalence classes} of our extracted fix
templates \wrt our GAST similarity relation. Each class can consist of several
member-expressions and each one of them can be viewed as the class
\emph{representative}. Each equivalence class representative can then be used as
a fix template to produce repairs for ill-typed programs.

For example, expressions $\hat{x} \oplus (\hat{y} \oplus \hat{z})$ and $(\hat{x}
\oplus \hat{y}) \oplus \hat{z}$ are similar and therefore they will be in the
same class. Either one can be used as the representative and our repair
algorithm in \autoref{sec:synthesis} will essentially consider both when fixing
an erroneous program with this template.

Finally, our partitioning algorithm returns the top $N$ equivalence classes
based on their member-expressions frequency in the dataset. $N$ is a parameter
of the algorithm and is chosen to be as small as possible while the top $N$
classes represent a large enough portion of the dataset. We discuss more of its
value in \autoref{sec:eval}.
