\section{Repair Synthesis from Templates}
\label{sec:synthesis}
We use an \emph{enumerative} program synthesis algorithm to fully repair a
program using the predicted templates and locations of our neural network
models. In \autoref{subsec:location-rank}, we show how we fix \emph{multiple}
error locations in a single program, and in \autoref{subsec:local-synthesis}, we
present our synthesis algorithm for producing \emph{local repairs} for a given
program location.
% Finally, we briefly show in \autoref{subsec:repair} how we use the
% aforementioned techniques to \emph{fully repair} an ill-typed program.

\subsection{Ranking Error Locations}
\label{subsec:location-rank}

\paragraph{Error Location Confidence}
Recall from \autoref{sec:templ-pred} that for each location in a program's
type-error slice, our $\Model$ generates a confidence score $\Conf$ of that
location containing an error that needs to be fixed, and our $\ModelT$ generates
the repair templates' confidence scores.

Our synthesis algorithm ranks all program locations based on their confidence
scores $\Conf$. For all locations in descending order of their confidence
scores, a fix template is used to produce a repair. Fix templates are also
considered in descending order of confidence. If the algorithm fails to
synthesize a program that type-checks, the next location is considered, until it
succeeds.

\paragraph{Multiple Error Locations}
In practice, however, frequently more than one location needs to be repaired. We
extend the above approach to synthesize programs with multiple error locations.

Let the confidence scores $\Conf$ for all locations in the type error slice from
our error localization model $\Model$ be $(l_1, c_1), \dots, (l_k, c_k)$, where
$l_i$ is a program location and $c_i$ its confidence score. We assume for
simplicity that the probabilities $c_i$ are independent. With that assumption,
the probability that both locations $l_i$ and $l_j$ need to be fixed is $c_i
\cdot c_j$. The same holds for more that two locations. Therefore, we extend our
simple algorithm of synthesizing fixes for a single location $l$, by adding the
combined scores of tuples $(l_i, l_j)$, triples $(l_i, l_j, l_K)$, etc. of
program locations in the ranked list of error locations.
% In practice we only consider up to \emph{five} locations to be fixed
% simultaneously; any more than that takes too much time to generate and has too
% small a chance of leading to a good solution.


\subsection{Local Synthesis from Templates}
\label{subsec:local-synthesis}

\paragraph{Enumerative Program Synthesis}
Our synthesis algorithm is a classic \emph{enumerative} program synthesis method
guided by an input template. Enumerative synthesis searches all possible
expressions over a language, starting from an empty program, until a high-level
specification is reached. In our case, we only try to synthesize a part of the
program that already captures the intent of the user and therefore our only
specification is that the repaired program is type-safe. However, we can also
extend this specification by allowing our algorithm to search for programs that
type-check but have the user's desired type signature for the specific program.

Given a location $l$ and a template $t$, our algorithm searches over all
possible expressions over \lang that will satisfy those goals by generating a
\emph{local repair} that expands the $t$'s GAST. One advantage of this technique
is that we can exploit the expression $e$ at location $l$ to further guide our
synthesis, since subexpressions used by the programmer at $l$ are usually reused
for their final repair.

\input{local-repair.tex}

\paragraph{Generating Local Repairs with Templates}
Using our \textsc{Enumerate} method, we lazily generate local repairs $R$ for
each subset of locations that is highest in confidence score. The
\textsc{Enumerate} method starts to fill in a template $T$ for location $L$ of
the program $P$ based on the context-free grammar $\lang$. It starts from the
parent node at the first level of the template $T$ and incrementally moves
down the tree. When a hole is found in the tree, the algorithm tries to expand
the tree one more level using $\lang$'s production rules $R$. The production
rules are considered in an ranked order based on the subexpressions that already
appear in $P$'s location $L$ and the template $T$. It then applies it to the
template $T$. If the node $\tilde{\alpha}$ was not a hole, terminals from the
the program $P$, the expression $\alpha$ at the location $L$ and the grammar
$\lang$ are used to fill that node, depending on what terminals where used from
$\repairLang$. For example, $\repairLang$'s operator $\oplus$ can be replaced
with $+,\:-,\:\etc$

After the template $T$ had some changes applied to it, we get an
\emph{instantiated} template $\tilde{T}$, which then replaces the expression at
location $L$. If the new program $\tilde{P}$ type-checks, it is inserted into
the list of generated solutions $R$. The list of candidate solutions $R$ is
generated lazily in practice and the top-N can be requested for the user
depending on the level of feedback that is needed.


% \subsection{Program Repair}
% \label{subsec:repair}

% \paragraph{Combining Error Localization and Local Repairs}
