typePat: ConPat: ("VarX",([],Just (WildPat (Just (13,9)-(13,10)))))
typePat: ConPat: ("VarY",([],Just (WildPat (Just (14,9)-(14,10)))))
NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let a = (1, 2);;

let buildX () = VarX;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval ((buildX ()), a, y))
  | Cosine a -> x
  | Average (a,b) -> x
  | Times (a,b) -> x
  | Thresh (a,b,c,d) -> x;;

[(15,3)-(23,27),(15,14)-(23,25),(16,2)-(23,25),(16,2)-(23,25),(17,13)-(17,14),(19,14)-(19,17),(19,14)-(19,44),(19,18)-(19,44),(19,19)-(19,23),(19,24)-(19,43),(19,38)-(19,39)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let a = (1, 2);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval (a, x, y))
  | Cosine a -> x
  | Average (a,b) -> x
  | Times (a,b) -> x
  | Thresh (a,b,c,d) -> x;;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval (e, x, a))
  | Cosine a -> cos (pi *. y);;

[(13,3)-(18,31),(13,14)-(18,29),(14,2)-(18,29),(17,18)-(17,34),(17,19)-(17,23),(17,24)-(17,33),(17,31)-(17,32),(18,20)-(18,29),(18,27)-(18,28)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval (a, x, y))
  | Cosine a -> cos (pi *. y);;

NO OVERLAP CORE/DIFF

let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in
      let base = if (List.length sl) > 1 then h else h in
      let l = t in List.fold_left f base l;;

let stringOfList f l = List.map (sepConcat (";", l));;

[(2,3)-(8,44),(2,18)-(8,42),(6,51)-(6,60),(6,52)-(6,55),(6,56)-(6,57),(10,32)-(10,52),(10,33)-(10,42),(10,43)-(10,51)]

let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in
      let base = h in let l = t in List.fold_left f base l;;

let stringOfList f l = sepConcat ";" (List.map f l);;

NO OVERLAP CORE/DIFF

let rec clone x n =
  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;

let padZero l1 l2 =
  let length1 = List.length l1 in
  let length2 = List.length l2 in
  match length1 >= length2 with
  | true  ->
      let n = length1 - length2 in
      let zeroes = clone 0 n in (l1, (List.append zeroes l2))
  | false  ->
      let n = length2 - length1 in
      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;

let rec removeZero l =
  match l with
  | [] -> []
  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      match a with
      | (carry,result) ->
          (match x with
           | (h1::t1,h2::t2) ->
               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in
    let base = (0, []) in
    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;

[(30,4)-(30,74),(30,15)-(30,23),(30,41)-(30,55),(30,41)-(30,67),(30,63)-(30,67)]

let rec clone x n =
  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;

let padZero l1 l2 =
  let length1 = List.length l1 in
  let length2 = List.length l2 in
  match length1 >= length2 with
  | true  ->
      let n = length1 - length2 in
      let zeroes = clone 0 n in (l1, (List.append zeroes l2))
  | false  ->
      let n = length2 - length1 in
      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;

let rec removeZero l =
  match l with
  | [] -> []
  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;

let bigAdd l1 l2 =
  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;

NO OVERLAP CORE/DIFF

let rec digitsOfInt n =
  let myList = [] in
  if n <= 0 then [] else (n mod 10) :: ((myList n) mod 100) :: myList;;

[(3,2)-(4,69),(3,15)-(3,17),(4,40)-(4,50),(4,41)-(4,47)]

let rec digitsOfInt n =
  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;

NO OVERLAP CORE/DIFF

let wwhile (f,b) =
  let rec helper (f,b) (x,y) =
    match y with | true  -> helper (f, x) (f b) | false  -> x in
  helper (f, b) (b, true);;

let fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (f, b);;

[(2,3)-(5,27),(2,12)-(5,25),(4,28)-(4,34),(4,28)-(4,47),(4,35)-(4,41),(4,36)-(4,37),(4,42)-(4,47),(4,43)-(4,44),(5,2)-(5,8),(5,2)-(5,25),(5,9)-(5,15),(5,10)-(5,11),(5,16)-(5,25),(5,17)-(5,18),(7,39)-(7,50),(7,39)-(7,50),(7,40)-(7,41),(7,44)-(7,49),(7,45)-(7,46),(7,55)-(7,61),(7,55)-(7,68),(7,62)-(7,68),(7,63)-(7,64),(7,66)-(7,67)]

let wwhile (f,b) =
  let rec helper (f,b) (x,y) =
    match y with | true  -> helper (f, x) (f b) | false  -> x in
  helper (f, b) (b, true);;

let fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, b);;

