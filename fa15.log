typePat: ConPat: ("TimesThree",([TApp "expr" [],TApp "expr" [],TApp "expr" []],Just (VarPat (Just (18,15)-(18,16)) "e")))
typeExpr: ConApp: ("Average",([TApp "expr" [],TApp "expr" []],Nothing))
typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (17,12)-(17,13)) "e")))
typePat: ConPat: ("Times",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (19,10)-(19,11)) "e")))
typePat: ConPat: ("Thresh",([TApp "expr" [],TApp "expr" [],TApp "expr" [],TApp "expr" []],Just (VarPat (Just (20,11)-(20,12)) "e")))
type  expr =
| VarX
| VarY
| Sine of expr
| Cosine of expr
| Average of expr * expr
| Times of expr * expr
| Thresh of expr * expr * expr * expr
let rec exprToString =
  fun e ->
    match e with
    | VarX -> "e"
    | VarY -> "e"
    | Sine e -> "sin(pi*" ^ (exprToString e ^ ")")
    | Cosine e -> "cos(pi*" ^ (exprToString e ^ ")")
    | Average e -> "((" ^ (exprToString e ^ ("+" ^ (exprToString e ^ ")/2)")))
    | Times e -> exprToString e ^ ("" ^ exprToString e)
    | Thresh e -> "(" ^ (exprToString e ^ ("<" ^ (exprToString e ^ (" ? " ^ (exprToString e ^ (" : " ^ (exprToString e ^ ")")))))))
------------------------------------------

typePat: ConPat: ("Golden",([TApp "expr" []],Nothing))
typePat: ConPat: ("MeanPi",([TApp "expr" [],TApp "expr" [],TApp "expr" []],Nothing))
type  expr =
| VarX
| VarY
| Sine of expr
| Cosine of expr
| Average of expr * expr
| Times of expr * expr
| Thresh of expr * expr * expr * expr
| Golden of expr
| MeanPi of expr * expr * expr
let rec exprToString =
  fun e ->
    match e with
    | VarX -> "x"
    | VarY -> "y"
    | Sine expr -> "sin(pi*" ^ (exprToString expr ^ ")")
    | Cosine expr -> "cos(pi*" ^ (exprToString expr ^ ")")
    | Average (expr1 , expr2) -> "(" ^ (exprToString expr1 ^ ("+" ^ (exprToString expr2 ^ ")/2")))
    | Times (expr1 , expr2) -> exprToString expr1 ^ ("*" ^ exprToString expr2)
    | Thresh (expr1 , expr2 , expr3 , expr4) -> "(" ^ (exprToString expr1 ^ ("<" ^ (exprToString expr2 ^ ("?" ^ (exprToString expr3 ^ (":" ^ (exprToString expr4 ^ ")")))))))
    | Golden -> ""
    | MeanPi -> ""
------------------------------------------

typePat: ConPat: ("Sine",([TApp "expr" []],Nothing))
typePat: ConPat: ("Cosine",([TApp "expr" []],Nothing))
typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Nothing))
typePat: ConPat: ("Times",([TApp "expr" [],TApp "expr" []],Nothing))
typePat: ConPat: ("Thresh",([TApp "expr" [],TApp "expr" [],TApp "expr" [],TApp "expr" []],Nothing))
let pipe =
  fun fs ->
    (let f =
       fun a -> fun x -> x a in
     let base = fun x -> [] in
     List.fold_left f base fs)
------------------------------------------

let rec listReverse =
  fun l ->
    match l with
    | [] -> []
    | h :: t -> [h]
------------------------------------------

typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (17,12)-(17,13)) "v")))
typePat: ConPat: ("Sine",([TApp "expr" []],Nothing))
typePat: ConPat: ("Cosine",([TApp "expr" []],Nothing))
typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Nothing))
typePat: ConPat: ("Times",([TApp "expr" [],TApp "expr" []],Nothing))
type  expr =
| VarX
| VarY
| Sine of expr
| Cosine of expr
| Average of expr * expr
| Times of expr * expr
| Thresh of expr * expr * expr * expr
let rec exprToString =
  fun e ->
    match e with
    | VarX -> "VarX"
    | VarY -> "VarY"
    | Sine -> "Sine(" ^ (exprToString e ^ ")")
    | Cosine -> "Cosine(" ^ (exprToString e ^ ")")
    | Average -> "Average(" ^ (exprToString e ^ ")")
    | Times -> "Times(" ^ (exprToString e ^ ")")
    | Thresh (a , b , c , d) -> "Thresh(" ^ (exprToString a ^ ("," ^ (exprToString b ^ ("," ^ (exprToString c ^ ("," ^ (exprToString d ^ ")")))))))
------------------------------------------

type  expr =
| VarX
| VarY
| Sine of expr
| Cosine of expr
| Average of expr * expr
| Times of expr * expr
| Thresh of expr * expr * expr * expr
let rec exprToString =
  fun e ->
    match e with
    | VarX -> "x"
    | VarY -> "y"
    | Sine expr -> "sin(pi*" ^ (exprToString expr ^ ")")
    | Cosine expr -> "cos(pi*" ^ (exprToString expr ^ ")")
    | Average (expr , expr) -> "((" ^ (exprToString expr ^ (" + " ^ (exprToString expr ^ ")/2)")))
    | Times (expr , expr) -> exprToString expr ^ ("*" ^ exprToString expr)
    | Thresh (expr , expr , expr , expr) -> "(" ^ (exprToString expr ^ ("<" ^ (exprToString expr ^ (" ? " ^ (exprToString expr ^ (" : " ^ (exprToString expr ^ ")")))))))
------------------------------------------

typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (17,12)-(17,13)) "n")))
typePat: ConPat: ("VarX",([],Just (VarPat (Just (13,9)-(13,10)) "n")))
typePat: ConPat: ("VarY",([],Just (VarPat (Just (14,9)-(14,10)) "n")))
typePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (17,12)-(17,13)) "n")))
typeExpr: ConApp: ("Times",([TApp "expr" [],TApp "expr" []],Nothing))
type  expr =
| VarX
| VarY
| Sine of expr
| Cosine of expr
| Average of expr * expr
| Times of expr * expr
| Thresh of expr * expr * expr * expr
let rec build =
  fun (rand , depth) ->
    if depth = 0
    then (let g = rand (0 , 1) in
          match g with
          | 0 -> VarX
          | 1 -> VarY)
    else (let g = rand (0 , 4) in
          match g with
          | 0 -> Sine (build (rand , depth - 1))
          | 1 -> Cosine (build (rand , depth - 1))
          | 2 -> Average (build (rand , depth - 1) , build (rand , depth - 1))
          | 3 -> Times (build (rand , depth - 1) , build (rand , depth - 1))
          | 4 -> Thresh (build (rand , depth - 1) , build (rand , depth - 1)))
------------------------------------------

typePat: ConPat: ("Cube",([TApp "expr" []],Nothing))
typePat: ConPat: ("MultDivBy6",([TApp "expr" [],TApp "expr" []],Nothing))
("minimizeCore",1,1)
MkConstraint {constraintSpan = Just (14,2)-(26,71), ct_t1 = TApp "expr" [], ct_t2 = TTup [TVar "t110",TVar "t111"]}
NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let isFPoint s = ((f s) - s) < 0 in
  let iterate (t,y) = t y in
  let rec go r = if isFPoint r then r else go (iterate (f, r)) in
  wwhile ((go, true), b);;

[(3,12)-(3,13),(3,12)-(3,15),(4,42)-(4,48),(4,42)-(4,55),(4,49)-(4,55),(4,50)-(4,51),(10,2)-(10,8),(10,2)-(10,24),(10,9)-(10,24),(10,10)-(10,20)]

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in
  wwhile (gs, b);;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let isFPoint s = ((f s) - s) < 0 in
  let iterate (t,y) = t y in
  let rec go r = if isFPoint r then r else go (iterate (f, r)) in
  wwhile (go, (isFPoint b), b);;

[(4,42)-(4,48),(4,42)-(4,55),(4,49)-(4,55),(10,2)-(10,8),(10,2)-(10,30),(10,9)-(10,30)]

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in
  wwhile (gs, b);;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let isFPoint s = ((f s) - s) < 0 in
  let iterate (t,y) = t y in
  let rec go r = if isFPoint r then r else go (iterate (f, r)) in
  wwhile ((go, (isFPoint b)), b);;

[(3,12)-(3,13),(3,12)-(3,15),(4,42)-(4,48),(4,42)-(4,55),(4,49)-(4,55),(4,50)-(4,51),(10,2)-(10,8),(10,2)-(10,32),(10,9)-(10,32),(10,10)-(10,28)]

let rec wwhile (f,b) =
  let res = f b in
  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;

let fixpoint (f,b) =
  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in
  wwhile (gs, b);;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Mirana of expr
  | Darius of expr* expr* expr;;

let buildAverage (e1,e2) = Average (e1, e2);;

let buildCosine e = Cosine e;;

let buildSine e = Sine e;;

let buildThresh (e1,e2,e3) = Darius (e1, e2, e3);;

let buildTimes (e1,e2) = Times (e1, e2);;

let buildX () = VarX;;

let buildY () = VarY;;

let rec build (rand,depth) =
  match ((rand (2, 6)), depth) with
  | (c,0) -> if c > 3 then buildX () else buildY ()
  | (2,_) -> buildSine (build (rand, (depth - 1)))
  | (3,_) -> buildCosine (build (rand, (depth - 1)))
  | (4,_) ->
      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | (5,_) ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | (6,_) ->
      buildThresh
        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),
          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;

[(19,3)-(19,50),(19,17)-(19,48),(37,6)-(37,17),(37,6)-(39,67),(38,8)-(39,67)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Mirana of expr
  | Darius of expr* expr* expr;;

let buildAverage (e1,e2) = Average (e1, e2);;

let buildCosine e = Cosine e;;

let buildDarius (e1,e2,e3) = Darius (e1, e2, e3);;

let buildMirana e = Mirana e;;

let buildSine e = Sine e;;

let buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;

let buildTimes (e1,e2) = Times (e1, e2);;

let buildX () = VarX;;

let buildY () = VarY;;

let rec build (rand,depth) =
  match ((rand (2, 8)), depth) with
  | (c,0) -> if c > 3 then buildX () else buildY ()
  | (2,_) -> buildSine (build (rand, (depth - 1)))
  | (3,_) -> buildCosine (build (rand, (depth - 1)))
  | (4,_) ->
      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | (5,_) ->
      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | (6,_) ->
      buildThresh
        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),
          (build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | (7,_) -> buildMirana (build (rand, (depth - 1)))
  | (8,_) ->
      buildDarius
        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),
          (build (rand, (depth - 1))));;

NO OVERLAP CORE/DIFF

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  match digits n with | x::[] -> 0 | _ -> additivePersistence (sumList n);;

[(5,3)-(5,36),(5,11)-(5,34),(5,27)-(5,34),(5,28)-(5,31),(5,32)-(5,33),(7,21)-(7,70),(7,21)-(7,70),(7,59)-(7,70),(7,60)-(7,67),(7,68)-(7,69),(10,8)-(10,14),(10,8)-(10,16),(10,15)-(10,16),(10,62)-(10,73),(10,63)-(10,70),(10,71)-(10,72)]

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  match digits n with
  | x::[] -> 0
  | n -> 1 + (additivePersistence (sumList n));;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Sqrt of expr
  | Average of expr* expr
  | Times of expr* expr
  | ExtremeExp of expr* expr* expr
  | Thresh of expr* expr* expr* expr;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e1 -> sin (pi *. (eval (e1, x, y)))
  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))
  | Sqrt e1 -> sqrt (abs (eval (e1, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | ExtremeExp (e1,e2,e3) ->
      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;

[(19,19)-(19,44),(19,26)-(19,43),(19,27)-(19,31),(21,20)-(21,43),(21,21)-(21,24),(21,25)-(21,42),(21,26)-(21,30)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Sqrt of expr
  | Average of expr* expr
  | Times of expr* expr
  | ExtremeExp of expr* expr* expr
  | Thresh of expr* expr* expr* expr;;

let abs x = if x > 0.0 then x else -. x;;

let pi = 4.0 *. (atan 1.0);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e1 -> sin (pi *. (eval (e1, x, y)))
  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))
  | Sqrt e1 -> sqrt (abs (eval (e1, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | ExtremeExp (e1,e2,e3) ->
      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) =
  wwhile
    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f' b), b);;

[(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(6,2)-(6,8),(6,2)-(7,77),(7,4)-(7,77),(7,5)-(7,73),(7,5)-(7,73),(7,13)-(7,64),(7,17)-(7,64),(7,35)-(7,44),(7,68)-(7,70),(7,68)-(7,72)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) =
  wwhile ((let f' b = if (f b) = b then b else f b in f' f b), b);;

[(6,10)-(6,61),(6,18)-(6,50),(6,47)-(6,48),(6,47)-(6,50),(6,49)-(6,50),(6,54)-(6,56),(6,54)-(6,60),(6,57)-(6,58)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OtypePat: ConPat: ("Average",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (17,12)-(17,13)) "v")))
typePat: ConPat: ("Times",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (19,10)-(19,11)) "v")))
VERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) = wwhile ((let f' b = (f b) = b in f' b), b);;

[(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(5,21)-(5,27),(5,21)-(5,63),(5,28)-(5,63),(5,29)-(5,59),(5,29)-(5,59),(5,37)-(5,50),(5,41)-(5,50),(5,54)-(5,56),(5,54)-(5,58)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) =
  wwhile ((let f' b = if (f b) = b then b else f b in f' b), b);;

[(3,2)-(3,63),(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(3,52)-(3,54),(6,2)-(6,8),(6,2)-(6,63),(6,9)-(6,63),(6,10)-(6,59),(6,10)-(6,59),(6,18)-(6,50),(6,22)-(6,50),(6,25)-(6,30),(6,25)-(6,34),(6,25)-(6,34),(6,26)-(6,27),(6,33)-(6,34),(6,47)-(6,48),(6,47)-(6,50),(6,54)-(6,56),(6,54)-(6,58),(6,57)-(6,58),(6,61)-(6,62)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) =
  wwhile ((let f' b' = if (f b) = b then b else f b in f' b), b);;

[(3,2)-(3,63),(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(3,52)-(3,54),(6,2)-(6,8),(6,2)-(6,64),(6,9)-(6,64),(6,10)-(6,60),(6,10)-(6,60),(6,18)-(6,51),(6,23)-(6,51),(6,26)-(6,31),(6,26)-(6,35),(6,26)-(6,35),(6,27)-(6,28),(6,34)-(6,35),(6,48)-(6,49),(6,48)-(6,51),(6,55)-(6,57),(6,55)-(6,59),(6,62)-(6,63)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) =
  wwhile ((let f' b' = if (f b') = b then b else f b' in f' b), b);;

[(3,2)-(3,63),(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(3,52)-(3,54),(6,2)-(6,8),(6,2)-(6,66),(6,9)-(6,66),(6,10)-(6,62),(6,10)-(6,62),(6,18)-(6,53),(6,23)-(6,53),(6,26)-(6,32),(6,26)-(6,36),(6,26)-(6,36),(6,27)-(6,28),(6,35)-(6,36),(6,49)-(6,50),(6,49)-(6,53),(6,57)-(6,59),(6,57)-(6,61),(6,64)-(6,65)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) = wwhile ((f, (b, (if (f b) == b then b else f b))), b);;

[(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(5,21)-(5,27),(5,21)-(5,74),(5,28)-(5,74),(5,29)-(5,70)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

let fixpoint (f,b) = wwhile ((f, b), b);;

[(3,8)-(3,9),(3,8)-(3,11),(3,41)-(3,47),(3,41)-(3,55),(3,48)-(3,55),(3,49)-(3,50),(5,21)-(5,27),(5,21)-(5,39),(5,28)-(5,39),(5,29)-(5,35)]

let rec wwhile (f,b) =
  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Cosine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Average (v,w) ->
      "(" ^ ((exprToString v) ^ ("+" ^ ((exprToString w) ^ ")/2")))
  | Times (v,w) -> (exprToString v) ^ ("*" ^ (exprToString w))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

[(28,2)-(39,69),(28,2)-(39,69),(28,2)-(39,69),(31,14)-(31,17),(31,14)-(31,42),(33,21)-(33,59),(33,21)-(33,63),(33,21)-(33,63),(36,6)-(39,69),(36,23)-(36,24)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Cosine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Average (v,w) ->
      "(" ^ ((exprToString v) ^ ("+" ^ ((exprToString w) ^ ")/2")))
  | Times (v,w) -> (exprToString v) ^ ("*" ^ (exprToString w))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi * (eval (v, x, y)))
  | Cosine v -> cos (pi * (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2
  | Times (v,w) -> (eval (v, x, y)) * (eval (w, x, y))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

[(27,2)-(39,69),(27,11)-(27,16),(28,2)-(39,69),(28,2)-(39,69),(31,14)-(31,17),(31,14)-(31,41),(31,18)-(31,41),(31,18)-(31,41),(31,19)-(31,21),(32,16)-(32,19),(32,16)-(32,43),(32,20)-(32,43),(32,20)-(32,43),(32,21)-(32,23),(33,21)-(33,62),(36,6)-(39,69),(36,23)-(36,24)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Cosine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Average (v,w) ->
      "(" ^ ((exprToString v) ^ ("+" ^ ((exprToString w) ^ ")/2")))
  | Times (v,w) -> (exprToString v) ^ ("*" ^ (exprToString w))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

[(28,2)-(39,69),(28,2)-(39,69),(31,14)-(31,17),(31,14)-(31,42),(33,21)-(33,64),(33,63)-(33,64),(36,6)-(39,69),(36,23)-(36,24)]

tytypePat: ConPat: ("VarX",([],Just (WildPat (Just (23,9)-(23,10)))))
typePat: ConPat: ("VarY",([],Just (WildPat (Just (24,9)-(24,10)))))
typeExpr: ConApp: ("Average",([TApp "expr" [],TApp "expr" []],Just (Bop (Just (19,29)-(19,75)) Div (Bop (Just (19,30)-(19,68)) FPlus (App (Just (19,31)-(19,47)) (Var (Just (19,32)-(19,36)) "eval") [Tuple (Just (19,37)-(19,46)) [Var (Just (19,38)-(19,39)) "e",Var (Just (19,41)-(19,42)) "x",Var (Just (19,44)-(19,45)) "y"]]) (App (Just (19,51)-(19,67)) (Var (Just (19,52)-(19,56)) "eval") [Tuple (Just (19,57)-(19,66)) [Var (Just (19,58)-(19,59)) "e",Var (Just (19,61)-(19,62)) "x",Var (Just (19,64)-(19,65)) "y"]])) (Lit (Just (19,71)-(19,74)) (LD 2.0)))))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (28,11)-(28,13)) "i1")))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (29,11)-(29,12)) "i")))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (29,11)-(29,13)) "i1")))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (26,11)-(26,12)) "i")))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (27,11)-(27,12)) "i")))
typePat: ConPat: ("Square",([TApp "expr" [],TApp "expr" []],Just (VarPat (Just (27,11)-(27,12)) "i")))
typePat: ConPat: ("Thresh",([TApp "expr" [],TApp "expr" [],TApp "expr" [],TApp "expr" []],Nothing))
pe expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;

NO OVERLAP CORE/DIFF

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec exprToString e =
  match e with
  | VarX  -> "x"
  | VarY  -> "y"
  | Sine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Cosine v -> "sin(pi*" ^ ((exprToString v) ^ ")")
  | Average (v,w) ->
      "(" ^ ((exprToString v) ^ ("+" ^ ((exprToString w) ^ ")/2")))
  | Times (v,w) -> (exprToString v) ^ ("*" ^ (exprToString w))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))
  | Thresh (v,w,x,y) ->
      (exprToString v) ^
        ("<" ^
           ((exprToString w) ^
              ("?" ^ ((exprToString x) ^ (":" ^ (exprToString y))))));;

[(28,2)-(39,69),(28,2)-(39,69),(31,14)-(31,17),(31,14)-(31,42),(36,6)-(39,69),(36,23)-(36,24)]

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  let pi = 3.142 in
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine v -> sin (pi *. (eval (v, x, y)))
  | Cosine v -> cos (pi *. (eval (v, x, y)))
  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0
  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;

NO OVERLAP CORE/DIFF

let getHead h = match h with | [] -> [] | h::t -> h;;

let getTail t = match t with | [] -> [] | h::t -> t;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec matchHeads x =
  match x with
  | [] -> true
  | h::t ->
      if (getHead x) = (getHead (listReverse x))
      then matchHeads (getTail (listReverse t))
      else false;;

let palindrome w =
  match explode w with | [] -> true | h::t -> matchHeads explode w;;

[(18,6)-(20,16),(18,6)-(20,16),(19,11)-(19,21),(19,11)-(19,47),(20,11)-(20,16),(23,46)-(23,56),(23,46)-(23,66)]

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec matchHeads x = match x with | [] -> true | h::t -> false;;

let palindrome w =
  match explode w with | [] -> true | h::t -> matchHeads (explode w);;

