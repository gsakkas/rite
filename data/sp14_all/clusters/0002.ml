TupleG [ListG [],ListG []]
(0 , [0 ; 0 ; 0 ; 0])
(l1 , [0 ; 0 ; 0 ; 0])
(t1 , (((h1 + x) + rh) mod 10) :: rt)
(t1 , [(h1 + x) mod 10])
(List.append zeroes l1 , l2)
(0 , [])
(fst x + snd x , [(fst x + snd x) / 10 ; (fst x + snd x) mod 10])
(if addit >= 10
 then 1
 else 0 , num @ [addit mod 10])
(List.append (clone 0
                    (List.length l2 - List.length l1))
             l1 , l2)
(0 , 4)
(0 , 1)
(let d =
   fun x ->
     (let xx = f b in
      (xx , xx = b)) in
 d , b)
(f , value)
(0 , acc)
(buildAverage (build (rand , depth - 1) , build (rand , depth - 1)) , build (rand , depth - 1))
(buildAverage (build (rand , depth - 1) , build (rand , depth - 1)) , buildSine (build (rand , depth - 1)))
(f , b')
([] , [])
(l1 @ clone 0 (x2 - x1) , l2)
(l1 , l2 @ clone 0 (x1 - x2))
(build (rand , depth - 1) , build (rand , depth - 1) , build (rand , depth - 1))
(if f b = b
 then (fun b'' ->
         (f b , false))
 else (fun b'' ->
         (f b , true)) , b)
(((c + x') + x'') / 10 , (((c + x') + x'') mod 10) :: s)
(c , s)
(c , c :: s)
(l1 , [])
(h , b)
(x * x , x < 100)
(next , next)
(fun xx ->
   (xx , f xx = xx) , b)
(clone 0
       (len2 - len1) @ l1 , l2)
(clone 0
       (len1 - len2) @ l2 , l1)
(cout , List.append [r] [])
(d , k , t)
(fun x ->
   (f x , not (f x = x)) , b)
(f x , not (f x = x))
(0 , 0)
(List.append (clone 0
                    (abs diff)) l1 , l2)
(l1 , List.append (clone 0
                         diff) l2)
(l1 , l2)
(e' , x , y)
(fun x ->
   (let b = f x in
    (b , b <> x)) , b)
(h1 + 1 , (mul / 10) :: ((mul mod 10) :: t2))
(((add1 + add2) + carry) / 10 , (((add1 + add2) + carry) mod 10) :: rest)
(0 , carry :: rest)
(l1 , clone 0
            (List.length l1 - List.length l2) @ l2)
(clone 0
       (List.length l2 - List.length l1) @ l1 , l2)
(f , x)
(s , x , y)
(t , x , y)
(u , x , y)
(v , x , y)
(fun b -> (f b , f b = b) , b)
(e1 , x , y)
(build (rand , depth) , build (rand , depth))
(build (rand , depth) , build (rand , depth) , build (rand , depth) , build (rand , depth))
(a , x , y)
(b , x , y)
(c , x , y)
(((i + j) + s) / 10 , (((i + j) + s) mod 10) :: t)
(List.append (clone 0
                    (sec - first)) l1 , l2)
(l1 , List.append (clone 0
                         (first - sec)) l2)
(first_forced , build (rand , depth - 1) , build (rand , depth - 1) , build (rand , depth - 1))
(e2 , x , y)
(e3 , x , y)
(List.append (clone 0
                    (lenl1 - lenl2))
             l1 , List.append (clone 0
                                     (lenl1 - lenl2)) l2)
(e , x , y)
(b , f b)
(m , x , y)
(if depth = 0
 then buildX ()
 else build (rand , depth - 1) , if depth = 0
                                 then buildY ()
                                 else build (rand , depth - 1))
(let f =
   fun x ->
     (let xx = (x * x) * x in
      (xx , xx < 100)) in
 f , b)
(p1 , [res / 10 ; res mod 10])
(p1 , (re / 10) :: ((re mod 10) :: b))
(x1 , x , y)
(x2 , x , y)
(t , (x + h) :: b)
(mulByDigit x q , [])
(List.append (clone 0 (b - a))
             l1 , l2)
(l1 , List.append (clone 0
                         (a - b)) l2)
(l1 , List.append (clone 0
                         l1G) l2)
(List.append (clone 0 l2G)
             l1 , l2)
(let g =
   fun x ->
     (let xx = f x in
      (xx , xx <> b)) in
 g , b)
(let helper =
   fun x -> (f x , f x = f b) in
 helper , b)
([x + 1] , [x + 1])
([x + 1] , [x + 2])
(l1 , to_append @ l2)
(a_less , x , y)
(b_less , x , y)
(d , k , l)
(l1 , clone 0 a)
(List.append (clone 0 (0 - a))
             l1 , l2)
(fun b ->
   (f b , b <> f b) , b)
(build (rand , depth - 1) , buildCosine (build (rand , depth - 1)) , build (rand , depth - 1) , build (rand , depth - 1))
(buildCosine (buildSine (build (rand , depth - 1))) , buildSine (build (rand , depth - 1)))
(e , 0.0 , 0.0)
(fun a ->
   (f a , f a <> a) , b)
([0] , [0])
(0 :: (List.rev l1) , 0)
(List.append (clone 0
                    (- diff)) l1 , l2)
(List.append (clone 0 diff)
             l2 , l1)
(c , d)
(c , d :: t)
(build (rand , depth - 1) , build (rand , depth - 1))
(ex , x , y)
(list1 , list2)
([(h1 + h2) / 10] , [(h1 + h2) mod 10])
(len , (-1) :: (((sum mod 10) + 1) :: xs'))
(build (rand , depth - 1) , build (rand , depth - 1) , build (rand , depth - 1) , build (rand , depth - 1))
(func b , b)
(f x , f x = x)
