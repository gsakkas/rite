LamG (IteG EmptyG EmptyG EmptyG)
fun numZeros ->
  if numZeros <= 0
  then []
  else 0 :: (generatePadding (numZeros - 1))
fun n ->
  if x <= 0
  then []
  else cloneHelper x (n - 1)
fun n ->
  if x <= 0
  then []
  else cloneHelper x (n - 1)
fun n ->
  if x <= 0
  then []
  else cloneHelper x (n - 1)
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun n ->
  if n < 1
  then []
  else cloneHelper x n []
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun l ->
  if i > 0
  then bigAdd l
              (mulByDigit (i - 1) l)
  else []
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun x ->
  if f x = b
  then (b , true)
  else (f x , false)
fun n ->
  if n < 10 then n else helper n
fun seen ->
  if List.mem h r
  then seen
  else h :: seen
fun seen ->
  if List.mem h r
  then seen
  else h :: seen
fun l ->
  if x > 0
  then l @ []
  else appZero (x - 1) l
fun b ->
  if f b = b
  then (b , false)
  else (f b , true)
fun b' ->
  if f b' = b'
  then (f b' , false)
  else (f b' , true)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
