{"hw": "hw3", "index": 0, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (valueToAddToArray @ currentSum)) in\n    let base = (0, []) in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      if x = []\n      then (0, (carry :: currentSum))\n      else\n        (let (toSum1,toSum2) = x in\n         let intermediateValue = (toSum1 + toSum2) + carry in\n         let valueToAddToArray = intermediateValue mod 10 in\n         let carry = intermediateValue / 10 in\n         (carry, (valueToAddToArray :: currentSum))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 4, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentSum) = a in\n      if x = ()\n      then (0, (carry :: currentSum))\n      else\n        (let (toSum1,toSum2) = x in\n         let intermediateValue = (toSum1 + toSum2) + carry in\n         let valueToAddToArray = intermediateValue mod 10 in\n         let carry = intermediateValue / 10 in\n         (carry, (valueToAddToArray :: currentSum))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + carry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 5, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (_,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + currentCarry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padCount,currList) = a in\n    let intermediateSum = mulByDigit x l2 in\n    let toSum = intermediateSum * (10 ** padCount) in\n    ((padCount - 1), (bigAdd currList toSum)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (_,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + currentCarry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padCount,currList) = a in\n    let intermediateSum = mulByDigit x l2 in\n    let rec generatePadding numZeros =\n      if numZeros <= 0 then [] else 0 :: (generatePadding (numZeros - 1)) in\n    let toSum = intermediateSum @ (generatePadding padCount) in\n    ((padCount + 1), (bigAdd currList toSum)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 6, "problem": "clone", "bad": "\nlet rec clone x n = if x <= 0 then [] else x @ (clone x (n - 1));;\n", "fix": "\nlet rec clone x n = if x <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 7, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (_,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + currentCarry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [] else bigAdd l mulByDigit (i - 1) l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (_,currentCarry::currentSum) = a in\n      let (toSum1,toSum2) = x in\n      let intermediateValue = (toSum1 + toSum2) + currentCarry in\n      let valueToAddToArray = intermediateValue mod 10 in\n      let carry = intermediateValue / 10 in\n      (carry, (carry :: valueToAddToArray :: currentSum)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 8, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let listZeros = clone 0 abs numZeros in\n  if numZeros > 0 then [(l1, (listZeros @ l2))] else [((listZeros @ l1), l2)];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 9, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let listZeros = clone (0, (abs numZeros)) in\n  if numZeros > 0 then [(l1, (listZeros @ l2))] else [((listZeros @ l1), l2)];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 10, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let listZeros = clone (0, (abs numZeros)) in\n  if numZeros > 0 then [(l1, l2)] else [((listZeros @ l1), l2)];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 11, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then [(l1, l2)]\n  else\n    (let listZeros = clone (0, (abs numZeros)) in\n     if numZeros > 0\n     then let list1 = l1 in let list2 = listZeros @ l2 in [(list1, list2)]\n     else (let list1 = listZeros @ l1 in let list2 = l2 in [(list1, list2)]));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 12, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then [(l1, l2)]\n  else\n    (let numZeros = (List.length l1) - (List.length l2) in\n     if numZeros = 0\n     then [(l1, l2)]\n     else\n       (let listZeros = clone (0, (abs numZeros)) in\n        if numZeros > 0\n        then let list1 = l1 in let list2 = listZeros @ l2 in [(list1, list2)]\n        else\n          (let list1 = listZeros @ l1 in let list2 = l2 in [(list1, list2)])));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 13, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then [(l1, l2)]\n  else\n    (let numZeros = (List.length l1) - (List.length l2) in\n     if numZeros = 0 then [(l1, l2)]);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 14, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then [(l1, l2)];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 15, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then [(l1, l2)]\n  else\n    (let listZeros = clone (0, (abs numZeros)) in\n     if numZeros > 0\n     then [(l1, (listZeros @ l2))]\n     else [((listZeros @ l1), l2)]);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 16, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone (0, (abs numZeros)) in\n     if numZeros > 0 then (l1, (listZeros @ l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 17, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0 then (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 18, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone (0, (abs numZeros)) in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 19, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    if numZeros > 0\n    then (l1, ((clone (0, (abs numZeros))) @ l2))\n    else (((clone (0, (abs numZeros))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 20, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    if numZeros > 0\n    then (l1, ((clone (0, numZeros)) @ l2))\n    else (((clone (0, (abs numZeros))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 21, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    if numZeros > 0\n    then (l1, ((clone 0 numZeros) @ l2))\n    else (((clone (0, (abs numZeros))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 22, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 abs numZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let numZeros = (List.length l1) - (List.length l2) in\n  let absNumZeros = abs numZeros in\n  if numZeros = 0\n  then (l1, l2)\n  else\n    (let listZeros = clone 0 absNumZeros in\n     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;\n"}
{"hw": "hw3", "index": 23, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 24, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2.) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 25, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \", (List.map (f, l)))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let newList = List.map f l in \"[\" ^ ((sepConcat \"; \" newList) ^ \"]\");;\n"}
{"hw": "hw3", "index": 26, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map (f, l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let newList = List.map f l in \"[\" ^ ((sepConcat \"; \" newList) ^ \"]\");;\n"}
{"hw": "hw3", "index": 27, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = ((sepConcat \"; \"), (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let newList = List.map f l in \"[\" ^ ((sepConcat \"; \" newList) ^ \"]\");;\n"}
{"hw": "hw3", "index": 28, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 29, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let quotient = n / 10 in\n      if quotient = 0 then n mod 10 else quotient :: (digitsOfInt quotient);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let quotient = n / 10 in\n      if quotient = 0 then [n mod 10] else quotient :: (digitsOfInt quotient);;\n"}
{"hw": "hw1", "index": 30, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with | true  -> [] | false  -> [[(digitsOfInt n) / 10]];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 31, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with | true  -> [] | false  -> [[digitsOfInt (n / 10)]];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 32, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 33, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else [digitsOfInt (n / 10)] :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 34, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 35, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0 then [n mod 10] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      if (n / 10) = 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 36, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let remainder = n mod 10 in\n      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let remainder = n mod 10 in\n      if n = 0 then [remainder] else (digitsOfInt (n / 10)) @ [remainder];;\n"}
{"hw": "hw1", "index": 37, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let q = n / 10 in\n      let r = n mod 10 in if q = 0 then r else (digitsOfInt q) @ [r];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n < 0 with\n  | true  -> []\n  | false  ->\n      let q = n / 10 in\n      let r = n mod 10 in if q = 0 then [r] else (digitsOfInt q) @ [r];;\n"}
{"hw": "hw1", "index": 38, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw3", "index": 39, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = \"\" in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,res) = a\n      and (d1,d2) = x in\n      ((((cin + d1) + d2) mod 10), (((cin + d1) + d2) :: res)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 40, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,res) = a\n      and (d1,d2) = x in\n      ((((cin + d1) + d2) mod 10), (((cin + d1) + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,res) = a\n      and (d1,d2) = x in\n      ((((cin + d1) + d2) mod 10), (((cin + d1) + d2) :: res)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 41, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc cin l' =\n    match l' with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) t in\n  removeZero (helper [] 0 l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x l1 in\n  let base = [] in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc cin l' =\n    match l' with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) t in\n  removeZero (helper [] 0 l);;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 42, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc cin l' =\n    match l' with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) t in\n  removeZero (helper [] 0 l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x l1 in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let rec helper acc cin l' =\n    match l' with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) t in\n  removeZero (helper [] 0 l);;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 43, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone (n - 1));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 44, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone (x, (n - 1)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 45, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 46, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec helper acc n' =\n    if n <= 0 then [] else helper ((x :: acc), (n' - 1)) in\n  helper [x] (n - 1);;\n", "fix": "\nlet rec clone x n =\n  let rec helper acc n' = if n <= 0 then [] else helper (x :: acc) (n' - 1) in\n  helper [x] (n - 1);;\n"}
{"hw": "hw3", "index": 47, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec helper acc n' = if n <= 0 then [] else (helper x) :: (acc (n' - 1)) in\n  helper [x] (n - 1);;\n", "fix": "\nlet rec clone x n =\n  let rec helper acc n' = if n <= 0 then [] else helper (x :: acc) (n' - 1) in\n  helper [x] (n - 1);;\n"}
{"hw": "hw3", "index": 48, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let (cin,res) = mulByDigit i t in\n      let sum = (i * h) + cin in ((sum / 10), ((sum mod 10) :: res));;\n", "fix": "\nlet rec mulByDigit i l =\n  let rec helper acc cin =\n    match l with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) in\n  helper [] 0;;\n"}
{"hw": "hw3", "index": 49, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let (cout,res) =\n    match l with\n    | [] -> (0, [])\n    | h::t ->\n        let (cin,acc) = mulByDigit i t in\n        let sum = (i * h) + cin in ((sum / 10), ((sum mod 10) :: acc)) in\n  if cout > 0 then cout :: res else res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let rec helper acc cin =\n    match l with\n    | [] -> cin :: acc\n    | h::t ->\n        let sum = (i * h) + cin in helper ((sum mod 10) :: acc) (sum / 10) in\n  helper [] 0;;\n"}
{"hw": "hw3", "index": 50, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone (0, (ll1 - ll2))) @ l2))\n  else (((clone (0, (ll2 - ll1))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 51, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, (((clone 0 ll1) - ll2) @ l2))\n  else (((clone ((0 ll2) - ll1)) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 52, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone (0 (ll2 - ll1))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1\n  and ll2 = List.length l2 in\n  if ll1 > ll2\n  then (l1, ((clone 0 (ll1 - ll2)) @ l2))\n  else (((clone 0 (ll2 - ll1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 53, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 54, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base b x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 55, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 56, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x r a x = a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 57, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 58, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a x = a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 59, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f' x a = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f' a x = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 60, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f' a x = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f' a x = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 61, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 62, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a \"to be implemented\" in\n  let base = 0 \"to be implemented\" in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 63, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 64, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 65, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 66, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 67, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = () in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw2", "index": 68, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 69, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> (\"sin(pi*\" + (exprToString e')) + \")\"\n  | Cosine e' -> (\"cos(pi*\" + (exprToString e')) + \")\"\n  | Average (e1,e2) ->\n      (((\"((\" + (exprToString e1)) + \"+\") + (exprToString e2)) + \")/2)\"\n  | Times (e1,e2) -> ((exprToString e1) + \"*\") + (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (((((((\"(\" + (exprToString e1)) + \"<\") + (exprToString e2)) + \"?\") +\n           (exprToString e3))\n          + \":\")\n         + (exprToString e4))\n        + \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 70, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) + \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 71, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos (pi *. (eval e))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 72, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 73, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) / 2) * (eval (e2, x, y))) / 3) *\n         (eval (e3, x, y)))\n        / 4\n  | Creative e1 -> (-1) * (eval e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) /. 2.0) *. (eval (e2, x, y))) /. 3.0) *.\n         (eval (e3, x, y)))\n        /. 4.0\n  | Creative e1 -> (-1.0) *. (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 74, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) /. 2) *. (eval (e2, x, y))) /. 3) *.\n         (eval (e3, x, y)))\n        /. 4\n  | Creative e1 -> (-1) *. (eval e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) /. 2.0) *. (eval (e2, x, y))) /. 3.0) *.\n         (eval (e3, x, y)))\n        /. 4.0\n  | Creative e1 -> (-1.0) *. (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 75, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) /. 2.0) *. (eval (e2, x, y))) /. 3.0) *.\n         (eval (e3, x, y)))\n        /. 4.0\n  | Creative e1 -> (-1.0) *. (eval e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Uncreative (e1,e2,e3) ->\n      (((((eval (e1, x, y)) /. 2.0) *. (eval (e2, x, y))) /. 3.0) *.\n         (eval (e3, x, y)))\n        /. 4.0\n  | Creative e1 -> (-1.0) *. (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 76, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> (\"sine(\" + (eval e)) + \")\"\n  | Cosine e -> (\"cos(\" + (eval e)) + \")\"\n  | Average (e1,e2) -> (((\"(\" eval e1) + \"+\") + (eval e2)) + \")/2\"\n  | Times (e1,e2) -> ((eval e1) + \"*\") + (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (((((((\"(\" + (eval e1)) + \"<\") + (eval e2)) + \"?\") + (eval e3)) + \":\")\n         + (eval e4))\n        + \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sine(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 77, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Uncreative (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/2*\" ^ ((exprToString e2 \"/3*\") ^ (exprToString e3 \"/4)\"))))\n  | Creative e1 -> \"(-1*\" ^ ((exprToString e1) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Uncreative (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/2*\" ^\n              ((exprToString e2) ^ (\"/3*\" ^ ((exprToString e3) ^ \"/4)\")))))\n  | Creative e1 -> \"(-1*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 78, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Uncreative (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/2*\" ^ ((exprToString e2) ^ (\"/3*\" ^ (exprToString e3 \"/4)\")))))\n  | Creative e1 -> \"(-1*\" ^ ((exprToString e1) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Uncreative of expr* expr* expr\n  | Creative of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Uncreative (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/2*\" ^\n              ((exprToString e2) ^ (\"/3*\" ^ ((exprToString e3) ^ \"/4)\")))))\n  | Creative e1 -> \"(-1*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 79, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in\n  if result = b\n  then b\n  else\n    (wwhile (f, b)) *\n      ((let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n        fixpoint (g, 0)));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let foo b =\n    let result = f b in\n    if result = b then (result, false) else (result, true) in\n  wwhile (foo, b);;\n"}
{"hw": "hw2", "index": 80, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in if result = b then b else wwhile (f, b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let foo b =\n    let result = f b in\n    if result = b then (result, false) else (result, true) in\n  wwhile (foo, b);;\n"}
{"hw": "hw2", "index": 81, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let result = f b in if result = b then b else wwhile (f, result);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let foo b =\n    let result = f b in\n    if result = b then (result, false) else (result, true) in\n  wwhile (foo, b);;\n"}
{"hw": "hw2", "index": 82, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let foo f b =\n    let result = f b in\n    if result = b then (result, false) else (result, true) in\n  wwhile (foo, b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let foo b =\n    let result = f b in\n    if result = b then (result, false) else (result, true) in\n  wwhile (foo, b);;\n"}
{"hw": "hw2", "index": 83, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 84, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in b';;\n"}
{"hw": "hw2", "index": 85, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f b') else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in b';;\n"}
{"hw": "hw2", "index": 86, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw1", "index": 87, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let return = [n mod 10] in\n  if (n / 10) <> 0\n  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)\n  else return;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let i = 0 in\n  fun helper  ->\n    fun n  ->\n      (let d = digitsOfInt n in\n       let s = sumList d in\n       if (n / 10) <> 0\n       then (print_int n; print_endline \" \"; incr i; helper s)\n       else d) i;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [n mod 10] in\n  if (n / 10) <> 0\n  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)\n  else return;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if ((sumList (digits n)) / 10) <> 0\n  then (additivePersistence (sumList (digits n))) + 1\n  else 1;;\n"}
{"hw": "hw1", "index": 88, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let return = [n mod 10] in\n  if (n / 10) <> 0\n  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)\n  else return;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if ((sumList (digits n)) / 10) <> 0\n  then (additivePersistence (sumList digits n)) + 1\n  else 1;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [n mod 10] in\n  if (n / 10) <> 0\n  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)\n  else return;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if ((sumList (digits n)) / 10) <> 0\n  then (additivePersistence (sumList (digits n))) + 1\n  else 1;;\n"}
{"hw": "hw1", "index": 89, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then [] else returnList @ ((n mod 10) digitsOfInt (n /. 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  let returnList = [] in if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 90, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then [] else returnList @ (1 digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 91, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then [] else returnList @ ([1] digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 92, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then returnList else returnList @ (1 digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 93, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then returnList else returnList @ (\"1\" digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 94, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then returnList else returnList @ ([\"1\"] digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 95, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in\n  if n < 0 then returnList else returnList :: (1 digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 96, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let returnList = [] in if n < 0 then returnList else returnList :: 1;;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 97, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = [];;\n"}
{"hw": "hw1", "index": 98, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [1];;\n"}
{"hw": "hw1", "index": 99, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else return :: 1;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else 1 :: return;;\n"}
{"hw": "hw1", "index": 100, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n < 0 then return else (n mod 10) :: ((return digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else digitsOfInt 1;;\n"}
{"hw": "hw1", "index": 101, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n < 0 then return else (n mod 10) :: ((return digitsOfInt n) /. 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else digitsOfInt 1;;\n"}
{"hw": "hw1", "index": 102, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else digitsOfInt - 1;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else digitsOfInt 1;;\n"}
{"hw": "hw1", "index": 103, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n < 0 then return else (digitsOfInt (-1) (n mod 10)) :: return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n < 0 then return else (n mod 10) :: return;;\n"}
{"hw": "hw1", "index": 104, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then return else (n mod 10) :: return; (n /. 10) :: return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then return else (n mod 10) :: return; (n / 10) :: return;;\n"}
{"hw": "hw1", "index": 105, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n == 0 then return else (n mod 10) :: return; (digitsOfInt 0) :: return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n == 0 then return else (n mod 10) :: return; (digitsOfInt 0) @ return;;\n"}
{"hw": "hw1", "index": 106, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then [return] else (n mod 10) :: return; (digitsOfInt 0) @ return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then return else (n mod 10) :: return; (digitsOfInt 0) @ return;;\n"}
{"hw": "hw1", "index": 107, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then [] :: return else (n mod 10) :: return;\n  (digitsOfInt 0) @ return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <= 0 then return else (n mod 10) :: return; (digitsOfInt 0) @ return;;\n"}
{"hw": "hw1", "index": 108, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in if n = 0 then return else print_int n; digitsOfInt 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n = 0 then return else digitsOfInt 0;;\n"}
{"hw": "hw1", "index": 109, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in if n != 0 then (n mod 10) digitsOfInt 0 else return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n <> 0 then (n mod 10) :: return else return;;\n"}
{"hw": "hw1", "index": 110, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in if n <> 0 then (n mod 10) digitsOfInt 0 else return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n <> 0 then (n mod 10) :: return else return;;\n"}
{"hw": "hw1", "index": 111, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <> 0 then (n mod 10) :: (return digitsOfInt 0) else return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in if n <> 0 then (n mod 10) :: return else return;;\n"}
{"hw": "hw1", "index": 112, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <> 0\n  then ((n mod 10) :: return; (digitsOfInt 0) :: return)\n  else return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <> 0 then ((n mod 10) :: return; (digitsOfInt 0) @ return) else return;;\n"}
{"hw": "hw1", "index": 113, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <> 0\n  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return; print_int n)\n  else return;;\n", "fix": "\nlet rec digitsOfInt n =\n  let return = [] in\n  if n <> 0\n  then ((n mod 10) :: return; print_int n; (digitsOfInt (n / 10)) @ return)\n  else return;;\n"}
{"hw": "hw1", "index": 114, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> t :: (listReverse h);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 115, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t :: (listReverse [h]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 116, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> [h] | h::t -> h :: (listReverse [t]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 117, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> [h] | h::t -> t @ (listReverse [h]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 118, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> [h] | h::t -> t @ (listReverse h);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 119, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> h @ (listReverse [t]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 120, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h -> h | h::t -> h @ (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 121, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> h @ (listReverse [t]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 122, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> [h] @ (listReverse [t]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 123, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> h @ (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t @ (listReverse [h]);;\n"}
{"hw": "hw1", "index": 124, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t -> t | h::t -> t :: (listReverse [h]);;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h];;\n"}
{"hw": "hw1", "index": 125, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 126, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw2", "index": 127, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> false;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 128, "problem": "eval", "bad": "\nlet rec eval (e,x,y) = sin 45;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 129, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 130, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 131, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 132, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 133, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 134, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 135, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 136, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 137, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (exprToString eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 138, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 139, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 140, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 141, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 142, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 143, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 144, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Smallest of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Neg e1 -> e1 *. (-1.0)\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Smallest of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Neg e1 -> (eval (e1, x, y)) *. (-1.0)\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 145, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Smallest of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Neg e1 -> (eval (e1, x, y)) *. (-1)\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Smallest of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Neg e1 -> (eval (e1, x, y)) *. (-1.0)\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 146, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e = [Sine (pi * e)];;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 147, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = [Thresh (e < (e ?e) : e)];;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 148, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> 0\n  | VarY  -> 1\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 149, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> 0\n  | VarY  -> 1\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) < (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 150, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) + (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 151, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) + (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> ((exprToString e1) ^ (\"+\" ^ (exprToString e2))) ^ \"/2\"\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 152, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> sin (pi * (exprToString e1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 153, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> sin (pi *. (exprToString e1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 154, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Neg e1 -> \"(\" ^ (e1 ^ \" * -1)\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Neg of expr\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Neg e1 -> \"(\" ^ ((exprToString e1) ^ \" * -1)\")\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 155, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile (((f b), ((not f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 156, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile (((f b), (not ((f b) = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 157, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, false) else (b, true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 158, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((b, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 159, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 160, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile (((f b), true), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 161, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((x, ((f x) = x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (y,true ) -> wwhile (f, y);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, ((f x) = x))), b);;\n"}
{"hw": "hw2", "index": 162, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h t) then true else false in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 163, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then true else false in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 164, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n =\n  if n > 0 then (n mod 10) + ((additivePersistence n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 165, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 166, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 10 then 1 + additivePersistence else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 0;;\n"}
{"hw": "hw1", "index": 167, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = [digitsOfInt n; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 168, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 169, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n mod 10)] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n mod 100; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 170, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n mod 10); n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n mod 100; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 171, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 172, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n"}
{"hw": "hw1", "index": 173, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n"}
{"hw": "hw1", "index": 174, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> 2 + 2;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n"}
{"hw": "hw1", "index": 175, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n"}
{"hw": "hw1", "index": 176, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList xs);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n"}
{"hw": "hw1", "index": 177, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec helper n l = if n = 0 then l else helper (n / 10) ((n mod 10) :: l) in\n  match n with | 0 -> [0] | _ -> helper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  if (List.length (digits n)) = 1\n  then List.hd (digits n)\n  else additivePersistence (digits n);;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper n l = if n = 0 then l else helper (n / 10) ((n mod 10) :: l) in\n  match n with | 0 -> [0] | _ -> helper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  if (List.length (digits n)) = 1\n  then List.hd (digits n)\n  else additivePersistence (n / 10);;\n"}
{"hw": "hw1", "index": 178, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n mod 10)) @ [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n mod 10)) @ [] else [];;\n"}
{"hw": "hw1", "index": 179, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n mod 10)) @ [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n mod 10)) @ [] else [];;\n"}
{"hw": "hw1", "index": 180, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n / 10)) @ [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt (n / 10)) @ [] else [];;\n"}
{"hw": "hw2", "index": 181, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  let h::t = l in\n  if h = []\n  then d\n  else (let (x,y) = h in if x = k then y else assoc (d, k, t));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  if l = []\n  then d\n  else\n    (let h::t = l in\n     if t = []\n     then d\n     else (let (x,y) = h in if x = k then y else assoc (d, k, t)));;\n"}
{"hw": "hw2", "index": 182, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile (let g b = ((f b), (if (f b) = b then false else true)) in (g, b));;\n"}
{"hw": "hw2", "index": 183, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then (b, false) else (((f b), true), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile (let g b = ((f b), (if (f b) = b then false else true)) in (g, b));;\n"}
{"hw": "hw2", "index": 184, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, false) else ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile (let g b = ((f b), (if (f b) = b then false else true)) in (g, b));;\n"}
{"hw": "hw2", "index": 185, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 186, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with | (k,_) -> k | h::t -> assoc (d, k, t) | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n"}
{"hw": "hw2", "index": 187, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with | (k,_) -> d | h::t -> assoc (d, k, t) | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n"}
{"hw": "hw2", "index": 188, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (str,num)::t -> if str = k then num else assoc (d, k, t)\n  | [] -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n"}
{"hw": "hw2", "index": 189, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n"}
{"hw": "hw2", "index": 190, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (ki,vi::t) -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::t -> if k = ki then vi else assoc (d, k, t)\n  | [] -> d;;\n"}
{"hw": "hw2", "index": 191, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = ((rand 1), 6) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | _ ->\n      let r = rand (1, 6) in\n      (match r with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 192, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match (e, x, y) with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> buildSine (eval e1)\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 193, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match (e, x, y) with | VarX  -> x | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 194, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> buildSine (eval e1)\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 195, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval e1))\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 196, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 197, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1 x y))\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 198, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> buildCosine (eval e1)\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 199, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 200, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 201, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> buildTimes ((eval e1), (eval e2))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 202, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 203, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 204, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1 / (sin (pi *. (eval (e1, x, y))))) *\n         (cos (pi *. (eval (e1, x, y)))))\n        * (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1 / (sin (pi *. (eval (e1, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1.0 /. (sin (pi *. (eval (e1, x, y))))) *.\n         (cos (pi *. (eval (e1, x, y)))))\n        *. (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1.0 /. (sin (pi *. (eval (e1, x, y))));;\n"}
{"hw": "hw2", "index": 205, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1 /. (sin (pi *. (eval (e1, x, y))))) *.\n         (cos (pi *. (eval (e1, x, y)))))\n        *. (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1 /. (sin (pi *. (eval (e1, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1.0 /. (sin (pi *. (eval (e1, x, y))))) *.\n         (cos (pi *. (eval (e1, x, y)))))\n        *. (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1.0 /. (sin (pi *. (eval (e1, x, y))));;\n"}
{"hw": "hw2", "index": 206, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1.0 /. (sin (pi *. (eval (e1, x, y))))) *.\n         (cos (pi *. (eval (e1, x, y)))))\n        *. (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1 /. (sin (pi *. (eval (e1, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewOp1 (e1,e2,e3) ->\n      ((1.0 /. (sin (pi *. (eval (e1, x, y))))) *.\n         (cos (pi *. (eval (e1, x, y)))))\n        *. (sin (pi *. (eval (e1, x, y))))\n  | NewOp2 e1 -> 1.0 /. (sin (pi *. (eval (e1, x, y))));;\n"}
{"hw": "hw2", "index": 207, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin pi*\" ^ (exprToString e1)\n  | Cosine e1 -> \"cos pi*\" ^ (exprToString e1)\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ (exprToString e2 \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin pi*\" ^ (exprToString e1)\n  | Cosine e1 -> \"cos pi*\" ^ (exprToString e1)\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 208, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewOp1 (e1,e2,e3) ->\n      (\"(\" \"1/sin(pi*\") ^\n        ((exprToString e1) ^\n           (\")\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e1) ^\n                    (\")\" ^ (\"sin(pi*\" ^ ((exprToString e1) ^ (\")\" ^ \")\"))))))))\n  | NewOp2 e1 -> \"1/sin(pi*\" ^ ((exprToString e1) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewOp1 of expr* expr* expr\n  | NewOp2 of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewOp1 (e1,e2,e3) ->\n      \"(\" ^\n        (\"1/sin(pi*\" ^\n           ((exprToString e1) ^\n              (\")\" ^\n                 (\"cos(pi*\" ^\n                    ((exprToString e1) ^\n                       (\")\" ^ (\"sin(pi*\" ^ ((exprToString e1) ^ (\")\" ^ \")\")))))))))\n  | NewOp2 e1 -> \"1/sin(pi*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 209, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 210, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((f, (b = (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 211, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let g = f b in ((f, g), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 212, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let g = f b in ((f, (g < b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 213, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n b = (f, (b = (f b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 214, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n z = (z, (b = (z b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 215, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n z = (f, (b = (f b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 216, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((let n z = (f, (b = (f b))) in n), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 217, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile ((let n z = let xx = f in (xx, (b = (f b))) in n), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 218, "problem": "fixpoint", "bad": "\nlet fu x b = (x, (b < (x b)));;\n\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((fu f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 219, "problem": "fixpoint", "bad": "\nlet fu x b = (x, (b < (x b)));;\n\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((fu f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 220, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((f, (b < (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 221, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let g = (f, (b = (f b))) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 222, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f, (b = (f b))) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 223, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let x = f in (x, (b = (f b))) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 224, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f in (xx, (b = (f b))) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 225, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f, (x = (f x))) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 226, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f, (b = (f b))) in g), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 227, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let xx = f in (f, (b < (f b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 228, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = (f, (b < (f b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 229, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = (f, (b = (f b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 230, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f in (ff, (b = (ff b))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = ff)) in (n, b));;\n"}
{"hw": "hw2", "index": 231, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (f, (b = ff)) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f b in (ff, (b = (f b))) in (n, b));;\n"}
{"hw": "hw2", "index": 232, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f in (ff, (x = (f x))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 233, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f in (ff, (x = (ff x))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 234, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) =\n  wwhile (let n x = let ff = f in (f, (x = (f x))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 235, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = (f, (x = (f x))) in (n, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 236, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = (f, (x = (f x))) in (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 237, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (((f x), (x = (f x))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;\n\nlet fixpoint (f,b) = wwhile (let n x = ((f x), (x = (f x))) in (n, b));;\n"}
{"hw": "hw2", "index": 238, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = List.mem h t in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 239, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h else h :: t in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 240, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h else h @ t in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 241, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h else t in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 242, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h else [t] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 243, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 244, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = padZero l1 l2 in\n    let base = List.combine l1 l2 in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in (((addition (m, n)) / 10), [(addition (m, n)) mod 10]) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 245, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.combine padZero l1 l2 in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in (((addition (m, n)) / 10), [(addition (m, n)) mod 10]) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 246, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), (((addition (m, n)) mod 10) @ res)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), ([(addition (m, n)) mod 10] @ z)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 247, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), (((addition (m, n)) mod 10) @ [res])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), ([(addition (m, n)) mod 10] @ z)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 248, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), ([(addition (m, n)) mod 10] @ [z])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((addition (m, n)) / 10), ([(addition (m, n)) mod 10] @ z)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 249, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((((addition (m, n)) + y) / 10) @ z),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 250, "problem": "bigAdd", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      (((((addition (m, n)) + y) / 10) :: z),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 251, "problem": "bigMul", "bad": "\nlet mult (x,y) = x * y;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = x in\n    let (y,z) = a in\n    ((((mult (m, n)) + y) / 10), [((mult (m, n)) + y) mod 10]) @ z in\n  let base = (0, []) in\n  let args = List.rev (List.combine l1 l2) in\n  let (cin,res) = List.fold_left f base args in [cin] @ res;;\n", "fix": "\nlet mult (x,y) = x * y;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = x in\n    let (y,z) = a in\n    ((((mult (m, n)) + y) / 10), ([((mult (m, n)) + y) mod 10] @ z)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l1 l2) in\n  let (cin,res) = List.fold_left f base args in [cin] @ res;;\n"}
{"hw": "hw3", "index": 252, "problem": "bigMul", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (cin,res) = List.fold_left f base args in [cin] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 = mulByDigit (bigAdd l1 l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (cin,res) = List.fold_left f base args in [cin] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 = mulByDigit 9 (bigAdd l1 l2);;\n"}
{"hw": "hw3", "index": 253, "problem": "bigMul", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (cin,res) = List.fold_left f base args in [cin] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  mulByDigit (((List.length l1) + (List.length l2)) (bigAdd l1 l2));;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet addition (x,y) = x + y;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (((clone 0 ((-1) * diff)) @ l1), l2)\n  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = x in\n      let (y,z) = a in\n      ((((addition (m, n)) + y) / 10),\n        ([((addition (m, n)) + y) mod 10] @ z)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (cin,res) = List.fold_left f base args in [cin] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  mulByDigit ((List.length l1) + (List.length l2)) (bigAdd l1 l2);;\n"}
{"hw": "hw3", "index": 254, "problem": "clone", "bad": "\nlet rec clone x n = List.split x n;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 255, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec clone x n = \"[\" ^ ((sepConcat \"; \") ^ ((List.append x n) ^ \"]\"));;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 256, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec clone x n = \"[\" ^ ((sepConcat \"; \") ^ ((List.combine x n) ^ \"]\"));;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 257, "problem": "clone", "bad": "\nlet rec clone x n = \"[\" ^ ((fun a  -> b) ^ ((List.combine x n) ^ \"]\"));;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 258, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet pipe fs =\n  let f a x n = x (a n) in let base n = n in List.fold_left f base fs;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet rec clone x n = pipe stringOfList x n;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 259, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n\nlet rec clone x n = stringOfList x n List.map x n;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 260, "problem": "clone", "bad": "\nlet rec clone x n = x List.map x n;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 261, "problem": "clone", "bad": "\nlet rec clone x n = if x <= 0 then [] else List.fold_left n;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 262, "problem": "clone", "bad": "\nlet rec clone x n = if x <= 0 then [] else List.fold_left x;;\n", "fix": "\nlet rec cloneHelper x n = if x <= 0 then [] else cloneHelper x (n - 1);;\n\nlet rec clone x n = cloneHelper x n;;\n"}
{"hw": "hw3", "index": 263, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | 0 -> [] | hd::tl -> (mulByDigit i tl) @ (hd * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (mulByDigit i tl) @ [hd * i];;\n"}
{"hw": "hw3", "index": 264, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (mulByDigit i tl) @ (hd * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (mulByDigit i tl) @ [hd * i];;\n"}
{"hw": "hw3", "index": 265, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (mulByDigit i tl) @ ([hd] * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (mulByDigit i tl) @ [hd * i];;\n"}
{"hw": "hw3", "index": 266, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> (hd * i) @ [mulByDigit i tl];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> [hd * i] @ (mulByDigit i tl);;\n"}
{"hw": "hw3", "index": 267, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> [hd * i] @ [mulByDigit i tl];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> [hd * i] @ (mulByDigit i tl);;\n"}
{"hw": "hw3", "index": 268, "problem": "mulByDigit", "bad": "\nlet retHead l = match l with | [] -> [] | h::t -> h;;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | hd::tl ->\n      [((hd * i) mod 10) + (((retHead tl) * i) / 10)] @ (mulByDigit i tl);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> [(hd * i) mod 10] @ (mulByDigit i tl);;\n"}
{"hw": "hw3", "index": 269, "problem": "mulByDigit", "bad": "\nlet rec retHead l = match l with | [] -> [] | h::t -> h;;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | hd::tl ->\n      [((hd * i) mod 10) + (((retHead tl) * i) / 10)] @ (mulByDigit i tl);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | hd::tl -> [(hd * i) mod 10] @ (mulByDigit i tl);;\n"}
{"hw": "hw3", "index": 270, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a x = match x with | [] -> [] | h::t -> (i * h) / 10 in\n  let base = i * h in\n  let args = List.rev l in let res = List.fold_left base args in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let c = i * x in match a with | [] -> [] | h::t -> ((h * i) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 271, "problem": "mulByDigit", "bad": "\nlet cin (x,y) = (x * y) / 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match x with | [] -> [] | h::t -> (cin (h, i)) @ (mulByDigit i t) in\n  let base = i * h in\n  let args = List.rev l in let res = List.fold_left base args in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let c = i * x in match a with | [] -> [] | h::t -> ((h * i) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 272, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a x =\n    let c = i * x in match a with | [] -> [] | h::t -> (h * i) mod 10 in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let c = i * x in match a with | [] -> [] | h::t -> ((h * i) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 273, "problem": "mulByDigit", "bad": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | _ -> c | h::t -> (((h * i) + c) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n", "fix": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | _ -> [c] | h::t -> (((h * i) + c) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 274, "problem": "mulByDigit", "bad": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match x with | [] -> [] | h::t -> (((h * i) + c) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n", "fix": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | [] -> [] | h::t -> (((h * i) + c) mod 10) :: t in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 275, "problem": "mulByDigit", "bad": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | hd::tl -> [cout (hd, i)] + (mulByDigit i tl) in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n", "fix": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | hd::tl -> [cout (hd, i)] @ (mulByDigit i tl) in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 276, "problem": "mulByDigit", "bad": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | hd::tl -> (cout (hd, i)) @ (mulByDigit i tl) in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n", "fix": "\nlet cout (x,y) = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = cout (i, x) in\n    match a with | hd::tl -> [cout (hd, i)] @ (mulByDigit i tl) in\n  let base = [] in\n  let args = List.rev l in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 277, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (clone 0 abs diff) @ l1\n  else if diff > 0 then (clone 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 278, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (cloneHelper 0 abs diff) @ l1\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 279, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (cloneHelper 0 ((-1) * diff)) @ l1\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 280, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((cloneHelper 0) - (1 * diff)) @ l1\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 281, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (cloneHelper 0 l1) - (1 * diff)\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 282, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then (cloneHelper 0) - (1 * diff)\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 283, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) (0 @ l1)\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 284, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) (l1 @ 0)\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 285, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) l1\n  else if diff > 0 then (cloneHelper 0 diff) @ l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 286, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) l1\n  else if diff > 0 then cloneHelper 0 diff l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 287, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) l1\n  else if diff > 0 then cloneHelper 0 diff l2 else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 288, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then cloneHelper 0 (((-1) * diff) - 1) l1\n  else if diff > 0 then cloneHelper 0 diff l2 else l1 l2;;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 289, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then clone 0 (((-1) * diff) - 1)\n  else if diff > 0 then clone 0 diff else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 290, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then l2 @ (clone 0 (((-1) * diff) - 1))\n  else if diff > 0 then clone 0 diff else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 291, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then l1 @ (clone 0 (((-1) * diff) - 1) (l1, l2))\n  else if diff > 0 then l2 @ (clone 0 diff (l1, l2)) else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 292, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then l1 @ (clone 0 (((-1) * diff) - 1))\n  else if diff > 0 then l2 @ ((clone 0 diff) - 1) else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 293, "problem": "padZero", "bad": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then l1 @ (clone 0 (((-1) * diff) - 1))\n  else if diff > 0 then l2 @ (clone 0 (diff - 1)) else (l1, l2);;\n", "fix": "\nlet rec cloneHelper x n l =\n  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;\n\nlet rec clone x n = if n < 1 then [] else cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((l1 @ (clone 0 diff)), l2)\n  else if diff > 0 then (l1, (l2 @ (clone 0 diff))) else (l1, l2);;\n"}
{"hw": "hw3", "index": 294, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 295, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 296, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a fs in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 297, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (x + x) + a in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 298, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 299, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 300, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + fs in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 301, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a + (fs a) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 302, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = a + x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 303, "problem": "pipe", "bad": "\nlet pipe fs = let f a x n = a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 304, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 305, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (fun n  -> n) in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> n) x in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 306, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n fs = a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 307, "problem": "pipe", "bad": "\nlet pipe fs = let f a x n = a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun n  -> a) x in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 308, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n x = a n in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 309, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sl in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 310, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ sl) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 311, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sl ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 312, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet stringOfList f l = \"[\" ^ (\"List.map f l\" ^ \"]\");;\n"}
{"hw": "hw3", "index": 313, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 314, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 315, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 316, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      if ((x1 + x2) + carry) > 9\n      then (1, ((((x1 + x2) + carry) - 9) :: accList))\n      else (0, ((x1 + x2) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      if ((x1 + x2) + carry) > 9\n      then (1, ((((x1 + x2) + carry) - 9) :: accList))\n      else (0, ((x1 + x2) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 317, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      if ((x1 + x2) + carry) / 10\n      then (1, ((((x1 + x2) + carry) mod 10) :: accList))\n      else (0, ((x1 + x2) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 318, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = l @ 0 in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let args = List.map (mulByDigit l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 319, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = List.append l 0 in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let args = List.map (mulByDigit l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 320, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = List.append l [0] in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let args = List.map (mulByDigit l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 321, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = List.append l [0] in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let f' a x = List.append a (mulByDigit x l1) in\n  let base' = [] in\n  let args = List.fold_left f' base' l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 322, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = List.append l [0] in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let f' aa xx = List.append aa (mulByDigit xx l1) in\n  let base' = [] in\n  let args = List.fold_left f' base' l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 323, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bit,l) = a in\n    let movedList = List.append l [0] in ((bit + 1), (bigAdd movedList x)) in\n  let base = (0, []) in\n  let f' aa xx = List.append aa (mulByDigit xx l1) in\n  let base' = [[]] in\n  let args = List.fold_left f' base' l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accList) = a in\n      let (x1,x2) = x in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: accList)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in\n    if carry = 1 then 1 :: res else res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,accList) = a in\n    (((carry + (x * i)) / 10), (((carry + (x * i)) mod 10) :: accList)) in\n  let base = (0, []) in\n  let newlist = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base newlist in removeZero res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (ll,accumulate) = a in\n    let multed = mulByDigit x l1 in\n    let accumulate = List.append accumulate [0] in\n    (l1, (bigAdd accumulate multed)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 324, "problem": "clone", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 325, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (clone 0 n) @ l2 else ((clone 0) - n) @ l1;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 326, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (clone 0 n) @ l2 else ((clone 0) - (1 * n)) @ l1;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n > 0 then (l1, ((clone 0 n) @ l2)) else (((clone 0 (0 - n)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 327, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p_pre = x (a p_pre) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 328, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval e)\n  | Cosine e -> cos (eval e)\n  | Average (e1,e2) -> ((eval e1) + (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) * (eval e2)\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval e1) < (eval e2) then eval e1less else eval e2less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n"}
{"hw": "hw2", "index": 329, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval e))\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e1,e2) -> ((eval e1) + (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) * (eval e2)\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval e1) < (eval e2) then eval e1less else eval e2less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n"}
{"hw": "hw2", "index": 330, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n"}
{"hw": "hw2", "index": 331, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n"}
{"hw": "hw2", "index": 332, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e1less,e2less) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1less, x, y)\n      else eval (e2less, x, y);;\n"}
{"hw": "hw2", "index": 333, "problem": "fixpoint", "bad": "\nlet fixpointHelper f =\n  match f with | (num,expr) -> if expr then (num, true) else (num, false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f), b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 334, "problem": "fixpoint", "bad": "\nlet fixpointHelper (f,b) = if (f b) = b then (b, true) else (b, false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper (f, b)), b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 335, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((let b = f b in (bb, (bb = f))), b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 336, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((let b = f b in (bb, (bb = (f b)))), b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 337, "problem": "fixpoint", "bad": "\nlet fixpointHelper f b =\n  let c = f b in if c = b then (c, true) else (c, false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 338, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile (0, b);;\n", "fix": "\nlet fixpointHelper f b b = ((f b), (if (f b) = b then true else false));;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) = wwhile ((fixpointHelper f b), b);;\n"}
{"hw": "hw2", "index": 339, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with | [] -> seen | h::t -> if !(List.mem h t) then h :: rest in\n  let seen' = t in\n  let rest' = rest helper (seen', rest') in List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h t then helper (seen, t) else helper ((h :: seen), t) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 340, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = if f then f (f, b) else b;;\n", "fix": "\nlet rec wwhile (f,b) = b;;\n"}
{"hw": "hw3", "index": 341, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 padLength) :: l1\n  else (clone 0 padlength) l2;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 (padLength l1 l2)) l1), l2)\n  else (l1, (List.append (clone 0 (padLength l1 l2)) l2));;\n"}
{"hw": "hw3", "index": 342, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 (padLength l1 l2)) :: l1\n  else (clone 0 (padLength l1 l2)) l2;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 (padLength l1 l2)) l1), l2)\n  else (l1, (List.append (clone 0 (padLength l1 l2)) l2));;\n"}
{"hw": "hw3", "index": 343, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 (padLength l1 l2)) * l1\n  else (clone 0 (padLength l1 l2)) * l2;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 (padLength l1 l2)) l1), l2)\n  else (l1, (List.append (clone 0 (padLength l1 l2)) l2));;\n"}
{"hw": "hw3", "index": 344, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 (padLength l1 l2)) l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, (List.append (clone 0 (padLength l1 l2)) l2))\n    else l1 l2;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padLength l1 l2 = abs ((List.length l1) - (List.length l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 (padLength l1 l2)) l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, (List.append (clone 0 (padLength l1 l2)) l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 345, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs b = let f a x = x a in let base = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 346, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x n = x n in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 347, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x h) :: a in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 348, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sl ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw2", "index": 349, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | (x,y)::t when x = k -> y | h::t -> assoc d k | _ -> (-1);;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 350, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | (x,y)::t when x = k -> y | h::t -> assoc d k t | _ -> (-1);;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 351, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (x,y)::t when x = k -> y\n  | (x,y)::t -> assoc d k t\n  | _ -> (-1);;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 352, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | (x,y)::t when x = k -> y | h::t -> assoc d k t | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 353, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc d k t | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 354, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) = match l with | h::t -> assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 355, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand 0.4 in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (d - 1)))\n      else buildCosine (build (rand, (d - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 356, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand 0.4 in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine build (rand, (d - 1))\n      else buildCosine build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 357, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand 0.4 in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine build (r, (d - 1))\n      else buildCosine build (r, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 358, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand 0.4 in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (d - 1)))\n      else buildCosine build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 359, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand 0.4 in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine build (rand, (d - 1))\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 360, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0. depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d -> if r = 0 then build (rand, (d - 1)) else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 361, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine build (rand, (d - 1))\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 362, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildCosine build (rand, (d - 1))\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 363, "problem": "build", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y);;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then eval ((buildCosine build (rand, (d - 1))), 1, 2)\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 364, "problem": "build", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y);;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then eval ((build (rand, (d - 1))), 1, 2)\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 365, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d -> if r = 0 then buildSine else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 366, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine build (rand, (depth - 1))\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 367, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX else buildY\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, depth) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else build (rand, (d - 1));;\n"}
{"hw": "hw2", "index": 368, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build (rand, (d - 1))\n       | 1 -> buildSine build (rand, (d - 1))\n       | 2 -> buildCosine build (rand, (d - 1))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, d1)), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build (rand, (d - 1))\n       | 1 -> buildSine (build (rand, (d - 1)))\n       | 2 -> buildCosine (build (rand, (d - 1)))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, (d - 1))), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n"}
{"hw": "hw2", "index": 369, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build ((rand ()), (d - 1))\n       | 1 -> buildSine build (rand, (d - 1))\n       | 2 -> buildCosine build (rand, (d - 1))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, d1)), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build (rand, (d - 1))\n       | 1 -> buildSine (build (rand, (d - 1)))\n       | 2 -> buildCosine (build (rand, (d - 1)))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, (d - 1))), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n"}
{"hw": "hw2", "index": 370, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build (rand, (d - 1))\n       | 1 -> buildSine (build (rand, (d - 1)))\n       | 2 -> buildCosine build (rand, (d - 1))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, d1)), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 7) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      (match r with\n       | 0 -> build (rand, (d - 1))\n       | 1 -> buildSine (build (rand, (d - 1)))\n       | 2 -> buildCosine (build (rand, (d - 1)))\n       | 3 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 4 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n       | 5 ->\n           buildThresh\n             ((build (rand, (d - 1))), (build (rand, (d - 1))),\n               (build (rand, (d - 1))), (build (rand, (d - 1))))\n       | _ -> build (rand, (d - 1)));;\n"}
{"hw": "hw2", "index": 371, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 11) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r <= 2\n      then buildSine (build (rand, (d - 1)))\n      else\n        if r <= 9\n        then\n          (match r with\n           | 3 ->\n               buildAverage\n                 ((build (rand, (d - 1))), (build (rand, (d - 1))))\n           | 4 ->\n               buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n           | 5 ->\n               buildThresh\n                 ((build (rand, (d - 1))), (build (rand, (d - 1))),\n                   (build (rand, (d - 1))), (build (rand, (d - 1))))\n           | 6 -> 0.\n           | 7 -> 0.)\n        else buildCosine (build (rand, (d - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 11) in\n  match depth with\n  | 0 -> if (r mod 2) = 0 then buildX () else buildY ()\n  | d ->\n      if r <= 2\n      then buildSine (build (rand, (d - 1)))\n      else\n        if r <= 9\n        then\n          (match r with\n           | 3 ->\n               buildAverage\n                 ((build (rand, (d - 1))), (build (rand, (d - 1))))\n           | 4 ->\n               buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n           | 5 ->\n               buildThresh\n                 ((build (rand, (d - 1))), (build (rand, (d - 1))),\n                   (build (rand, (d - 1))), (build (rand, (d - 1)))))\n        else buildCosine (build (rand, (d - 1)));;\n"}
{"hw": "hw2", "index": 372, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = (buildX 2 let_) = (eval (VarX, 3, 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 373, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = (buildX () let_) = (eval (VarX, 3, 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 374, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = buildTimes buildX buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 375, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) = buildTimes x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 376, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) = buildTimes (buildX, buildY);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 377, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. t)\n  | Cosine t -> cos (pi *. t)\n  | Average (t,s) -> (t +. s) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 378, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. (eval t x y))\n  | Cosine t -> cos (pi *. (eval t x y))\n  | Average (t,s) -> ((eval t x y) +. (eval s x y)) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 379, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | varX -> x\n  | varY -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 380, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) mod 30.0) +. ((eval (r, x, y)) mod (eval (s, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) /. 30.0) +. ((eval (r, x, y)) /. (eval (s, x, y)));;\n"}
{"hw": "hw2", "index": 381, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) mod 30) +. ((eval (r, x, y)) mod (eval (s, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) /. 30.0) +. ((eval (r, x, y)) /. (eval (s, x, y)));;\n"}
{"hw": "hw2", "index": 382, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) / 30) +. ((eval (r, x, y)) / (eval (s, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) /. 30.0) +. ((eval (r, x, y)) /. (eval (s, x, y)));;\n"}
{"hw": "hw2", "index": 383, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) /. 30) +. ((eval (r, x, y)) /. (eval (s, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((eval (t, x, y)) /. 30.0) +. ((eval (r, x, y)) /. (eval (s, x, y)));;\n"}
{"hw": "hw2", "index": 384, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((sin (pi * (eval (r, x, y)))) + (tan (pi * (eval (s, x, y))))) *\n        (sin (pi * (eval (t, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((sin (pi *. (eval (r, x, y)))) +. (tan (pi *. (eval (s, x, y))))) *.\n        (sin (pi *. (eval (t, x, y))));;\n"}
{"hw": "hw2", "index": 385, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((sin (pi *. (eval (r, x, y)))) * (tan (pi *. (eval (s, x, y))))) *.\n        (sin (pi *. (eval (t, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Average (t,s) -> ((eval (t, x, y)) +. (eval (s, x, y))) /. 2.0\n  | Times (t,s) -> (eval (t, x, y)) *. (eval (s, x, y))\n  | Thresh (t,r,s,q) ->\n      if (eval (t, x, y)) < (eval (r, x, y))\n      then eval (s, x, y)\n      else eval (q, x, y)\n  | Trip (t,r,s) ->\n      ((sin (pi *. (eval (r, x, y)))) *. (tan (pi *. (eval (s, x, y))))) *.\n        (sin (pi *. (eval (t, x, y))));;\n"}
{"hw": "hw2", "index": 386, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(\" @ ((exprToString x) @ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(\" ^ ((exprToString x) ^ \")\");;\n"}
{"hw": "hw2", "index": 387, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"%30.0)\" ^ (exprToString ^ (\"%\" ^ ((exprToString z) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"%30.0)\" ^ ((exprToString y) ^ (\"%\" ^ ((exprToString z) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 388, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"%30.0)\" ^ (exprToString ^ (\"%\" ^ ((exprToString z) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"%30.0)\" ^ ((exprToString y) ^ (\"%\" ^ ((exprToString z) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 389, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"/30.0)+\" ^ ((exprToString y) ^ (\"/\" ^ ((exprToString z) ^ \")\")))))\n  | Greater (x,y) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\">\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Trip of expr* expr* expr\n  | Greater of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,s) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString s) ^ \")\")))))))\n  | Trip (x,y,z) ->\n      \"((\" ^\n        ((exprToString x) ^\n           (\"/30.0)+\" ^ ((exprToString y) ^ (\"/\" ^ ((exprToString z) ^ \")\")))))\n  | Greater (x,y) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\">\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 390, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 391, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 392, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fx x = if x = 0 then 0 else if x > 1 then x - 1 else x + 1 in\n  wwhile ((fx b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 393, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fx x = if x = 0 then 0 else if x > 1 then x - 1 else x + 1 in\n  wwhile ((fx b), f);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 394, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fx b = if b = 0 then 0 else if b > 1 then b - 1 else b + 1 in\n  wwhile (fx, f);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 395, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let res = f b in\n  if b = 0 then 0 else if b > 1 then b - 1 else b + (1 wwhile (f, res));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 396, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  if b = 0 then 0 else if b > 1 then b - 1 else b + (1 wwhile (f, res));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 397, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt = let res = f b in match b with | res -> b in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 398, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt = let res = f b in match b with | res -> b in wwhile (funt, f);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 399, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx a = true in wwhile (fx, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 400, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx = 2 in wwhile (fx, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 401, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx x = x in wwhile (fx, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 402, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx x = x in wwhile ((fx b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 403, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx x = x in wwhile (2, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 404, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fx x = x in wwhile (b, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 405, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fs bs = if bs = 0 then 0 else if bs > 1 then bs - 1 else bs + 1 in\n  wwhile (fs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 406, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fs bs = if bs = 0 then 0 else if bs > 1 then bs - 1 else bs + 1 in\n  wwhile ((fs true), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 407, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fs bs = if bs = 0 then 0 else if bs > 1 then bs - 1 else bs + 1 in\n  wwhile ((fs b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 408, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fs bs = if bs = 0 then 0 else if bs > 1 then bs - 1 else bs + 1 in\n  wwhile ((fs b true), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 409, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let fs bs = if bs = 0 then 0 else if bs > 1 then bs - 1 else bs + 1 in\n  wwhile ((fs b), true, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 410, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt = (f, ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 411, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt = ((f b), ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 412, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt = (f, ((f b) = b)) in wwhile (b, funt);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 413, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt b = (f, ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 414, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 415, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 416, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt b = if f b then 0 else 1 in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 417, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt b = if f b then b else b in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 418, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then b else b in wwhile ((funt b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, true) else (b, false) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 419, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, 1) else (b, 2) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, b) else (b, b) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 420, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (1, 1) else (1, 1) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, b) else (b, b) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 421, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (true, 1) else (true, 1) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, b) else (b, b) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 422, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (1, 1) else (true, 1) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, b) else (b, b) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 423, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (1, b) else (1, b) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if f b then (b, b) else (b, b) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 424, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b = if (f b) = b then (b, b) else (b, b) in wwhile ((funt b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt x = (2, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 425, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b1 = if (f b1) = b then (1, b) else (1, b) in wwhile ((funt b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt x = (2, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 426, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let funt b1 = if (f b1) = b then (b1, b) else (b1, b) in\n  wwhile ((funt b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let funt x = (2, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 427, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let funt x = let xx = f f (f (f b)) in (xx, ((f b) = b)) in\n  wwhile (funt, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let rec funt x = ((f b), ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 428, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let rec funt x = ((funt b), ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let rec funt x = ((f b), ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 429, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let rec funt x = ((funt f b), ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let rec funt x = ((f b), ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 430, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let rec funt x = ((funt (f b)), ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let rec funt x = ((f b), ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 431, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec funt x = (funt, ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec funt x = (b, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 432, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let rec funt x = ((funt b), ((f b) = b)) in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec funt x = (b, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 433, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec funt x = (f b) = b in wwhile (funt, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec funt x = (b, ((f b) = b)) in wwhile (funt, b);;\n"}
{"hw": "hw2", "index": 434, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((b, ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (b, ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 435, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec fs x = ((fs x), ((f b) = b)) in wwhile (fs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fs x = ((f b), ((f b) = b)) in wwhile (fs, b);;\n"}
{"hw": "hw2", "index": 436, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let rec fs x = ((fs b), ((f b) = b)) in wwhile (fs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) = let fs x = ((f b), ((f b) = b)) in wwhile (fs, b);;\n"}
{"hw": "hw2", "index": 437, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let gs x =\n    let xx = f x in match xx with | xx when (xx - x) > 0 -> (x, b) | _ -> f x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 438, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let isFPoint = ((f b) - b) < 0 in\n  let rec test x = if isFPoint x then (x, true) else ((test x), false) in\n  wwhile (isFPoint, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 439, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let isFPoint x = ((f x) - x) < 0 in\n  let rec test x = if isFPoint x then (x, true) else ((test x), false) in\n  wwhile (isFPoint, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 440, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let isFPoint x = ((f x) - x) < 0 in\n  let rec test x = if isFPoint x then (x, true) else ((test (f x)), false) in\n  wwhile (isFPoint, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 441, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let isFPoint x = ((f x) - x) < 0 in\n  let rec test x = if isFPoint x then (x, true) else ((test (f b)), false) in\n  wwhile (isFPoint, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 442, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let isFPoint x = ((f x) - x) < 0 in\n  let rec test x = if isFPoint x then (x, true) else test ((f x), false) in\n  wwhile (isFPoint, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 443, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint x = ((f x) - x) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in go x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 444, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint x = ((f x) - x) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in\n    (x, (isFPoint x)) in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 445, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in go x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 446, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in go (go x) in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 447, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in (go x) w in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 448, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in go x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 449, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r = if isFPoint r then r else go (iterate (x, r)) in x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 450, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x =\n    let isFPoint s = ((f s) - s) < 0 in\n    let iterate (t,y) = t y in\n    let rec go r =\n      if isFPoint r then (r, true) else go ((iterate (x, r)), false) in\n    go x in\n  wwhile (gs, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 451, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let isFPoint s = ((f s) - s) < 0 in\n  let iterate (t,y) = t y in\n  let rec go r = if isFPoint r then r else go (iterate (f, r)) in\n  wwhile (go, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 452, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let isFPoint s = ((f s) - s) < 0 in\n  let iterate (t,y) = t y in\n  let rec go r = if isFPoint r then r else go (iterate (f, r)) in\n  wwhile (go, (isFPoint b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 453, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let isFPoint s = ((f s) - s) < 0 in\n  let iterate (t,y) = t y in\n  let rec go r = if isFPoint r then r else go (iterate (f, r)) in\n  wwhile ((go, (isFPoint b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 454, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let isFPoint s = ((f s) - s) < 0 in\n  let iterate (t,y) = t y in\n  let rec go r = if isFPoint r then r else go (iterate (f, r)) in\n  wwhile ((go, true), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n\nlet fixpoint (f,b) =\n  let gs x = let isFPoint s = ((f s) - s) < 0 in ((f x), (isFPoint x)) in\n  wwhile (gs, b);;\n"}
{"hw": "hw2", "index": 455, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.rev h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 456, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile ((f b), x) | (x,y) -> x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n"}
{"hw": "hw2", "index": 457, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x y = (f, b) in if b = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n"}
{"hw": "hw2", "index": 458, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = match f with | (a,b)|_ -> (a, b) in\n  if y = true then wwhile (f, y) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let res = f b in\n  match res with | (x,y) when y = true -> wwhile (f, x) | (x,y) -> x;;\n"}
{"hw": "hw1", "index": 459, "problem": "additivePersistence", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n = if (n / 10) <= 0 then 0 else digits n;;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0 then 0 else sumList (digits n);;\n"}
{"hw": "hw1", "index": 460, "problem": "additivePersistence", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (n / 10) <= 0 then 0 else sumList digits n;;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0 then 0 else sumList (digits n);;\n"}
{"hw": "hw1", "index": 461, "problem": "additivePersistence", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (n / 10) <= 0 then 0 else digits sumList n;;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0 then 0 else sumList (digits n);;\n"}
{"hw": "hw1", "index": 462, "problem": "additivePersistence", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0 then 0 else digits (sumList n);;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0 then 0 else sumList (digits n);;\n"}
{"hw": "hw1", "index": 463, "problem": "digitsOfInt", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n div 10 in digitsOfInt n2 append [n2]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in digitsOfInt n2);;\n"}
{"hw": "hw1", "index": 464, "problem": "digitsOfInt", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in digitsOfInt n2 append [n2]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in digitsOfInt n2);;\n"}
{"hw": "hw1", "index": 465, "problem": "digitsOfInt", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in (digitsOfInt n2) append [n2]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in digitsOfInt n2);;\n"}
{"hw": "hw1", "index": 466, "problem": "digitsOfInt", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in append digitsOfInt n2 n2);;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in append (digitsOfInt n2) [n2]);;\n"}
{"hw": "hw1", "index": 467, "problem": "digitsOfInt", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in append digitsOfInt n2 [n2]);;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n2 = n / 10 in append (digitsOfInt n2) [n2]);;\n"}
{"hw": "hw1", "index": 468, "problem": "palindrome", "bad": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet palindrome w =\n  let l = explode w in\n  let lr = listReverse l in if l :: lr then true else false;;\n", "fix": "\nlet rec append xs ys = match xs with | [] -> ys | h::t -> h :: (append t ys);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet palindrome w =\n  let l = explode w in\n  let lr = listReverse l in if l = lr then true else false;;\n"}
{"hw": "hw3", "index": 469, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (x1 + x2) :: a in\n    let base = ([], []) in\n    let args = List.combine (padZero l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 470, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (x1 + x2) :: a in\n    let base = ([], []) in\n    let args =\n      let padZeroLists = padZero l1 l2 in fst padZeroLists snd padZeroLists in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 471, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (x1 + x2) :: a in\n    let base = ([], []) in\n    let args = List.combine padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 472, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (x1 + x2) :: a in\n    let base = ([], []) in\n    let args = List.combine padZero (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 473, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (x1 + x2) :: a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 474, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (((x1 + x2) / 10), ((x1 + x2) mod 10)) in\n    let base = ([], []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l1' l2' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 475, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), (sum :: (((x1 + x2) + carry) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 476, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), (sum @ (((x1 + x2) + carry) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,sum) = a in\n      (((x1 + x2) / 10), ((((x1 + x2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 477, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1',l2') =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,acc) = a in\n      let sum = (x1 + x2) + carry in ((sum / 10), (acc :: (sum mod 10))) in\n    let base = (0, []) in\n    let args = let (l1',l2') = padZero l1 l2 in List.combine l2' l1' in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 478, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), (sum mod 10)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 479, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), (acc @ (sum mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 480, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 481, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), (acc @ [sum mod 10])) in\n    let base = (0, []) in\n    let args = [(0, 0)] :: (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), (acc @ [sum mod 10])) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 482, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sum = (x1 + x2) + carry in ((sum / 10), ((sum mod 10) :: acc)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 483, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,acc) = a in\n    let res = (x * i) + carry in ((res / 10), ((res mod 10) :: acc)) in\n  let base = (0, []) in let args = List.rev in List.fold_left f base args;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let (carry,acc) = a in\n    let res = (x * i) + carry in ((res / 10), ((res mod 10) :: acc)) in\n  let base = (0, []) in\n  let args = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 484, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 485, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (fun result  -> fun x  -> a + x) 0 in\n  let base = 1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 486, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result x = a x in let base = 1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 487, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result = a x in let base = 1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 488, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result = a x in let base = f 1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 489, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 490, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result = a x in let base = f 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 491, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result n = x (a n) in let base = f 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 492, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x result n = x (a n) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 493, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = n (a x) in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 494, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = n (a x) in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 495, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = n (a x) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 496, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = n a (a x) in let base f = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 497, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x n = n a (a x) in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x n = x (a n) in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 498, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_right f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 499, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_right f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 500, "problem": "sqsum", "bad": "\nlet sqsum xs = List.fold_right (fun x  -> fun n  -> n * n) 0;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw2", "index": 501, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> (-1) | h::l' -> let (x,y) = h in Printf.printf (x, h);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | h::l' -> let (x,y) = h in (match x with | k -> y | _ -> assoc (d, k, l'));;\n"}
{"hw": "hw2", "index": 502, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> (-1) | h::l' -> let (x,y) = h in Printf.sprintf h;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | h::l' -> let (x,y) = h in (match x with | k -> y | _ -> assoc (d, k, l'));;\n"}
{"hw": "hw2", "index": 503, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> (-1) | h::l' -> let (x,y) = h in print_int h;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | h::l' -> let (x,y) = h in (match x with | k -> y | _ -> assoc (d, k, l'));;\n"}
{"hw": "hw2", "index": 504, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> (-1) | h::l' -> let (x,y) = h in print_int y;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | h::l' -> let (x,y) = h in (match x with | k -> y | _ -> assoc (d, k, l'));;\n"}
{"hw": "hw2", "index": 505, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi * (eval (b, x, y)))\n  | Cosine b -> cos (pi * (eval (b, x, y)))\n  | Average (a,b) -> (eval (a, x, y)) + ((eval (b, x, y)) / 2)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.0)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | _ -> 0.0;;\n"}
{"hw": "hw2", "index": 506, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | _ -> 0.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.0)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | _ -> 0.0;;\n"}
{"hw": "hw2", "index": 507, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Logx of expr\n  | TripMult of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Logx a -> log (eval a)\n  | TripMult (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | _ -> 0.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TripMult of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | TripMult (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | _ -> 0.0;;\n"}
{"hw": "hw2", "index": 508, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Logx of expr\n  | TripMult of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Logx a -> log 0\n  | TripMult (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | _ -> 0.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TripMult of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine b -> sin (pi *. (eval (b, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | TripMult (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | _ -> 0.0;;\n"}
{"hw": "hw2", "index": 509, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2))\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString c) ^ (\":\" ^ ((exprToString d) :: \")\")))))))\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2))\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 510, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expn of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Eval (a,b) -> \"(\" ^ ((exprToString a) ^ (\"^\" ^ ((exprToString b) ^ \")\")))\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expn of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Expn (a,b) -> \"(\" ^ ((exprToString a) ^ (\"^\" ^ ((exprToString b) ^ \")\")))\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 511, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expn of expr* expr\n  | TripMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Expn b -> \"(0.5^\" ^ ((exprToString b) ^ \")\")\n  | TripMult (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"*\" ^ ((exprToString c) ^ \")\")))))\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expn of expr\n  | TripMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine b -> \"sin(pi*\" ^ ((exprToString b) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Expn b -> \"(0.5^\" ^ ((exprToString b) ^ \")\")\n  | TripMult (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"*\" ^ ((exprToString c) ^ \")\")))))\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 512, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | true  -> wwhile (f, b') | false  -> b';;\n\nlet fixpoint (f,b) = wwhile ((let func (x,y) = (f x) = y in func), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | true  -> wwhile (f, b') | false  -> b';;\n\nlet fixpoint (f,b) = wwhile ((fun b'  -> let x = f b' in (x, (b' != x))), b);;\n"}
{"hw": "hw2", "index": 513, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem (h, seen) with\n          | true  -> seen @ [h]\n          | false  -> seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen @ [h] | false  -> seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 514, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = b in match c' with | true  -> wwhile (f, b') | false  -> b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | true  -> wwhile (f, b') | false  -> b';;\n"}
{"hw": "hw3", "index": 515, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l = rmzhelp l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 516, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 517, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = x in\n      match a with\n      | (n,listSum) ->\n          (match listSum with\n           | [] ->\n               if ((n + a) + b) < 10\n               then (0, [n; (n + a) + b])\n               else ((n + 1), [n + 1; ((n + a) + b) mod 10])\n           | h::t ->\n               if ((n + a) + b) < 10\n               then (0, ([0; (a + b) + h] @ t))\n               else\n                 [((n + 1), (((h + i) + j) / 10));\n                 (((h + a) + b) mod 10)\n                 ::\n                 t]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 518, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (c,d) = x in\n      match a with\n      | (n,listSum) ->\n          (match listSum with\n           | [] ->\n               if ((n + c) + d) < 10\n               then (0, [n; (n + c) + d])\n               else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n           | h::t ->\n               if ((n + c) + d) < 10\n               then (0, ([0; (c + d) + h] @ t))\n               else\n                 [((n + 1), (((h + c) + d) / 10));\n                 (((h + c) + d) mod 10)\n                 ::\n                 t]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 519, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (c,d) = x in\n      match a with\n      | (n,listSum) ->\n          (match listSum with\n           | [] ->\n               if ((n + c) + d) < 10\n               then (0, [n; (n + c) + d])\n               else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n           | h::t ->\n               if ((n + c) + d) < 10\n               then (0, ([0; (c + d) + h] @ t))\n               else\n                 ((n + 1), [((h + c) + d) / 10; (((h + c) + d) mod 10) :: t])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 520, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (c,d) = x in\n      match a with\n      | (n,listSum) ->\n          (match listSum with\n           | [] ->\n               if ((n + c) + d) < 10\n               then (0, [n; (n + c) + d])\n               else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n           | h::t ->\n               if ((n + c) + d) < 10\n               then (0, ([0; (c + d) + h] @ t))\n               else\n                 ((n + 1), ((((h + c) + d) / 10) :: (((h + c) + d) mod 10) ::\n                   t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 521, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (c,d) = x in\n      match a with\n      | (n,listSum) ->\n          (match listSum with\n           | [] ->\n               if ((n + c) + d) < 10\n               then (0, [n; (n + c) + d])\n               else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n           | h::t ->\n               if ((n + c) + d) < 10\n               then (0, ([0; (c + d) + h] @ t))\n               else\n                 ((n + 1), ((((h + c) + d) / 10) ::\n                   ([((h + c) + d) mod 10] @ t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 522, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, [n; (n + c) + d])\n                    else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0; (c + d) + h] @ t))\n                    else\n                      ((n + 1), ((((h + c) + d) / 10) ::\n                        (((h + c) + d) mod 10) :: t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 523, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, [n; (n + c) + d])\n                    else ((n + 1), [n + 1; ((n + c) + d) mod 10])\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0; (c + d) + h] @ t))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 524, "problem": "bigAdd", "bad": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec rmzhelp l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet rec foldr f b x n = if n > 0 then f x (foldr f b x (n - 1)) else b;;\n\nlet rec clone x n = foldr (fun y  -> fun m  -> y :: m) [] x n;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs' -> if x = 0 then rmzhelp xs' else x :: xs';;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (c,d) ->\n          (match a with\n           | (n,listSum) ->\n               (match listSum with\n                | [] ->\n                    if ((n + c) + d) < 10\n                    then (0, ([n] @ [(n + c) + d]))\n                    else ((n + 1), ([n + 1] @ [((n + c) + d) mod 10]))\n                | h::t ->\n                    if ((n + c) + d) < 10\n                    then (0, ([0] @ ([(c + d) + h] @ t)))\n                    else\n                      ((n + 1),\n                        ([((h + c) + d) / 10] @ ([((h + c) + d) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 525, "problem": "pipe", "bad": "\nlet pipe fs n = let f a x = a n in let base = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 526, "problem": "pipe", "bad": "\nlet pipe fs n =\n  let f a x = a + (n x) in let base = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 527, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 528, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | [] -> x | h::fs' -> h x in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 529, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | [] -> x | h::fs' -> h x in\n  let base = function | [] -> fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 530, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base fs = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 531, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a fs in let base fs = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 532, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a + (x fs) in let base fs = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 533, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x = x a in let base fs = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a = x a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 534, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x = x a in let base fs = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 535, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a = x a in let base a = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a = x a in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 536, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\" l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 537, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map ((sepConcat \";\" l) l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 538, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map (f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 539, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw2", "index": 540, "problem": "build", "bad": "\nlet rec build (rand,depth) = rand + build;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = if 1 > 0 then VarY else VarY;;\n"}
{"hw": "hw2", "index": 541, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin x;;\n"}
{"hw": "hw2", "index": 542, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin x;;\n"}
{"hw": "hw2", "index": 543, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1 x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin x;;\n"}
{"hw": "hw2", "index": 544, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin x;;\n"}
{"hw": "hw2", "index": 545, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 546, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 547, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 548, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 549, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 550, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 551, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 552, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX (X ) -> X | VarY (Y ) -> Y | Sine (N ) -> Sin N;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 553, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> X | VarY (Y ) -> Y | Sine (N ) -> Sin N;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 554, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> X | VarY  -> Y | Sine (N ) -> Sin N;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 555, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> X | VarY  -> Y | Sine (N ) -> sin N;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 556, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> X | VarY  -> Y | Sine  -> sin N;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 557, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> exprToString X | VarY  -> Y | Sine e1 -> sin e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 558, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"VarX\" | VarY  -> \"VarY\" | Sine  -> sin e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 559, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"VarX\" | VarY  -> \"VarY\" | Sine e1 -> sin e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 560, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e1 -> sin (exprToString e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 561, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sin\"\n  | Cosine  -> \"cos\"\n  | Average  -> \"avg\"\n  | Times  -> \"*\"\n  | Thresh  -> \"/\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 562, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin\"\n  | Cosine  -> \"cos\"\n  | Average  -> \"avg\"\n  | Times  -> \"*\"\n  | Thresh  -> \"/\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 563, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin\" + (exprToSring e1)\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\"\n  | Thresh  -> \"/\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 564, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin\" + (exprToSring e1)\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 565, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin\" + \"x\"\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 566, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> sin e1\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 567, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> sin 1.0000\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 568, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> sin \"x\"\n  | Cosine e1 -> \"cos\" + (exprToString e1)\n  | Average (e1,e2) -> \"avg\"\n  | Times (e1,e2) -> (exprToSring e1) + \"*\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 569, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin\" + (exprToString e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine e1 -> \"sin\";;\n"}
{"hw": "hw2", "index": 570, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ ((\"+\" exprToString e2) ^ \")/2)\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"?\" ^ ((exprToString e2) ^ (\":\" ^ ((exprToString e4) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"?\" ^ ((exprToString e2) ^ (\":\" ^ ((exprToString e4) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 571, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Volume of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Volume (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1 \"*\") ^\n           ((exprToString e2 \"*\") ^ ((exprToString e3) ^ \")\")))\n  | Tan e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Volume of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Volume (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))))\n  | Tan e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 572, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen :: h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 573, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [seen; h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 574, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 575, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 576, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let t1 = List.nth l1 (List.length l1) in\n      let t2 = List.nth l2 (List.length l2) in\n      if (t1 + t2) > 9 then (1, [(t1 + t2) - 10]) else (0, [t1 + t2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 577, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let t1 = List.tl l1 in\n      let t2 = List.tl l2 in\n      if (t1 + t2) > 9 then (1, [(t1 + t2) - 10]) else (0, [t1 + t2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let t1 = List.nth l1 (List.length l1) in\n      let t2 = List.nth l2 (List.length l2) in\n      if (t1 + t2) > 9 then (1, [(t1 + t2) - 10]) else (0, [t1 + t2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 578, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev a in\n      let lr2 = List.rev x in\n      let h1::t1 = a in\n      let h2::t2 = x in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 579, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev a in\n      let lr2 = List.rev x in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 580, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev x in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 581, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev a in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 582, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev x in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9 then (1, [(h1 + h2) - 10]) else (0, [h1 + h2]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 583, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then (1, [(h1 + h2) - 10]) :: a\n      else (0, [h1 + h2]) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 584, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then (1, [(h1 + h2) - 10]) :: a\n      else (0, [h1 + h2]) :: a in\n    let base = [(0, [])] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 585, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then (1, [(h1 + h2) - 10]) :: a\n      else (0, [h1 + h2]) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 586, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then (1, [(h1 + h2) - 10]) :: x\n      else (0, [h1 + h2]) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 587, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then x ((1, [(h1 + h2) - 10]) :: a)\n      else x ((0, [h1 + h2]) :: a) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 588, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let lr1 = List.rev l1 in\n      let lr2 = List.rev l2 in\n      let h1::t1 = lr1 in\n      let h2::t2 = lr2 in\n      if (h1 + h2) > 9\n      then (1, [(h1 + h2) - 10]) :: (a x)\n      else (0, [h1 + h2]) :: (a x) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 589, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2)::t = x in\n      if (x1 + x2) > 9\n      then (1, ((x1 + x2) - 10)) :: a\n      else (0, (x1 + x2)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 590, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 591, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (value - 10) :: a else value :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 592, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else value :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 593, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then [(1, (value - 10))] @ a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 594, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 595, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 596, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then [(1, (value - 10))] @ a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 597, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [0. a1]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then [(1, (value - 10))] @ a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 598, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [(0, a1)]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then [(1, (value - 10))] @ a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 599, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [(0, a1)]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 600, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then [] else [(0, a1)]\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) else (0, value) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 601, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then (0, []) else (0, a1)\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) else (0, value) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 602, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then (0, 0) else (0, a1)\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) else (0, value) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 603, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::ta = a in\n      match x with\n      | [] -> 0\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then value - 10 else value in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 604, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2)::t' = a in\n      match x with\n      | [] -> if a1 = 0 then a else (0, a1) :: a\n      | (x1,x2)::t ->\n          let value = (a1 + x1) + x2 in\n          if value > 9 then (1, (value - 10)) :: a else (0, value) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 605, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      let val2 = (x1 + x2) / 10 in (val2, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 606, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      if val1 > 9 then (1, ((val1 - 10) :: a2)) else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      if val1 > 9 then (1, ((val1 - 10) :: a2)) else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 607, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      if val1 > 9 then (1, ((val1 - 10) :: a2)) else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine [0]) @ ((l1 [0]) @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then List.append [x] (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1),\n    (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      let (x1,x2) = x in\n      let val1 = (a1 + x1) + x2 in\n      if val1 > 9 then (1, ((val1 - 10) :: a2)) else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 608, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 1 -> [x] | n' -> [clone x (n - 1)];;\n", "fix": "\nlet rec clone x n =\n  match n with | 1 -> [x] | n' -> List.append (clone x (n - 1)) [];;\n"}
{"hw": "hw3", "index": 609, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n with | 1 -> [x] | n' -> List.append clone x (n - 1) [];;\n", "fix": "\nlet rec clone x n =\n  match n with | 1 -> [x] | n' -> List.append (clone x (n - 1)) [];;\n"}
{"hw": "hw3", "index": 610, "problem": "clone", "bad": "\nlet rec clone x n n = List.append (clone x (n - 1)) [x];;\n", "fix": "\nlet rec clone x n = x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 611, "problem": "clone", "bad": "\nlet rec clone x n = [clone x (n - 1); x];;\n", "fix": "\nlet rec clone x n = (clone x (n - 1)) @ [x];;\n"}
{"hw": "hw3", "index": 612, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a xs =\n    let (a1,a2) = a in\n    let h::t = xs in\n    let val1 = (h * i) + a1 in\n    if val1 > 9\n    then ((val1 / 10), ((val1 mod 10) :: a2))\n    else (0, (val1 :: a2)) in\n  let base = (0, []) in\n  let args = List.rev (0 :: l) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let (a1,a2) = a in\n    let val1 = (x * i) + a1 in\n    if val1 > 9\n    then ((val1 / 10), ((val1 mod 10) :: a2))\n    else (0, (val1 :: a2)) in\n  let base = (0, []) in\n  let args = 0 :: (List.rev l) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 613, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a xs =\n    let (a1,a2) = a in\n    let h::t = xs in\n    let val1 = (h * i) + a1 in\n    if val1 > 9\n    then ((val1 / 10), ((val1 mod 10) :: a2))\n    else (0, (val1 :: a2)) in\n  let base = (0, []) in\n  let args = 0 :: (List.rev l) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    let (a1,a2) = a in\n    let val1 = (x * i) + a1 in\n    if val1 > 9\n    then ((val1 / 10), ((val1 mod 10) :: a2))\n    else (0, (val1 :: a2)) in\n  let base = (0, []) in\n  let args = 0 :: (List.rev l) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 614, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet rec mulByDigit i l =\n  let mul (i,l) =\n    let f a x =\n      let (a1,a2) = a in\n      let val1 = (x * i) + a1 in\n      if val1 > 9\n      then ((val1 / 10), ((val1 mod 10) :: a2))\n      else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (0 :: l) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul i l);;\n", "fix": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | _ -> let h::t = l in (match h with | 0 -> removeZero t | _ -> l);;\n\nlet rec mulByDigit i l =\n  let mul (i,l) =\n    let f a x =\n      let (a1,a2) = a in\n      let val1 = (x * i) + a1 in\n      if val1 > 9\n      then ((val1 / 10), ((val1 mod 10) :: a2))\n      else (0, (val1 :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (0 :: l) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul (i, l));;\n"}
{"hw": "hw3", "index": 615, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.fold_right a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 616, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.fold_right a x in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 617, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in h a x in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 618, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in h a x in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 619, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in h a x in\n  let base = [0] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 620, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in h a x in\n  let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 621, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = x in h a t in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 622, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in a = (h x) in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 623, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = fs in (h x) + (h a) in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 624, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> 0 | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 625, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.fold_right a 0 x in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 626, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.fold_right a [] x in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 627, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.fold_right a [] x in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 628, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let h::t = x in (h a) t in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 629, "problem": "pipe", "bad": "\nlet pipe fs =\n  let rec f a x = let h::t = x in h a in\n  let base = [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let h::t = x in pipe t in\n  let base = [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let h::t = x in (pipe t) (h a) in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 630, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = x (a g) in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base k = k in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 631, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 632, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 633, "problem": "additivePersistence", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | xf::xb -> xf + (sumList xb);;\n\nlet rec additivePersistence n =\n  let x = sumList digits n in\n  if x > 9 then 1 + (additivePersistence x) else 1;;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | xf::xb -> xf + (sumList xb);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 9 then 1 + (additivePersistence x) else 1;;\n"}
{"hw": "hw1", "index": 634, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else ((digitsOfInt n) / 10) @ (n % 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 635, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 636, "problem": "digitsOfInt", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else digitsOfInt (n / 10) add [n mod 10];;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n"}
{"hw": "hw1", "index": 637, "problem": "digitsOfInt", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else digitsOfInt ((n / 10) add [n mod 10]);;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n"}
{"hw": "hw1", "index": 638, "problem": "digitsOfInt", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) add [n mod 10];;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n"}
{"hw": "hw1", "index": 639, "problem": "digitsOfInt", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) [n mod 10];;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n"}
{"hw": "hw1", "index": 640, "problem": "digitsOfInt", "bad": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n", "fix": "\nlet rec add current next =\n  match current with | [] -> [next] | front::back -> front :: (add back next);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else add (digitsOfInt (n / 10)) (n mod 10);;\n"}
{"hw": "hw1", "index": 641, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | front::back -> (listReverse back) :: front;;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 642, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | front::back -> back :: front;;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 643, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | front::back -> [listReverse back; front];;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 644, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | front::back -> [[listReverse back]; front];;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 645, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [1] | front::back -> (listReverse back) :: front;;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 646, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [1] | front::back -> [listReverse back; front];;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 647, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> None | front::back -> [listReverse back; front];;\n", "fix": "\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n"}
{"hw": "hw1", "index": 648, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n\nlet palindrome w = (explode w) = (listReverse explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec recurse original reverse =\n    match original with\n    | [] -> reverse\n    | front::back -> recurse back (front :: reverse) in\n  recurse l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 649, "problem": "sumList", "bad": "\nlet rec sumList xs = function | [] -> 0 | x::1 -> x + (sumList xs);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | xf::xb -> xf + (sumList xb);;\n"}
{"hw": "hw1", "index": 650, "problem": "sumList", "bad": "\nlet rec sumList xs = function | [] -> 0 | x::xs -> x + (sumList xs);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | xf::xb -> xf + (sumList xb);;\n"}
{"hw": "hw1", "index": 651, "problem": "sumList", "bad": "\nlet rec sumList xs = function | [] -> 0 | xf::xb -> xf + (sumList xb);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | xf::xb -> xf + (sumList xb);;\n"}
{"hw": "hw2", "index": 652, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 26) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildSine (build (rand, d))\n    | 3 -> buildSine (build (rand, d))\n    | 4 -> buildSine (build (rand, d))\n    | 5 -> buildSine (build (rand, d))\n    | 6 -> buildCosine (build (rand, d))\n    | 7 -> buildCosine (build (rand, d))\n    | 8 -> buildCosine (build (rand, d))\n    | 9 -> buildCosine (build (rand, d))\n    | 10 -> buildCosine (build (rand, d))\n    | 11 -> buildTimes (build (rand, d))\n    | 12 -> buildTimes (build (rand, d))\n    | 13 -> buildTimes (build (rand, d))\n    | 14 -> buildTimes (build (rand, d))\n    | 15 -> buildTimes (build (rand, d))\n    | 16 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 17 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 18 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 19 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 20 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 21 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 22 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 23 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 24 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 25 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n  else\n    (let r = rand (0, 1) in match r with | 0 -> buildX () | _ -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 26) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildSine (build (rand, d))\n    | 3 -> buildSine (build (rand, d))\n    | 4 -> buildSine (build (rand, d))\n    | 5 -> buildSine (build (rand, d))\n    | 6 -> buildCosine (build (rand, d))\n    | 7 -> buildCosine (build (rand, d))\n    | 8 -> buildCosine (build (rand, d))\n    | 9 -> buildCosine (build (rand, d))\n    | 10 -> buildCosine (build (rand, d))\n    | 11 -> buildTimes ((buildX ()), (build (rand, d)))\n    | 12 -> buildTimes ((buildX ()), (build (rand, d)))\n    | 13 -> buildTimes ((buildX ()), (build (rand, d)))\n    | 14 -> buildTimes ((buildX ()), (build (rand, d)))\n    | 15 -> buildTimes ((buildX ()), (build (rand, d)))\n    | 16 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 17 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 18 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 19 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 20 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 21 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 22 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 23 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 24 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n    | 25 ->\n        buildThresh\n          ((build (rand, d)), (buildX ()), (buildY ()), (buildX ()))\n  else\n    (let r = rand (0, 1) in match r with | 0 -> buildX () | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 653, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Tangent a ->\n      (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tangent of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Tangent a ->\n      (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 654, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Boo a -> ((eval (a, x, y)) +. (eval (a, x, y))) /. 100.0\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Hoi (a,b,c) ->\n      ((sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (b, x, y))))) /.\n        (eval (c, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Boo of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Boo a -> ((eval (a, x, y)) +. (eval (a, x, y))) /. 100.0\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Hoi (a,b,c) ->\n      ((sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (b, x, y))))) /.\n        (eval (c, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 655, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VaryY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\" +\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\" * \" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\" +\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\" * \" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 656, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n"}
{"hw": "hw2", "index": 657, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n"}
{"hw": "hw2", "index": 658, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tangent a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tangent of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tangent a -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp a) ^ \")\")));;\n"}
{"hw": "hw2", "index": 659, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tangent of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Tangent a ->\n      \"sin(pi*\" ^ ((exp a) ^ (\")/(\" (\"cos(pi*\" ^ ((exp a) ^ \")\")) \")\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 660, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      \"sin(pi*\" ^ ((exp a) ^ (\")/(\" (\"cos(pi*\" ^ ((exp b) ^ \")\")) \")\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 661, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      \"sin(pi*\" ^ ((exp a) ^ (\")/(\" (\"cos(pi*\" ^ ((exp b) ^ \")\")) \")\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 662, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      \"sin(pi*\" ^ ((exp a) ^ (\")\" / (\"(\" (\"cos(pi*\" ^ ((exp b) ^ \")\")) \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 663, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      (\"sin(pi*\" ^ ((exp a) ^ \")\")) \"/\" (\"cos(pi*\" ^ ((exp b) \")\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 664, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      (\"sin(pi*\" ^ ((exp a) ^ \")\")) \"/(\" (\"cos(pi*\" ^ ((exp b) \")\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 665, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) -> \"sin(pi*\" ^ ((exp a) ^ (\")/(cos(pi*\" ^ ((exp b) \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 666, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b) ->\n      (\"(sin(pi*\" ^ ((exp a) ^ \"))\")) \"/\" (\"(cos(pi*\" ^ ((exp b) ^ \"))\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 667, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      ((\"sin(pi*\" ^ ((exp a) ^ \")\")) \"*\" (\"cos(pi*\" ^ ((exp b) ^ \")\"))) \"/2\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 668, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      ((\"sin(pi*\" ^ ((exp a) ^ \")\")) \"*\" (\"cos(pi*\" ^ ((exp b) ^ \")\"))) \"/2\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 669, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Square a -> (\"(\" ^ ((exp a) ^ (\"*\" ^ ((exp a) ^ \")\")))) \"/2\"\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Square a -> \"((\" ^ ((exp a) ^ (\"*\" ^ ((exp a) ^ \")/2)\")))\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 670, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Boo a -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp a) ^ \")/100)\")))\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Boo of expr\n  | Hoi of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let exp = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exp a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exp a) ^ \")\")\n  | Boo a -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp a) ^ \")/100)\")))\n  | Average (a,b) -> \"((\" ^ ((exp a) ^ (\"+\" ^ ((exp b) ^ \")/2)\")))\n  | Times (a,b) -> (exp a) ^ (\"*\" ^ (exp b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exp a) ^\n           (\"<\" ^ ((exp b) ^ (\"?\" ^ ((exp c) ^ (\":\" ^ ((exp d) ^ \")\")))))))\n  | Hoi (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exp a) ^ (\")*cos(pi*\" ^ ((exp b) ^ (\")/(\" ^ ((exp c) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 671, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (2, 6) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (2, 6) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 672, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval e))\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 673, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> int_of_float sin (pi * (eval e))\n  | Cosine e -> int_of_float cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 674, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> int_of_float (sin (pi * (eval e)))\n  | Cosine e -> int_of_float (cos (pi * (eval e)))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 675, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval e)\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 676, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin ((eval e), x, y)\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 677, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval e x y)\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 678, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval e' x y)\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 679, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e' x y))\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 680, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin eval e' x y\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 681, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e -> cos (pi * (eval e))\n  | Average (e,e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e,e1) -> (eval e) * (eval e2)\n  | Thresh (e,e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 682, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval e) + (eval e1)) / 2\n  | Times (e',e1) -> (eval e) * (eval e2)\n  | Thresh (e',e2,e3,e4) -> (e < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 683, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval e') + (eval e1)) / 2\n  | Times (e',e1) -> (eval e') * (eval e2)\n  | Thresh (e',e2,e3,e4) -> (e' < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 684, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) + (eval (e1, x, y))) / 2\n  | Times (e',e1) -> (eval (e', x, y)) * (eval (e2, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 685, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) / 2\n  | Times (e',e1) -> (eval (e', x, y)) * (eval (e2, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 686, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e',e1) -> (eval (e', x, y)) * (eval (e2, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 687, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) * (eval (e2, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e',e1) -> ((eval (e', x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e',e1) -> (eval (e', x, y)) *. (eval (e1, x, y))\n  | Thresh (e',e2,e3,e4) ->\n      if (eval (e', x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 688, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 689, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 690, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ThreshRev (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e1 -> e1 *. e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ThreshRev (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) *. (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 691, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ThreshRev (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) *. (eval (x, y, e1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin ((eval (e1, x, y)) *. pi)\n  | Cosine e1 -> cos ((eval (e1, x, y)) *. pi)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ThreshRev (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) *. (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 692, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin\" ^ (exprToString e)\n  | Cosine e -> \"cos\" ^ (exprToString e)\n  | Average (e,e1) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e1) ^ (\")\" ^ \"/2\"))))\n  | Times (e,e1) -> (exprToString e) ^ (\"*\" ^ (exprToString e1))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2 \"?\") ^\n                 ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin\" ^ (exprToString e)\n  | Cosine e -> \"cos\" ^ (exprToString e)\n  | Average (e,e1) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e1) ^ (\")\" ^ \"/2\"))))\n  | Times (e,e1) -> (exprToString e) ^ (\"*\" ^ (exprToString e1))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 693, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" exprToString e2)\n  | Thresh (e1,e2,e3,4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 694, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 695, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ThreshRev (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e1 -> \"(\" ^ (exprToString ^ \")^2\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ThreshRev of expr* expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | ThreshRev (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e1 -> \"(\" ^ ((exprToString e1) ^ \")^2\");;\n"}
{"hw": "hw2", "index": 696, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 697, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h; seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 698, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem (seen', seen) then t else seen' @ seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 699, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if ((List.mem seen'), seen) then t else seen' @ seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 700, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem seen' seen then t else seen' @ seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 701, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem seen' seen then t else seen' :: seen in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 702, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t ->\n      (Printf.fprintf \"%s, %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t ->\n      (Printf.sprintf \"%s, %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n"}
{"hw": "hw2", "index": 703, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t ->\n      (Printf.fprintf 1 \"%s, %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t ->\n      (Printf.sprintf \"%s, %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n"}
{"hw": "hw2", "index": 704, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> print_string \"empty\" d\n  | (ki,vi)::t ->\n      (Printf.sprintf \"%s %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (print_string \"empty\"; d)\n  | (ki,vi)::t ->\n      (Printf.sprintf \"%s %d\\n\" ki vi;\n       if ki == k then vi else assoc (d, k, t));;\n"}
{"hw": "hw2", "index": 705, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand with\n    | 1 -> buildSine build (rand, (depth - 1))\n    | 2 -> buildCosine build (rand, (depth - 1))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand, (depth - 1))), buildY)\n    | 5 ->\n        e =\n          (buildThresh\n             (buildX, buildY, (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 706, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand with\n    | 1 -> buildSine build (rand', (depth - 1))\n    | 2 -> buildCosine build (rand', (depth - 1))\n    | 3 -> buildTimes ((build (rand', (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand', (depth - 1))), buildY)\n    | 5 ->\n        e =\n          (buildThresh\n             (buildX, buildY, (build (rand', (depth - 1))),\n               (build (rand', (depth - 1)))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 707, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand with\n    | 1 -> buildSine build (rand', (depth - 1))\n    | 2 -> buildCosine build (rand', (depth - 1))\n    | 3 -> buildTimes ((build (rand', (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand', (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          (buildX, buildY, (build (rand', (depth - 1))),\n            (build (rand', (depth - 1))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 708, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine build (rand', (depth - 1))\n    | 2 -> buildCosine build (rand', (depth - 1))\n    | 3 -> buildTimes ((build (rand', (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand', (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          (buildX, buildY, (build (rand', (depth - 1))),\n            (build (rand', (depth - 1))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 709, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand', (depth - 1)))\n    | 2 -> buildCosine build (rand', (depth - 1))\n    | 3 -> buildTimes ((build (rand', (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand', (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          (buildX, buildY, (build (rand', (depth - 1))),\n            (build (rand', (depth - 1))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 710, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine build (rand, (depth - 1))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand, (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          (buildX, buildY, (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 711, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), buildY)\n    | 4 -> buildAverage ((build (rand, (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          (buildX, buildY, (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 712, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), buildY)\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rand' = rand (1, 5) in\n    match rand' with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 -> buildTimes ((build (rand, (depth - 1))), (buildY ()))\n    | 4 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n    | 5 ->\n        buildThresh\n          ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else buildX ();;\n"}
{"hw": "hw2", "index": 713, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> (sin pi) * (eval expr)\n  | Cosine expr -> (cos pi) * (eval expr)\n  | Average (expr1,expr2) -> ((eval expr1) + (eval expr2)) / 2\n  | Times (expr1,expr2) -> (eval expr1) * (eval expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      ((eval expr1) < (eval expr2 ?eval expr3) : eval expr4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 714, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> (sin pi) *. (eval expr)\n  | Cosine expr -> (cos pi) * (eval expr)\n  | Average (expr1,expr2) -> ((eval expr1) + (eval expr2)) / 2\n  | Times (expr1,expr2) -> (eval expr1) * (eval expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      ((eval expr1) < (eval expr2 ?eval expr3) : eval expr4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 715, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 716, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> (sin pi) *. (eval (e', x, y))\n  | Cosine e' -> (cos pi) *. (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 717, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' -> cos ((((eval (e', x, y)) ** 2) -. (eval (e', x, y))) -. 1)\n  | MeanPi (e1,e2,e3) ->\n      cos\n        ((((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) /.\n           pi);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      cos\n        ((((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) /.\n           pi);;\n"}
{"hw": "hw2", "index": 718, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' -> cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1)\n  | MeanPi (e1,e2,e3) ->\n      cos\n        ((((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) /.\n           pi);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      cos\n        ((((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) /.\n           pi);;\n"}
{"hw": "hw2", "index": 719, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      sin (((eval (e1, x, y) eval) + (e2, x, y)) + ((eval (e3, x, y)) /. pi));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      sin\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +.\n           ((eval (e3, x, y)) /. pi));;\n"}
{"hw": "hw2", "index": 720, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      sin\n        (((eval (e1, x, y)) + (eval (e2, x, y))) + ((eval (e3, x, y)) /. pi));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' ->\n      cos ((((eval (e', x, y)) ** 2.0) -. (eval (e', x, y))) -. 1.0)\n  | MeanPi (e1,e2,e3) ->\n      sin\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +.\n           ((eval (e3, x, y)) /. pi));;\n"}
{"hw": "hw2", "index": 721, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' -> cos (((eval (e', x, y)) *. x) * y)\n  | MeanPi (e1,e2,e3) ->\n      sin (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Golden e' -> cos (((eval (e', x, y)) *. x) *. y)\n  | MeanPi (e1,e2,e3) ->\n      sin (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 722, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden  -> \"\"\n  | MeanPi  -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden expr -> \"\"\n  | MeanPi (expr1,expr2,expr3) -> \"\";;\n"}
{"hw": "hw2", "index": 723, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden  -> \"\"\n  | MeanPi  -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden expr -> \"\"\n  | MeanPi (expr1,expr2,expr3) -> \"\";;\n"}
{"hw": "hw2", "index": 724, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden expr -> \"cos(\" ^ (exprToString expr \"^2-\" exprToString expr \"-1)\")\n  | MeanPi (expr1,expr2,expr3) ->\n      \"sin(\" ^\n        ((exprToString expr1) ^\n           (\"+\" ^\n              ((exprToString expr2) ^ (\"+\" ^ ((exprToString expr3) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Golden of expr\n  | MeanPi of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \")/2\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))))\n  | Golden expr ->\n      \"cos(\" ^\n        ((exprToString expr) ^ (\"^2-\" ^ ((exprToString expr) ^ \"-1)\")))\n  | MeanPi (expr1,expr2,expr3) ->\n      \"sin(\" ^\n        ((exprToString expr1) ^\n           (\"+\" ^\n              ((exprToString expr2) ^ (\"+\" ^ ((exprToString expr3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 725, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let b' = f b in let f' = (b', (b == b')) in wwhile (f', b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' b = let b' = f b in (b', (b == b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 726, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' b = let b' = f b in (b', (b == b')) in wwhile ((f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' b = let b' = f b in (b', (b == b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 727, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b) else b';;\n"}
{"hw": "hw2", "index": 728, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b) else b';;\n"}
{"hw": "hw1", "index": 729, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = let x = n mod 10 in ((digitsOfInt n) / 10) @ [x];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 730, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 731, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | x::xs' -> ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 732, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 733, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n != 0\n  then\n    (if n > 0\n     then (digitsOfInt (n / 10)) @ [n mod 10]\n     else (digitsOfInt n) * (-1))\n  else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n != 0\n  then\n    (if n > 0\n     then (digitsOfInt (n / 10)) @ [n mod 10]\n     else digitsOfInt (n * (-1)))\n  else [];;\n"}
{"hw": "hw1", "index": 734, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw3", "index": 735, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (0, (x1 + x2)) @ a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 736, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (0, (x1 + x2)) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 737, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (0, ((x1 + x2) :: a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 738, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (0, ((x1 + x2) @ a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 739, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x1,x2) -> (0, ([x1 + x2] @ a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 740, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (0, ([x1 + x2] @ a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 741, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (0, ((x1 + x2) :: a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 742, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (x1 + x2) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 743, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (0, (x1 + x2)) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 744, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([0], ((x1 + x2) :: a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 745, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([0], ((x1 + x2) :: a)) in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 746, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([0], (x1 + x2)) :: a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 747, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (0, (x1 + x2)) :: a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 748, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10 then 1 else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 749, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ((if ((a1 + x1) + x2) >= 10 then 1 else 0), (((a1 + x1) + x2) :: a2)) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 750, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, (a2 :: (((a1 + x1) + x2) - 10)))\n      else (0, (a2 :: ((a1 + x1) + x2))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, (a2 @ [((a1 + x1) + x2) - 10]))\n      else (0, (a2 @ [(a1 + x1) + x2])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 751, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, (a2 @ (((a1 + x1) + x2) - 10)))\n      else (0, (a2 @ ((a1 + x1) + x2))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, (a2 @ [((a1 + x1) + x2) - 10]))\n      else (0, (a2 @ [(a1 + x1) + x2])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 752, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 753, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 754, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 755, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else mulByDigit (i - 1) bigAdd l l;;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 756, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else mulByDigit (i - 1) (bigAdd l l);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 757, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then [0]\n  else if i = 1 then l else (mulByDigit (i - 1) l) + (bigAdd l l);;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((a1 + x1) + x2) >= 10\n      then (1, ((((a1 + x1) + x2) - 10) :: a2))\n      else (0, (((a1 + x1) + x2) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 758, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then ((((clone 0) - n) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n"}
{"hw": "hw3", "index": 759, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (([(clone 0) - n] @ l1), l2) else (l1, ([clone 0 n] @ l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n"}
{"hw": "hw3", "index": 760, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then ((((clone 0) - n) :: l1), l2) else (l1, ((clone 0 n) :: l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else if n = 1 then [x] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n < 0 then (((clone 0 (- n)) @ l1), l2) else (l1, ((clone 0 n) @ l2));;\n"}
{"hw": "hw3", "index": 761, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f' d = x (a d) in let base c = c in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x d = x (a d) in let base c = c in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 762, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 763, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | h::t -> h + digitsO);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 764, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else (digitsOfInt (n / 10)) :: n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 765, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 766, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then n else (append n) mod (10 digitsOfInt (n / 10));;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 767, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then n else append (n mod 10) (digitsOfInt (n / 10));;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 768, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then n else append digitsOfInt (n / 10) [n mod 10];;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 769, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then n else append ((digitsOfInt (n / 10)), [n mod 10]);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 770, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then n else append (digitsOfInt (n / 10) [n mod 10]);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 771, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append digitsOfInt (n / 10) [n mod 10];;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 772, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else ((append digitsOfInt (n / 10)), [n mod 10]);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 773, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n = if n <= 0 then [n] else append digitsOfInt (n / 10);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 774, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> [r] | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n = if n <= 0 then [n] else append digitsOfInt (n / 10);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 775, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append digitsOfInt (n / 10) [n];;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 776, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else (append digitsOfInt n) / (10 [n]);;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 777, "problem": "digitsOfInt", "bad": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else (append digitsOfInt (n / 10) n) mod 10;;\n", "fix": "\nlet rec append l r = match l with | [] -> r | h::t -> h :: (append t r);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [n] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 778, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = Printf.sprintf explode w;;\n", "fix": "\nlet palindrome w = false;;\n"}
{"hw": "hw1", "index": 779, "problem": "sumList", "bad": "\nlet rec sumList xs = (List.hd xs) + (sumList List.tl x);;\n", "fix": "\nlet rec sumList xs =\n  if xs == [] then 0 else (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 780, "problem": "sumList", "bad": "\nlet rec sumList xs = if xs == [] then 0;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 781, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in d @ [n mod 10]);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> let s = sumList t in h + s;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in d @ [n mod 10]);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> let s = sumList t in h + s;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 782, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (fun n  -> let d = digitsOfInt (n / 10) in (n mod 10) :: d);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let d = digitsOfInt (n / 10) in (n mod 10) :: d);;\n"}
{"hw": "hw1", "index": 783, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then n else (let d = digitsOfInt (n / 10) in (n mod 10) :: d);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in (n mod 10) :: d);;\n"}
{"hw": "hw1", "index": 784, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in d :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let d::[] = digitsOfInt (n / 10) in [d; n mod 10]);;\n"}
{"hw": "hw1", "index": 785, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in [d; n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else (let d::[] = digitsOfInt (n / 10) in [d; n mod 10]);;\n"}
{"hw": "hw1", "index": 786, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in d @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10 then [n] else (let d = digitsOfInt (n / 10) in d @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 787, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let r = listReverse t in r :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let r = listReverse t in r @ [h];;\n"}
{"hw": "hw1", "index": 788, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x = 0 then y else (loop sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 789, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x = 0 then y else (loop (sumList (digitsOfInt x))) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 790, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x = 0 then y else loop ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 791, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else loop ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 792, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt loop x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 793, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else (sumList (digitsOfInt (loop x))) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 794, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else (sumList (digitsOfInt x)) + (loop y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y = if x < 10 then y else (sumList (digitsOfInt x)) + y in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 795, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else loop ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10\n    then y\n    else loop (sumList (digitsOfInt x)) ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 796, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else loop ((digitsOfInt (sumList (digitsOfInt x))) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10\n    then y\n    else loop (sumList (digitsOfInt x)) ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 797, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10 then y else loop ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec loop x y =\n    if x < 10\n    then y\n    else loop (sumList (digitsOfInt x)) ((sumList (digitsOfInt x)) + y) in\n  match n with | 0 -> 0 | x' -> loop x' 0;;\n"}
{"hw": "hw1", "index": 798, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec itt x i =\n    if x < 10\n    then i\n    else\n      (let x' = sumList (digitsOfInt x) in\n       if x' > 9 then (i + 1) + (itt x') else 1) in\n  match n with | 0 -> 0 | y' -> itt y';;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec itt x i =\n    if x < 10\n    then i\n    else\n      (let x' = sumList (digitsOfInt x) in\n       if x' > 9 then 1 + (itt x' i) else 1) in\n  match n with | 0 -> 0 | y' -> itt y' 0;;\n"}
{"hw": "hw1", "index": 799, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec itt x i =\n    if x < 10\n    then i\n    else\n      (let x' = sumList (digitsOfInt x) in\n       if x' > 9 then 1 + (itt x' i) else 1) in\n  match n with | 0 -> 0 | y' -> itt y';;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop x listX =\n    if x = 0 then listX else loop (x / 10) ((x mod 10) :: listX) in\n  match n with | 0 -> [0] | x' -> loop x' [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec itt x i =\n    if x < 10\n    then i\n    else\n      (let x' = sumList (digitsOfInt x) in\n       if x' > 9 then 1 + (itt x' i) else 1) in\n  match n with | 0 -> 0 | y' -> itt y' 0;;\n"}
{"hw": "hw1", "index": 800, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 10 then [n] else [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n"}
{"hw": "hw1", "index": 801, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec dig acc d =\n    if d < 10 then d :: acc else dig ((d mod 10) :: acc) (d div 10) in\n  dig [] d;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n"}
{"hw": "hw1", "index": 802, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 803, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; listReverse t];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 804, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 805, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 806, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n_ -> incr i additivePersistence (sumList (digitsOfInt n)));;\n", "fix": "\nlet incre i = i + 1;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n =\n  if lt10 n then n else (match n with | n -> incre n);;\n"}
{"hw": "hw1", "index": 807, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n = if lt10 n then n else 55 :: (digitsOfInt n);;\n", "fix": "\nlet incre i = i + 1;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n =\n  if lt10 n then n else (match n with | n -> incre n);;\n"}
{"hw": "hw1", "index": 808, "problem": "additivePersistence", "bad": "\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n = if lt10 n then n else 55 :: 66;;\n", "fix": "\nlet incre i = i + 1;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n =\n  if lt10 n then n else (match n with | n -> incre n);;\n"}
{"hw": "hw1", "index": 809, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n = if lt10 n then n else [55] @ (digitsOfInt n);;\n", "fix": "\nlet incre i = i + 1;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n =\n  if lt10 n then n else (match n with | n -> incre n);;\n"}
{"hw": "hw1", "index": 810, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet incre i = i + 1;;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with | n -> let x_ = digitsOfInt n in ((sumList x_), (incre i)));;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else (match n with | n -> let x_ = digitsOfInt n in sumList x_);;\n"}
{"hw": "hw1", "index": 811, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n ->\n         let n1 = let x0 = digitsOfInt n in sumList x0 in\n         additivePersistence n1);;\n"}
{"hw": "hw1", "index": 812, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n ->\n         let x_ = digitsOfInt n in\n         (sumList x_) = (let xx = sumList x_ in additivePersistence xx));;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n ->\n         let n1 = let x0 = digitsOfInt n in sumList x0 in\n         additivePersistence n1);;\n"}
{"hw": "hw1", "index": 813, "problem": "additivePersistence", "bad": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else (match n with | n -> let x_ = digitsOfInt n in [sumList x_]);;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;\n\nlet lt10 q = q < 10;;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if lt10 n\n  then n\n  else\n    (match n with\n     | n ->\n         let n1 = let x0 = digitsOfInt n in sumList x0 in\n         additivePersistence n1);;\n"}
{"hw": "hw1", "index": 814, "problem": "additivePersistence", "bad": "\nlet count = 0;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n = if lt10 n then count;;\n", "fix": "\nlet count = 0;;\n\nlet lt10 q = q < 10;;\n\nlet rec additivePersistence n = if lt10 n then count else 8;;\n"}
{"hw": "hw1", "index": 815, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | h::t -> h :: (digitsOfInt t));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n_ -> (n_ mod 10) :: (digitsOfInt n_));;\n"}
{"hw": "hw1", "index": 816, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | h::t -> h digistsOfInt t);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n_ -> (n_ mod 10) :: (digitsOfInt n_));;\n"}
{"hw": "hw1", "index": 817, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n_ -> (digitsOfInt (n / 10)) :: (n_ mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n_ -> (n_ mod 10) :: (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 818, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> (n' mod 10) @ (digitsOfInt (n / 10)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> (n' mod 10) :: (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 819, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> [digitsOfInt (n / 10); n' mod 10]);;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> (digitsOfInt (n / 10)) @ [modulus n']);;\n"}
{"hw": "hw1", "index": 820, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> (digitsOfInt (n / 10)) :: (n' mod 10));;\n", "fix": "\nlet modulus ss = ss mod 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (match n with | n' -> (digitsOfInt (n / 10)) @ [modulus n']);;\n"}
{"hw": "hw1", "index": 821, "problem": "palindrome", "bad": "\nlet checkSame (x,y) = x == y;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let revstr = listReverse (explode w) in\n  if checkSame (w, revstr) then true else false c;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) == (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 822, "problem": "palindrome", "bad": "\nlet checkSame (x,y) = x == y;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if checkSame ((listReverse (explode w)), w) then true else false c;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) == (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 823, "problem": "palindrome", "bad": "\nlet checkSame (x,y) = x == y;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if checkSame ((listReverse (explode w)), (explode w))\n  then true\n  else false c;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) == (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 824, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) == (explode w) then true else false c;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) == (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 825, "problem": "palindrome", "bad": "\nlet checkSame (x,y) = x == y;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if checkSame ((listReverse (explode w)), (explode w))\n  then true\n  else explode w;;\n", "fix": "\nlet checkSame (x,y) = x == y;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if checkSame ((listReverse (explode w)), (explode w)) then true else false;;\n"}
{"hw": "hw3", "index": 826, "problem": "bigAdd", "bad": "\nlet padZero l1 l2 = (List.length l1) - (List.length l2);;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 827, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) -> if (b + c) > 9 then (((b + c) - 10), 1) else ((b + c), 0) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 828, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (x, a) with\n      | ((fst,sec),_) ->\n          if (fst + sec) > 9\n          then (((fst + sec) - 10), 1)\n          else ((fst + sec), 0)\n      | (_,(carry,digits)) ->\n          if carry = 1\n          then (1, (digits @ (fst, sec)))\n          else (0, (digits @ (fst, sec))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 829, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (x, a) with\n      | ((fst,sec),_) ->\n          if (fst + sec) > 9\n          then (((fst + sec) - 10), 1)\n          else ((fst + sec), 0)\n      | ((fst,sec),(carry,digits)) ->\n          if sec = 1\n          then (1, (digits @ (fst, sec)))\n          else (0, (digits @ (fst, sec))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 830, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (_,(fst,sec)) ->\n          if (fst + sec) > 9\n          then (((fst + sec) - 10), 1)\n          else ((fst + sec), 0)\n      | ((carry,digits),(fst,sec)) ->\n          if sec = 1\n          then (1, (digits @ (fst, sec)))\n          else (0, (digits @ (fst, sec))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 831, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, (digits @ (fst, sec)))\n        else (0, (digits @ (fst, sec))) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 832, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, (digits @ (fst', sec')))\n        else (0, (digits @ (fst', sec'))) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 833, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, ((fst', sec') @ digits'))\n        else (0, ((fst', sec') @ digits')) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 834, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, ([(fst', sec')] @ digits))\n        else (0, ([(fst', sec')] @ digits)) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 835, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, ([(fst', sec')] @ digits))\n        else (0, ([(fst', sec')] @ digits)) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1), l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 836, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1\n        then (1, (digits @ [(fst', sec')]))\n        else (0, (digits @ [(fst', sec')])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if sec' = 1 then (1, (digits @ [fst'])) else (0, (digits @ [fst'])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 837, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if (carry + fst') > 9\n        then (1, (digits @ [fst' - 9]))\n        else\n          if sec' = 1\n          then (1, (digits @ [fst' + carry]))\n          else (0, (digits @ [fst' + carry])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (List.rev (padZero l1 l2)));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (fst,sec) = x in\n      let (fst',sec') =\n        if (fst + sec) > 9 then (((fst + sec) - 10), 1) else ((fst + sec), 0) in\n      let (carry,digits) = a in\n      let (carry',digits') =\n        if (carry + fst') > 9\n        then (1, (digits @ [fst' - 9]))\n        else\n          if sec' = 1\n          then (1, (digits @ [fst' + carry]))\n          else (0, (digits @ [fst' + carry])) in\n      (carry', digits') in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 838, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | n -> x :: (clone (x (n - 1)));;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | n -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 839, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (clone 0 n) @ l1 else (clone 0 n) @ l2;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (((clone 0 n) @ l1), l2) else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 840, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (clone 0 abs n) @ l1 else (clone 0 abs n) @ l2;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (((clone 0 n) @ l1), l2) else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 841, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (clone 0 n) ^ l1 else (clone 0 n) ^ l2;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (((clone 0 n) @ l1), l2) else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 842, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (((clone 0 n) @ l1), l2);;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n -> if n < 0 then (((clone 0 n) @ l1), l2) else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 843, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then ((((clone 0) - n) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 844, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 abs n) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 845, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else List.rev (((clone 0 n) @ l2), l1);;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (((clone 0 n) @ l2), l1);;\n"}
{"hw": "hw3", "index": 846, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else List.rev (((clone 0 n) @ l2), l1);;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | n -> if n < 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) - (List.length l2) with\n  | 0 -> (l1, l2)\n  | n ->\n      if n < 0\n      then (((clone 0 (n * (-1))) @ l1), l2)\n      else (l1, ((clone 0 n) @ l2));;\n"}
{"hw": "hw3", "index": 847, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 848, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = x (a y) in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 849, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = x (a y) in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base fs = fs in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 850, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in let base = h in let l = t in List.fold_left f base;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 851, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sep in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 852, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ t) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 853, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (f, (sepConcat l));;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 854, "problem": "stringOfList", "bad": "\nlet stringOfList f l = List.map (f, l);;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 855, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat, l);;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 856, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat, (f l));;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 857, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat, (\"\" l));;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 858, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map ((sepConcat (f, l)), l);;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 859, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map ((sepConcat f l), l);;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 860, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\", (List.map (f, l)));;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 861, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat, (f, l));;\n", "fix": "\nlet stringOfList f l = match l with | x::[] -> \"[\" ^ (x ^ \"]\");;\n"}
{"hw": "hw3", "index": 862, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> List.map (f, (sepConcat f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 863, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> List.map (f, (sepConcat \";\" l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 864, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with | [] -> \"[]\" | x::[] -> \"[\" ^ (x ^ \"]\") | l -> List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 865, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\";\", (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 866, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\" \", (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 867, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \" \" List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 868, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \" \" (List.map (f, l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 869, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\" \" (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 870, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\";\" (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 871, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat @ (List.map (f, l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 872, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"@\" List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 873, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \";\" List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 874, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\";\" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 875, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\", \" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 876, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat (\"\" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 877, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 878, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::[] -> \"[\" ^ (x ^ \"]\")\n  | l -> sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 879, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with | [] -> \"[]\" | l -> sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with | [] -> \"[]\" | l -> sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 880, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with | [] -> \"[]\" | l -> \"[\" ^ (sepConcat \";\" (List.map f l) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | l -> \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 881, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = if String.length = 0 then true else explode w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> (listReverse xs') @ [x];;\n\nlet palindrome w =\n  let wList = explode w in\n  let revList = listReverse wList in match revList with | wList -> true;;\n"}
{"hw": "hw1", "index": 882, "problem": "sumList", "bad": "\nlet rec sumList xs = match 1 with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 883, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw3", "index": 884, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 885, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) (if l1 > l2 then l1 else l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 886, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 887, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) -> let num = (l1e + l2e) + a in ((num mod 9), 7) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 888, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) -> let num = (l1e + l2e) + a in ((num mod 9), [7]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 889, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (l1e,l2e) -> (1, [7]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 890, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (l1e,l2e) -> let num = (l1e + l2e) + a in (num, [7]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 891, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (l1e,l2e) -> let num = l1e + l2e in (num, [7]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 892, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (l1e,l2e) -> let num = l1e + l2e in (num, [7]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((if l1 > l2 then l1 else l2) (padZero l1 l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 893, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), (7 @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 894, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 895, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 896, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = ([0], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 897, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (l1 (if l1 > l2 then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 898, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 899, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2) l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 900, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) (if l1 > l2 then l1 else l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 901, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add (padZero l1 l2)\n       (if (List.length l1) > (List.length l2) then l1 else l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 902, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero ((add (padZero l1 l2)), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in ((num mod 9), ([7] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero l1 l2), l2));;\n"}
{"hw": "hw3", "index": 903, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, (num @ list))\n               else if num = 10 then (1, ([0] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n"}
{"hw": "hw3", "index": 904, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, (list @ num))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, (list @ [num]))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n"}
{"hw": "hw3", "index": 905, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, (list @ [num]))\n               else\n                 if num = 10\n                 then (1, (list @ [0]))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine List.rev l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, (list @ [num]))\n               else\n                 if num = 10\n                 then (1, (list @ [0]))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n"}
{"hw": "hw3", "index": 906, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev padZero l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n"}
{"hw": "hw3", "index": 907, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n"}
{"hw": "hw3", "index": 908, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args =\n    ((padZero l1 l2),\n      (if (List.length l1) >= (List.length l2) then l1 else l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) <= (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet makeTuple l1 l2 =\n  let (x,y) = padZero l1 l2 in ((List.rev x), (clone y (List.length y)));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (aNum,wholeNum) ->\n        (match a with\n         | (zeros,total) ->\n             ((zeros @ [0]),\n               (bigAdd total ((mulByDigit aNum wholeNum) @ zeros)))) in\n  let base = ([], []) in\n  let args = let (x,y) = makeTuple l1 l2 in List.combine x y in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 909, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) <= (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n\nlet makeTuple l1 l2 =\n  let (x,y) = padZero l1 l2 in ((List.rev x), (clone y (List.length y)));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = makeTuple l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) <= (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet makeTuple l1 l2 =\n  let (x,y) = padZero l1 l2 in ((List.rev x), (clone y (List.length y)));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (aNum,wholeNum) ->\n        (match a with\n         | (zeros,total) ->\n             ((zeros @ [0]),\n               (bigAdd total ((mulByDigit aNum wholeNum) @ zeros)))) in\n  let base = ([], []) in\n  let args = let (x,y) = makeTuple l1 l2 in List.combine x y in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 910, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) <= (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet makeTuple l1 l2 =\n  let (x,y) = padZero l1 l2 in ((List.rev x), (clone y (List.length y)));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (aNum,wholeNum) ->\n        (match a with\n         | (zeros,total) ->\n             ((zeros @ [0]),\n               (bigAdd total ((mulByDigit a wholeNum) @ zeros)))) in\n  let base = ([], []) in\n  let args = let (x,y) = makeTuple l1 l2 in List.combine x y in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) <= (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet makeTuple l1 l2 =\n  let (x,y) = padZero l1 l2 in ((List.rev x), (clone y (List.length y)));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (aNum,wholeNum) ->\n        (match a with\n         | (zeros,total) ->\n             ((zeros @ [0]),\n               (bigAdd total ((mulByDigit aNum wholeNum) @ zeros)))) in\n  let base = ([], []) in\n  let args = let (x,y) = makeTuple l1 l2 in List.combine x y in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 911, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 912, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 913, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else (bigAdd l) + (mulByDigit (i - (1 l)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i <= 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 914, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i <= 1 then l else bigAdd l mulByDigit (i - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i <= 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 915, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i <= 1 then l else bigAdd l ((mulByDigit i) - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l =\n  let f a x =\n    if (List.length a) = 0 then (if x = 0 then [] else [x]) else a @ [x] in\n  let base = [] in List.fold_left f base l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (l1e,l2e) ->\n          (match a with\n           | (carry,list) ->\n               let num = (l1e + l2e) + carry in\n               if num < 10\n               then (0, ([num] @ list))\n               else\n                 if num = 10\n                 then (1, ([0] @ list))\n                 else ((num / 10), ([num mod 10] @ list))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero\n    (add\n       ((padZero l1 l2),\n         (if (List.length l1) > (List.length l2) then l1 else l2)));;\n\nlet rec mulByDigit i l =\n  if i <= 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 916, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((clone \"0\" List.length l2) - (List.length l1)) :: l1\n  else ((clone \"0\" List.length l1) - (List.length l2)) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n"}
{"hw": "hw3", "index": 917, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((clone \"[0]\" List.length l2) - (List.length l1)) :: l1\n  else ((clone \"0\" List.length l1) - (List.length l2)) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n"}
{"hw": "hw3", "index": 918, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone \"0\" ((List.length l2) - (List.length l1))) :: l1\n  else ((clone \"0\" List.length l1) - (List.length l2)) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n"}
{"hw": "hw3", "index": 919, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) :: l1\n  else (clone \"0\" ((List.length l1) - (List.length l2))) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n"}
{"hw": "hw3", "index": 920, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (((clone 0 ((List.length l1) - (List.length l2))) @ l2), l1);;\n"}
{"hw": "hw3", "index": 921, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs z = let f a x = x a in let base = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 922, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (x + x) in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs z = let f a x = x a in let base = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 923, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (h::t,z) -> z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs z = let f a x = x a in let base = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 924, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs z = let f a x = x a in let base = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 925, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base g p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 926, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base g p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x q = x q in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 927, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base z = z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x q = x q in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 928, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x t = t (x a) in let base z = z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x q = x q in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 929, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x p = p a x in let base z = z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x q = x q in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 930, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_right f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 931, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \";\" l);;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 932, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \";\" l);;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 933, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \";\" (List.map (fun t  -> let g = f t in g :: \"]\") l);;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun t  -> f t) l);;\n"}
{"hw": "hw3", "index": 934, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun t  -> ((f t) ^ \"]\") l));;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun t  -> f t) l);;\n"}
{"hw": "hw3", "index": 935, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \";\" (List.map f (List.map (fun f  -> \"[\" :: f :: \"]\") l));;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \";\" (List.map f (List.map (fun f  -> \"[\" :: f) l));;\n"}
{"hw": "hw2", "index": 936, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  let h::t = l in\n  let f::e = h in\n  if f = k then e else if t = [] then (-1) else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,m)::t -> if n = k then m else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 937, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let f::e = h in if f = k then e else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,m)::t -> if n = k then m else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 938, "problem": "build", "bad": "\nlet rec build (rand,depth) = match depth with | 0 -> rand (0, 1) | _ -> rand;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let x = rand (0, 1) in (match x with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      let x = rand (0, 6) in\n      (match x with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 939, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine  -> buildSine e\n  | Cosine  -> buildCosine e\n  | Average  -> buildAverage (e1, e2)\n  | Times  -> buildTimes (e1, e2)\n  | Thresh  -> buildThresh (a, b, a_less, b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 940, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (a,b,a_less,b_less) -> a < (b ?a_less:b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 941, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> (e1 +. e2) /. 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (a,b,a_less,b_less) -> a < (b ?a_less:b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 942, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (buildSine e))\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> (e1 +. e2) /. 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (a,b,a_less,b_less) -> a < (b ?a_less:b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 943, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 944, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 945, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> buildThresh (a, b, a_less, b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 946, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> y\n  | Sine e -> buildSine e\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> buildThresh (a, b, a_less, b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 947, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> (e +. e) /. 2.0\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (a,b,a_less,b_less) -> (a < (b ?a_less) : b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 948, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. e2\n  | Thresh (a,b,a_less,b_less) -> (a < (b ?a_less) : b_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 949, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> a < (b ?a_less);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 950, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> buildX ()\n  | buildY -> buildY ()\n  | Sine e -> buildSine (eval (e, x, y))\n  | Cosine e -> buildCosine (eval (e, x, y))\n  | Average (e1,e2) -> buildAverage ((eval (e1, x, y)), (eval (e2, x, y)))\n  | Times (e1,e2) -> buildTimes ((eval (e1, x, y)), (eval (e2, x, y)))\n  | Thresh (a,b,a_less,b_less) ->\n      buildThresh (a, b, a_less, (eval (b_less, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 951, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | buildY -> buildY ()\n  | Sine e -> buildSine (eval (e, x, y))\n  | Cosine e -> buildCosine (eval (e, x, y))\n  | Average (e1,e2) -> buildAverage ((eval (e1, x, y)), (eval (e2, x, y)))\n  | Times (e1,e2) -> buildTimes ((eval (e1, x, y)), (eval (e2, x, y)))\n  | Thresh (a,b,a_less,b_less) ->\n      buildThresh (a, b, a_less, (eval (b_less, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 952, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) -> 0.0;;\n"}
{"hw": "hw2", "index": 953, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> printf \"%s\" x | VarY y -> printf \"%s\" y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 954, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX s -> printf \"%s\" | VarY  -> printf \"%s\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 955, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX s -> s | VarY  -> printf \"%s\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 956, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> (\"sin(pi*\" + exprToString) + \")\"\n  | Cosine  -> (\"cos(pi*\" + exprToString) + \")\"\n  | Average  -> (((\"((\" + exprToString) + \"+\") + exprToString) + \")/2\"\n  | Times  -> (exprToString + \"*\") + exprToString\n  | Thresh  ->\n      (((((\"(\" + exprToString) + \"?\") + exprToString) + \":\") + exprToString)\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 957, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> (\"sin(pi*\" + (exprToString s)) + \")\"\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 958, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat (\"sin(pi*\", (exprToString s), \")\")\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 959, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat (\"sin(pi*\", (exprToString s))\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 960, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat (\"\", [\"sin(pi*\"; exprToString s; \")\"])\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 961, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 962, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> (\"cos(pi*\" + (exprToString s)) + \")\"\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 963, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      (((\"((\" + (exprToString s)) + \"+\") + (exprToString p)) + \")/2\"\n  | Times (s,p) -> ((exprToString s) + \"*\") + (exprToString p)\n  | Thresh (s,p,r,d) ->\n      (((((((\"(\" + (exprToString s)) + \"<\") + (exprToString p)) + \"?\") +\n           (exprToString r))\n          + \":\")\n         + (exprToString d))\n        + \")\"\n  | _ -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat \"\" [\"sin(pi*\"; exprToString s; \")\"]\n  | Cosine s -> String.concat \"\" [\"cos(pi*\"; exprToString s; \")\"]\n  | Average (s,p) ->\n      String.concat \"\" [\"((\"; exprToString s; \"+\"; exprToString p; \")/2\"]\n  | Times (s,p) -> String.concat \"\" [exprToString s; \"*\"; exprToString p]\n  | Thresh (s,p,r,d) ->\n      String.concat \"\"\n        [\"(\";\n        exprToString s;\n        \"<\";\n        exprToString p;\n        \"?\";\n        exprToString r;\n        \":\";\n        exprToString d;\n        \")\"]\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 964, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\")\n  | Cosine s -> \"cos(pi*\" ^ ((exprToString s) ^ \")\")\n  | Average (s,p) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString p) ^ \")/2\")))\n  | Times (s,p) -> (exprToString s) ^ (\"*\" ^ (exprToString p))\n  | Thresh (s,p,r,d) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString p) ^\n                 (\"?\" ^ ((exprToString r) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | AllMult (s,p,r) ->\n      (exprToString s) ^\n        (\"*\" ^ ((exprToString p) ^ (\"*\" ^ (exprToString p))))\n  | AvgThree (s,p,r) ->\n      \"((\" ^\n        ((exprToString s) ^\n           (\"+\" ^ ((exprToString p) ^ (\"+\" ^ ((exprToString p) ^ \")/2\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AllMult of expr* expr* expr\n  | AvgThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\")\n  | Cosine s -> \"cos(pi*\" ^ ((exprToString s) ^ \")\")\n  | Average (s,p) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString p) ^ \")/2\")))\n  | Times (s,p) -> (exprToString s) ^ (\"*\" ^ (exprToString p))\n  | Thresh (s,p,r,d) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString p) ^\n                 (\"?\" ^ ((exprToString r) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | AllMult (s,p,r) ->\n      (exprToString s) ^\n        (\"*\" ^ ((exprToString p) ^ (\"*\" ^ (exprToString p))))\n  | AvgThree (s,p,r) ->\n      \"((\" ^\n        ((exprToString s) ^\n           (\"+\" ^ ((exprToString p) ^ (\"+\" ^ ((exprToString p) ^ \")/2\")))));;\n"}
{"hw": "hw2", "index": 965, "problem": "fixpoint", "bad": "\nlet helper x r =\n  let m = x r in match m with | r -> (r, false) | _ -> (r, true);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 966, "problem": "fixpoint", "bad": "\nlet helper x r = let m = x r in match m with | r -> (r, false);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 967, "problem": "fixpoint", "bad": "\nlet helper (x,r) = let m = x r in match m with | r -> (r, false);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 968, "problem": "fixpoint", "bad": "\nlet helper (x,r) = let m = x r in (r, (r = m));;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 969, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 970, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (((f b) = (let rr = f b in (rr, (rr = b)))), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 971, "problem": "fixpoint", "bad": "\nlet helper (f,b) =\n  let x = f b in match x with | b -> (x, false) | _ -> (x, true);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 972, "problem": "fixpoint", "bad": "\nlet helper (f,b) = let x = f b in (x, (x = b));;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 973, "problem": "fixpoint", "bad": "\nlet rec helper (f,b) =\n  let (x,y) = f b in match x with | b -> (x, (x = b)) | _ -> helper (f, x);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 974, "problem": "fixpoint", "bad": "\nlet rec helper (f,b) = let (x,y) = f b in (x, (x = b));;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 975, "problem": "fixpoint", "bad": "\nlet helper (f,b) = let (x,y) = f b in (x, (x = b));;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 976, "problem": "fixpoint", "bad": "\nlet helper (f,b) =\n  let x = f b in match x with | b -> (x, false) | _ -> (x, true);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper f b), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 977, "problem": "fixpoint", "bad": "\nlet helper (f,b) =\n  let (x,y) = f b in match x with | b -> (x, false) | _ -> (x, true);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 978, "problem": "fixpoint", "bad": "\nlet helper (f,b) = let x = f b in match x with | b -> false | _ -> true;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 979, "problem": "fixpoint", "bad": "\nlet rec helper (f,b) =\n  let x = f b in match x with | b -> (x, false) | _ -> helper (f, x);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 980, "problem": "fixpoint", "bad": "\nlet helper (f,b) = let x = f b in (x, (x != b));;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 981, "problem": "fixpoint", "bad": "\nlet helper (f,b) =\n  let x = f b in match b with | x -> (x, (x != b)) | _ -> (x, true);;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 982, "problem": "fixpoint", "bad": "\nlet helper (f,b) = let f b = let x = f in (x, (x != b)) in f b;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper (f,b) = let f b = let x = f b in (x, (x != b)) in f;;\n\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n"}
{"hw": "hw2", "index": 983, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem (h, t)\n        then helper (seen', t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 984, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem (h, seen)\n        then helper (seen', t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 985, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if (List.mem (h, seen)) = true\n        then helper (seen', t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 986, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem (h, seen) in\n        if x\n        then helper (seen', t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 987, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem (h, seen) in\n        if x = true\n        then helper (seen', t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 988, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else (let seen' = [] @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 989, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else (let seen' = seen @ h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 990, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen :: h in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen @ [h] in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 991, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = [seen; h] in let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n", "fix": "\nlet rec append (x,y) =\n  match y with | [] -> x | h::t -> let z = h :: x in append (z, t);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = append (seen, [h]) in\n           let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n"}
{"hw": "hw2", "index": 992, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = seen :: h in let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n", "fix": "\nlet rec append (x,y) =\n  match y with | [] -> x | h::t -> let z = h :: x in append (z, t);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = append (seen, [h]) in\n           let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n"}
{"hw": "hw2", "index": 993, "problem": "removeDuplicates", "bad": "\nlet rec append (x,y) =\n  match y with | [] -> x | h::t -> let z = h :: x in append (z, t);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = append (seen, h) in\n           let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n", "fix": "\nlet rec append (x,y) =\n  match y with | [] -> x | h::t -> let z = h :: x in append (z, t);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let x = List.mem h seen in\n        if x\n        then helper (seen, t)\n        else\n          (let seen' = append (seen, [h]) in\n           let rest' = t in helper (seen', rest')) in\n  helper ([], l);;\n"}
{"hw": "hw2", "index": 994, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = wwhile (f, b) in\n  let h::t = x in match t with | false  -> h | true  -> wwhile (f, h);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n"}
{"hw": "hw2", "index": 995, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = wwhile (f, b) in\n  let h::t = x in match [t] with | false  -> h | true  -> wwhile (f, h);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n"}
{"hw": "hw2", "index": 996, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = wwhile (f, b) in\n  let h::t = x in\n  let r::l = t in match r with | false  -> h | true  -> wwhile (f, h);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n"}
{"hw": "hw2", "index": 997, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = f b in\n  let h::t = x in\n  let r::l = t in match t with | false  -> h | true  -> wwhile (f, h);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in match y with | false  -> x | true  -> wwhile (f, x);;\n"}
{"hw": "hw3", "index": 998, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 999, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1000, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x [0]) + (x [1]) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1001, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (r,s) = x in r + s in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1002, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet pairHelper x = let (r,s) = x in r + s;;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = pairHelper x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1003, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet pairHelper x = let (r,s) = x in r + s;;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (pairHelper x) :: a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1004, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet pairHelper x = let (r,s) = x in r + s;;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (pairHelper x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1005, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in\n      let (r,s) = a in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1006, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) :: (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1007, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) :: (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1008, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1009, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1)) :: (0 (List.rev l2)) :: 0 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1010, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1)) @ ((0 (List.rev l2)) @ 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1011, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) @ 0) ((List.rev l2) @ 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1012, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1013, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (l1 @ 0)) (List.rev (l2 @ 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1014, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (l1 :: 0)) (List.rev (l2 :: 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1015, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev [l1; 0]) (List.rev [l2; 0]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1016, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = a in\n    let (c,d) = x in let z = (c * d) + m in ((z / 10), ((z mod 10) :: n)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev ([(0, 0, 0, 0)] :: l1))\n      (List.rev ([(0, 0, 0, 0)] :: l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = a in\n    let (c,d) = x in let z = (c * d) + m in ((z / 10), ((z mod 10) :: n)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: 0 :: 0 :: 0 :: l1))\n      (List.rev (0 :: 0 :: 0 :: 0 :: l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1017, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = a in\n    let (c,d) = x in let z = (c * d) + m in ((z / 10), ((z mod 10) :: n)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev ([0; 0; 0; 0] :: l1))\n      (List.rev ([0; 0; 0; 0] :: l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (m,n) = a in\n    let (c,d) = x in let z = (c * d) + m in ((z / 10), ((z mod 10) :: n)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: 0 :: 0 :: 0 :: l1))\n      (List.rev (0 :: 0 :: 0 :: 0 :: l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1018, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet rec multHelper l3 l4 x =\n  match l3 with\n  | [] -> [0]\n  | h::t -> bigAdd (mulByDigit h l4) (multHelper t l4 (x + 1));;\n\nlet bigMul l1 l2 =\n  let f a x = multHelper (List.rev l1) l2 0 in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1019, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = (mulByDigit o p) + b in ((r / 10), ((r mod 10) :: b)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev l1) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1020, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = (mulByDigit o List.rev l2) + b in ((r / 10), ((r mod 10) :: b)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev l1) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1021, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = (mulByDigit o (List.rev l2)) + b in ((r / 10), ((r mod 10) :: b)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev l1) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1022, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = [(mulByDigit o (List.rev l2)) + b] in\n    ((r / 10), ((r mod 10) :: b)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev l1) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1023, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = bigAdd (mulByDigit o (List.rev l2)) [b] in\n    ((r / 10), ((r mod 10) :: b)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev l1) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1024, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (o,p) = x in\n    let r = bigAdd (mulByDigit o (List.rev l2)) [b] in\n    match r with | [] -> [0] | h::t -> (h, (t :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1025, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, ([0] :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let r = bigAdd (mulByDigit x (List.rev l2)) [b] in\n    match r with | [] -> (0, (0 :: c)) | h::t -> (h, ((List.hd t) :: c)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1026, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone (x, (n - 1)); x];;\n", "fix": "\nlet helper (x,m) = x :: m;;\n\nlet rec clone x n = match n with | 0 -> [] | _ -> helper (x, (clone x n));;\n"}
{"hw": "hw3", "index": 1027, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [(clone x n) - 1; x];;\n", "fix": "\nlet helper (x,m) = x :: m;;\n\nlet rec clone x n = match n with | 0 -> [] | _ -> helper (x, (clone x n));;\n"}
{"hw": "hw3", "index": 1028, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> ((clone x n) - 1) :: x;;\n", "fix": "\nlet helper (x,m) = x :: m;;\n\nlet rec clone x n = match n with | 0 -> [] | _ -> helper (x, (clone x n));;\n"}
{"hw": "hw3", "index": 1029, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone (x, (n - 1))) :: x;;\n", "fix": "\nlet helper (x,m) = x :: m;;\n\nlet rec clone x n = match n with | 0 -> [] | _ -> helper (x, (clone x n));;\n"}
{"hw": "hw3", "index": 1030, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [x; clone x (n - 1)];;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1031, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let x = h * i in\n      (match x with\n       | x when x >= 10 -> (x / 10) :: ((x mod 10) + (mulByDigit i t))\n       | _ -> x :: (mulByDigit i t));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1032, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let x = h * i in\n      (match x with\n       | x when x >= 10 -> (x / 10) ::\n           ((x mod 10) + (List.hd (mulByDigit i t)))\n       | _ -> x :: (mulByDigit i t));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1033, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let x = h * i in\n      (match x with\n       | x when x >= 10 ->\n           (x / 10) @ ((x mod 10) + (List.hd (mulByDigit i t)))\n       | _ -> x :: (mulByDigit i t));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1034, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> 0 | _ -> (bigAdd l l) + (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1035, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> 0 | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = a in\n      let (r,s) = x in let m = (r + s) + y in ((m / 10), ((m mod 10) :: z)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1036, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (clone 0 z) :: y\n  else (let z = y - x in (clone 0 z) :: x);;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then let z = x - y in (l1, ((clone 0 z) @ l2))\n  else (let z = y - x in (((clone 0 z) @ l1), l2));;\n"}
{"hw": "hw3", "index": 1037, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1038, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1039, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1040, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base x = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1041, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1042, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1043, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x fs in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1044, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1045, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1046, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1047, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet f a x = (a * a) + x;;\n\nlet pipe fs =\n  let f a x x a = f a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1048, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x * a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1049, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1050, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1051, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1052, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1053, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (fun a  -> x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1054, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1055, "problem": "pipe", "bad": "\nlet f a x = let (r,s) = x in r + s;;\n\nlet pipe fs =\n  let f a x a x = f x f a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1056, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1057, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1058, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1059, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1060, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1061, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1062, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1063, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ t) in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1064, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | x::xs' -> a * a in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1065, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | x::xs' -> x * x in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1066, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | x::d -> x * x in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1067, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> h * h in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1068, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> 1 in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1069, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1070, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> a * a in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1071, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | _ -> a * a in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1072, "problem": "sqsum", "bad": "\nlet f a x = a * a;;\n\nlet sqsum xs =\n  let f a x = let aa = a * a in aa + f in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1073, "problem": "sqsum", "bad": "\nlet rec helper (a,x) =\n  match x with | [] -> 0 | h::t -> (h * h) + (helper (a, x));;\n\nlet sqsum xs =\n  let f a x = helper (a, x) in\n  let base = List.hd xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1074, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a * a in let base = f in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + x in let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1075, "problem": "sqsum", "bad": "\nlet f a x = a * a;;\n\nlet sqsum xs =\n  let f a x = (a * a) + (f a) in let base = x in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + x in let base = List.hd xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1076, "problem": "sqsum", "bad": "\nlet f a x = a * a;;\n\nlet sqsum xs =\n  let f a x = (a * a) + (f List.hd xs x) in\n  let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1077, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1078, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = ((fst x) + (snd x)) + (fst a) in ((sum / 10), (sum mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1079, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = ((fst x) + (snd x)) + (fst a) in ((sum / 10), (sum mod 10))\n        :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1080, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = ((fst x) + (snd x)) + (fst a) in (sum / 10) :: (sum mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1081, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = ((fst x) + (snd x)) + (fst a) in\n      match a with | h::t -> (sum / 10) :: (sum mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1082, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in (sum / 10) ::\n            (sum mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1083, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in (sum / 10) ::\n            (sum mod 10) :: t in\n    let base = [()] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1084, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in (sum / 10) ::\n            (sum mod 10) :: t in\n    let base = [a :: b] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1085, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in\n          ((sum / 10), (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1086, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in\n          ((sum / 10), (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1087, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in ((sum / 10) ::\n            (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1088, "problem": "bigAdd", "bad": "\nlet rec padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then padZero (0 :: l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then padZero l1 (0 :: l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          let sum = ((fst x) + (snd x)) + (fst h) in (sum / 10) ::\n            (sum mod 10) :: t\n      | _ -> let sum' = (fst x) + (snd x) in (sum / 10) :: (sum mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1089, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          (match h with\n           | (b,c) ->\n               (match x with\n                | (first,second) -> (((first + second) + b) / 10) ::\n                    (((first + second) + b) mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1090, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          (match h with\n           | (b,c) ->\n               (match x with\n                | (first,second) ->\n                    ((((first + second) + b) / 10),\n                      ((((first + second) + b) mod 10) :: t)))) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1091, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          (match h with\n           | (fir,sec) ->\n               (match a with\n                | h::t -> ((fir + sec) + (h / 10)) ::\n                    (((fir + sec) + h) mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1092, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          (match h with\n           | (fir,sec) ->\n               (match a with\n                | h::t -> ((fir + sec) + (h / 10)) ::\n                    (((fir + sec) + h) mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1093, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          (match h with\n           | (fir,sec) ->\n               (match a with\n                | h::t -> ((fir + sec) + (h / 10)) ::\n                    (((fir + sec) + h) mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1094, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with | h::t -> (h + (sum / 10)) :: ((h + sum) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with | h::t -> (h + (sum / 10)) :: ((h + sum) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1095, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> (h + (sum / 10)) :: ((h + sum) mod 10) :: t\n      | _ -> (sum / 10) :: (sum mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1096, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> (h + (sum / 10)) :: ((h + sum) mod 10) :: t\n      | _ -> (((fst x) + (snd x)) / 10) :: (((fst x) + (snd x)) mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1097, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          (match a with\n           | hd::tl -> ((((fst h) + (snd h)) + hd) / 10) ::\n               ((((fst h) + (snd h)) + hd) mod 10) :: tl) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1098, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = x in\n      match a with\n      | hd::tl -> (((a + b) + hd) / 10) :: (((a + b) + hd) mod 10) :: tl in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1099, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = x in\n      match a with\n      | hd::tl -> (((a + b) + hd) / 10) :: (((a + b) + hd) mod 10) :: tl in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1100, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl\n      | _ -> (((fst x) + (snd x)) / 10) :: (((fst x) + (snd x)) mod 10) in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl\n      | _ -> (((fst x) + (snd x)) / 10) :: (((fst x) + (snd x)) mod 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1101, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl\n      | _ -> (((fst x) + (snd x)) / 10) :: (((fst x) + (snd x)) mod 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | hd::tl -> ((((fst x) + (snd x)) + hd) / 10) ::\n          ((((fst x) + (snd x)) + hd) mod 10) :: tl\n      | _ -> (((fst x) + (snd x)) / 10) :: (((fst x) + (snd x)) mod 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1102, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          if (((fst x) + (snd x)) + h) > 9\n          then (1, (((((fst x) + (snd x)) + h) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + h) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, ((((fst x) + (snd x)) mod 10) :: a))\n          else (0, ((((fst x) + (snd x)) mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (((((fst x) + (snd x)) + a) mod 10) :: b))\n          else (0, (((((fst x) + (snd x)) + a) mod 10) :: b))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1103, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          if (((fst x) + (snd x)) + h) > 9\n          then (1, (((((fst x) + (snd x)) + h) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + h) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, (((fst x) + (snd x)) mod 10))\n          else (0, (((fst x) + (snd x)) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (((((fst x) + (snd x)) + a) mod 10) :: b))\n          else (0, (((((fst x) + (snd x)) + a) mod 10) :: b))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1104, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | h::t ->\n          if (((fst x) + (snd x)) + h) > 9\n          then (1, (((((fst x) + (snd x)) + h) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + h) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (((((fst x) + (snd x)) + a) mod 10) :: b))\n          else (0, (((((fst x) + (snd x)) + a) mod 10) :: b))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1105, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10)))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10)))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1106, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1107, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, ((a :: ((((fst x) + (snd x)) + a) mod 10)) @ t))\n          else (0, ((a :: ((((fst x) + (snd x)) + a) mod 10)) @ t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,h::d::t) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1108, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, (a :: ((((fst x) + (snd x)) + a) mod 10)))\n          else (0, (a :: ((((fst x) + (snd x)) + a) mod 10)))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, [a; (((fst x) + (snd x)) + a) mod 10])\n          else (0, [a; (((fst x) + (snd x)) + a) mod 10])\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1109, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (a,b) ->\n          if (((fst x) + (snd x)) + a) > 9\n          then (1, ((((fst x) + (snd x)) + a) mod 10))\n          else (0, ((((fst x) + (snd x)) + a) mod 10))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1110, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,d) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, ((((fst x) + (snd x)) + c) mod 10))\n          else (0, ((((fst x) + (snd x)) + c) mod 10))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1111, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,d) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, ((((fst x) + (snd x)) + c) mod 10))\n          else (0, ((((fst x) + (snd x)) + c) mod 10))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, (((fst x) + (snd x)) mod 10))\n          else (0, (((fst x) + (snd x)) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1112, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,d) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, ((((fst x) + (snd x)) + c) mod 10))\n          else (0, ((((fst x) + (snd x)) + c) mod 10))\n      | (0,[]) ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, (((fst x) + (snd x)) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1113, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,d) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, ((((fst x) + (snd x)) + c) mod 10))\n          else (0, ((((fst x) + (snd x)) + c) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1114, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, (((fst x) + (snd x)) mod 10))\n          else (0, (((fst x) + (snd x)) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,h::t) ->\n          if (((fst x) + (snd x)) + c) > 9\n          then (1, (((((fst x) + (snd x)) + c) mod 10) :: t))\n          else (0, (((((fst x) + (snd x)) + c) mod 10) :: t))\n      | _ ->\n          if ((fst x) + (snd x)) > 9\n          then (1, [((fst x) + (snd x)) mod 10])\n          else (0, [((fst x) + (snd x)) mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1115, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = mulByDigit (int_of_string l1) s in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1116, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = int_of_string (mulByDigit (int_of_string l1) s) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1117, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum =\n          int_of_string\n            (sepConcat \"\" (mulByDigit (int_of_string (sepConcat \"\" l1)) s)) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1118, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = mulByDigit (int_of_string (sepConcat \"\" l1)) s in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1119, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum =\n          int_of_string\n            (sepConcat \" \" (mulByDigit (int_of_string (sepConcat \"\" l1)) s)) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1120, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = mulByDigit (intListToInt l1) s in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then (((sum + r) / 10), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.combine l2 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1121, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((int_of_float ((sum + r) mod 10)), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((sum + r), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1122, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((int_of_float (sum + r)), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((sum + r), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1123, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((int_of_float ((sum + r) / 10)), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((sum + r), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1124, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then ((carryFunc (sum + r)), (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1125, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = (List.rev (List.combine l2 l2)) @ [((0, 0), (0, 0))] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1126, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev ((List.combine l2 l2) @ [((0, 0), (0, 0), (0, 0))]) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ (helper ((List.length l2) * 2) x);;\n"}
{"hw": "hw3", "index": 1127, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet helper l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  helper x res ((List.length res) * 2);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ (helper ((List.length l2) * 2) x);;\n"}
{"hw": "hw3", "index": 1128, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10);;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  [helper ((List.length l2) * 2) x] @ res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ (helper ((List.length l2) * 2) x);;\n"}
{"hw": "hw3", "index": 1129, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10);;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ [helper ((List.length l2) * 2) x];;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ (helper ((List.length l2) * 2) x);;\n"}
{"hw": "hw3", "index": 1130, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ [helper ((List.length l2) * 2) x];;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet rec helper n x = if n > 0 then helper (n - 1) (x / 10) else [];;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (s,t) = x in\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [s]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [s]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = List.rev (List.combine l2 l2) in\n  let (x,res) = List.fold_left f base args in\n  res @ (helper ((List.length l2) * 2) x);;\n"}
{"hw": "hw3", "index": 1131, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) x) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) x))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = [0; 0; 0; 0; 0; 0; 0] @ l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [x]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [x]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1132, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [x]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [x]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = l2 in\n  let (x,res) = List.fold_left f base args in\n  [List.map (fun i  -> i mod 10) x] @ res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [x]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [x]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = l2 in\n  let (x,res) = List.fold_left f base args in [x mod 10] @ res;;\n"}
{"hw": "hw3", "index": 1133, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [x]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [x]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = l2 in\n  let (x,res) = List.fold_left f base args in\n  (List.rev\n     ([(x / 10000) mod 10] @\n        ([(x / 1000) mod 10] @\n           ([(x / 100) mod 10] @ ([(x / 10) mod 10] @ [((x / 1) x) mod 10])))))\n    @ res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      match a with\n      | (c,d) ->\n          if ((i + j) + c) > 9\n          then (1, ((((i + j) + c) mod 10) :: d))\n          else (0, ((((i + j) + c) mod 10) :: d)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet carryFunc p = let z = List.rev p in match z with | h::t -> List.rev t;;\n\nlet intListToInt l = int_of_string (sepConcat \"\" (List.map string_of_int l));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (r,v) ->\n        let sum = intListToInt (mulByDigit (intListToInt l1) [x]) in\n        if (sum + r) > 9\n        then\n          ((intListToInt (carryFunc (mulByDigit (intListToInt l1) [x]))),\n            (((sum + r) mod 10) :: v))\n        else (0, (((sum + r) mod 10) :: v)) in\n  let base = (0, []) in\n  let args = l2 in\n  let (x,res) = List.fold_left f base args in\n  (List.rev\n     ([(x / 10000) mod 10] @\n        ([(x / 1000) mod 10] @\n           ([(x / 100) mod 10] @ ([(x / 10) mod 10] @ [(x / 1) mod 10])))))\n    @ res;;\n"}
{"hw": "hw3", "index": 1134, "problem": "clone", "bad": "\nlet rec clone x n = if n > 1 then x :: (clone x (n - 1));;\n", "fix": "\nlet rec clone x n = x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1135, "problem": "clone", "bad": "\nlet rec clone x n = if n > 1 then x @ (clone x (n - 1));;\n", "fix": "\nlet rec clone x n = x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1136, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (padZero 0) :: (l1 l2)\n    else (padZero l1 0) :: l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1137, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (padZero [0]) :: (l1 l2)\n    else (padZero l1 [0]) :: l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1138, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = sepConcat t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1139, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1140, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ t) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1141, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let y x = List.map f l in sepConcat \"[\" y;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let fix l x = List.map f l in sepConcat \"[\" l;;\n"}
{"hw": "hw3", "index": 1142, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 1143, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | h::t -> if k h then v else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1144, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | h::t -> if k = h then v else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1145, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (k, d) with\n  | [] -> d\n  | h::t -> if (k, d) = l then d else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1146, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = l then d else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1147, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = l then d else assoc (d, k, [t]);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1148, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = l then d else assoc (d, k, (t :: l));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if (k, d) = h then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1149, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match [(k, d)] with\n  | [] -> d\n  | h::t -> if [(k, d)] = h then d else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1150, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1151, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand 0.6 with\n  | 0 -> if (rand (0, 2)) = 0 then Varx else Vary\n  | 1 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then Varx else Vary)\n      else Sine a\n  | 2 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then Varx else Vary)\n      else Cosine b\n  | 3 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then Varx else Vary)\n      else Average (c, d)\n  | 4 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then Varx else Vary)\n      else Times (e, f)\n  | 5 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then Varx else Vary)\n      else Thresh (g, h, i, j);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (0, 6) with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | 1 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildSine (build (rand, (depth - 1)))\n  | 2 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1152, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand (0.0, 6.0) with\n  | 0 -> if (rand (0.0, 2.0)) = 0.0 then Varx else Vary\n  | 1 ->\n      if depth = 0\n      then (if (rand (0.0, 2.0)) = 0.0 then Varx else Vary)\n      else Sine a\n  | 2 ->\n      if depth = 0\n      then (if (rand (0.0, 2.0)) = 0.0 then Varx else Vary)\n      else Cosine b\n  | 3 ->\n      if depth = 0\n      then (if (rand (0.0, 2.0)) = 0.0 then Varx else Vary)\n      else Average (c, d)\n  | 4 ->\n      if depth = 0\n      then (if (rand (0.0, 2.0)) = 0.0 then Varx else Vary)\n      else Times (e, f)\n  | 5 ->\n      if depth = 0\n      then (if (rand (0.0, 2.0)) = 0.0 then Varx else Vary)\n      else Thresh (g, h, i, j);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (0, 6) with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | 1 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildSine (build (rand, (depth - 1)))\n  | 2 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1153, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunny (c,d,e) = Funny (c, d, e);;\n\nlet buildFunny1 f = Funny1 f;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (0, 8) with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | 1 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildSine (build (rand, (depth - 1)))\n  | 2 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildFunny (build (rand, (depth - 1)))\n  | 7 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildFunny1 (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunny (c,d,e) = Funny (c, d, e);;\n\nlet buildFunny1 f = Funny1 f;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (0, 8) with\n  | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n  | 1 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildSine (build (rand, (depth - 1)))\n  | 2 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else\n        buildFunny\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  | 7 ->\n      if depth = 0\n      then (if (rand (0, 2)) = 0 then buildX () else buildY ())\n      else buildFunny1 (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1154, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"cos(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n\nlet rec eval (e,x,y) =\n  match (e, x, y) with | x -> buildX () | (a,b,c) -> exprToString a;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (eval (c, x, y)) +. ((eval (d, x, y)) /. 2.0)\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y);;\n"}
{"hw": "hw2", "index": 1155, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (c +. d) /. 2\n  | Times (e,f) -> e *. f\n  | Thresh (g,h,i,j) -> (g < (h ?i) : j);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (eval (c, x, y)) +. ((eval (d, x, y)) /. 2.0)\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y);;\n"}
{"hw": "hw2", "index": 1156, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> c +. (d /. 2)\n  | Times (e,f) -> e *. f\n  | Thresh (g,h,i,j) -> (g < (h ?i) : j);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (eval (c, x, y)) +. ((eval (d, x, y)) /. 2.0)\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y);;\n"}
{"hw": "hw2", "index": 1157, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (eval (c, x, y)) +. ((eval (d, x, y)) /. 2)\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> (eval (c, x, y)) +. ((eval (d, x, y)) /. 2.0)\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y);;\n"}
{"hw": "hw2", "index": 1158, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      ((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) / 1000;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      ((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) /. 1000.0;;\n"}
{"hw": "hw2", "index": 1159, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      ((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) / 1000.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      ((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) /. 1000.0;;\n"}
{"hw": "hw2", "index": 1160, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      (((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))) /. 10\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) /. 1000.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Funny of expr* expr* expr\n  | Funny1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine b -> cos (pi *. (eval (b, x, y)))\n  | Average (c,d) -> ((eval (c, x, y)) +. (eval (d, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (g,h,i,j) ->\n      if (eval (g, x, y)) < (eval (h, x, y))\n      then eval (i, x, y)\n      else eval (j, x, y)\n  | Funny (k,l,m) ->\n      (((eval (k, x, y)) +. (eval (l, x, y))) +. (eval (m, x, y))) /. 10.0\n  | Funny1 n -> (sqrt (abs_float (eval (n, x, y)))) /. 1000.0;;\n"}
{"hw": "hw2", "index": 1161, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> printf \"%s\" x | VarY y -> printf \"%s\" y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" \"x\"\n  | VarY  -> Printf.sprintf \"%s\" \"y\";;\n"}
{"hw": "hw2", "index": 1162, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" VarX\n  | VarY  -> Printf.sprintf \"%s\" VarY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" \"x\"\n  | VarY  -> Printf.sprintf \"%s\" \"y\";;\n"}
{"hw": "hw2", "index": 1163, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" \"x\"\n  | VarY  -> Printf.sprintf \"%s\" \"y\"\n  | Sine a -> Printf.sprintf \"%expr\" \"(pi*\" a \")\"\n  | Cosine b -> Printf.sprintf \"%expr\" \"(pi*\" b \")\"\n  | Average (c,d) -> Printf.sprintf \"%expr%expr\" c \"+\" d \"/2\"\n  | Times (e,f) -> Printf.sprintf \"%expr%expr\" e \"*\" f\n  | Thresh (g,h,i,j) -> Printf.sprintf \"%expr%expr%expr\" (g < (h ?i) : j);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1164, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" \"x\"\n  | VarY  -> Printf.sprintf \"%s\" \"y\"\n  | Sine a -> Printf.sprintf \"%expr\" \"(pi*\" a \")\"\n  | Cosine b -> Printf.sprintf \"%expr\" \"(pi*\" b \")\"\n  | Average (c,d) -> Printf.sprintf \"%expr%expr\" c \"+\" d \"/2\"\n  | Times (e,f) -> Printf.sprintf \"%expr%expr\" e \"*\" f\n  | Thresh (g,h,i,j) ->\n      Printf.sprintf \"%expr%expr%expr\" \"(\" g \"<\" h \"?\" i \":\" j \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1165, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" + (exprToString d \")\" \"/2)\")))\n  | Times (e,f) -> exprToString e \"*\" exprToString f\n  | Thresh (g,h,i,j) ->\n      \"(\" exprToString g \"<\" exprToString h \"?\" exprToString i \":\"\n        exprToString j \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1166, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ (exprToString d \")\" \"/2)\")))\n  | Times (e,f) -> exprToString e \"*\" exprToString f\n  | Thresh (g,h,i,j) ->\n      \"(\" exprToString g \"<\" exprToString h \"?\" exprToString i \":\"\n        exprToString j \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1167, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ (\")\" \"/2)\"))))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine b -> \"(pi*\" ^ ((exprToString b) ^ \")\")\n  | Average (c,d) ->\n      \"((\" ^ ((exprToString c) ^ (\"+\" ^ ((exprToString d) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (g,h,i,j) ->\n      \"(\" ^\n        ((exprToString g) ^\n           (\"<\" ^\n              ((exprToString h) ^\n                 (\"?\" ^ ((exprToString i) ^ (\":\" ^ ((exprToString j) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1168, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match b with | b -> wwhile f b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match b with | b -> if (f b) = (b, true) then wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1169, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | b -> if (f b) = ((f b), true) then wwhile (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match b with | b -> if (f b) = (b, true) then wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1170, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match b with | b -> f b wwhile ((f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1171, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match b with | b -> wwhile ((f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1172, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match (f, b) with | h::t -> h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1173, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1174, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h else h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1175, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h else b;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1176, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h else f h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1177, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h else f h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1178, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h else f b;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1179, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h else f t;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1180, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then f b;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1181, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then f t;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1182, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then f;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1183, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then t;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1184, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then f h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1185, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then f b;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h;;\n"}
{"hw": "hw2", "index": 1186, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then h;;\n"}
{"hw": "hw2", "index": 1187, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (_,t) -> if t = true then 5;;\n", "fix": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then h;;\n"}
{"hw": "hw2", "index": 1188, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then t;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 1189, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 1190, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = true then f h else h;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 1191, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (h,t) -> if t = false then h else f h;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 1192, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else f b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' = false then b' else wwhile (f, b');;\n"}
{"hw": "hw3", "index": 1193, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1194, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1195, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1196, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = f 0 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1197, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1198, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1199, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1200, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1201, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1202, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1203, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1204, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1205, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1206, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1207, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw1", "index": 1208, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw3", "index": 1209, "problem": "bigAdd", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | [] -> [[b / 10]; b mod 10]\n      | h::t -> [(h + b) / 10] :: [(h + b) mod 10] :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1210, "problem": "bigAdd", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> [(h + b) / 10] :: [(h + b) mod 10] :: t\n      | [] -> [[b / 10]; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1211, "problem": "bigAdd", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1212, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1213, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone ((x n) - 1));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1214, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> 0 | 1 -> 1 | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1215, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> [l] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1216, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> [l] | _ -> [bigAdd l (mulByDigit (i - 1) l)];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1217, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> [0]\n  | 1 -> [l]\n  | _ -> [bigAdd [l] [mulByDigit (i - 1) l]];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1218, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> [l] | _ -> bigAdd [l] [mulByDigit (i - 1) l];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1219, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l = let x = List.map (l * i) l in big Add x [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1220, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = let x = List.map (l * i) l in bigAdd x [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1221, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (List.map (l * i) l) [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1222, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ((List.map l) * (i l)) [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1223, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (List.map (l * (i l))) [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1224, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd List.map (l * (i l)) [];;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1225, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (List.map (l * (i l)) []);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1226, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (((List.map l) * (i l)), []);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1227, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ([(List.map l) * (i l)], []);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1228, "problem": "mulByDigit", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | [] -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ([(List.map l) * (i l)] []);;\n", "fix": "\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | [] -> [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = i * x in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | [] -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1229, "problem": "padZero", "bad": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (padZero 0) :: (l1 l2)\n    else (padZero l1 0) :: l2;;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), l2)\n    else (l1, (0 :: l2));;\n"}
{"hw": "hw3", "index": 1230, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then clone (0 :: l1) l2\n    else clone l1 (0 :: l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), l2)\n    else (l1, (0 :: l2));;\n"}
{"hw": "hw3", "index": 1231, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then clone (0 :: l1) (List.length l2)\n    else clone (List.length l1) (0 :: l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), l2)\n    else (l1, (0 :: l2));;\n"}
{"hw": "hw3", "index": 1232, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) :: l1\n    else clone (List.length l1) (0 :: l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), l2)\n    else (l1, (0 :: l2));;\n"}
{"hw": "hw3", "index": 1233, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2)\n    else clone (List.length l1) (0 :: l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), l2)\n    else (l1, (0 :: l2));;\n"}
{"hw": "hw3", "index": 1234, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (clone 0 ((List.length l1) - (List.length l2)))) @ l2\n  else (((clone 9 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1235, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [(1, (sum - 1))] else [sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1236, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1237, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1238, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1239, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1240, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = l'\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n"}
{"hw": "hw3", "index": 1241, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1242, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1243, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x b x a = x a b in let base i = i in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1244, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> []\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n", "fix": "\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n"}
{"hw": "hw1", "index": 1245, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt n in\n  match x with\n  | head -> 0\n  | head::tail -> 1 + (additivePersistence sumList n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt n in\n  match x with\n  | head -> 0\n  | head::tail -> 1 + (additivePersistence (sumList x));;\n"}
{"hw": "hw1", "index": 1246, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt n in\n  match x with\n  | head -> 0\n  | head::tail -> 1 + (additivePersistence sumList x);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt n in\n  match x with\n  | head -> 0\n  | head::tail -> 1 + (additivePersistence (sumList x));;\n"}
{"hw": "hw1", "index": 1247, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt in\n  match x with\n  | [] -> 0\n  | head::[] -> 0\n  | head::tail -> 1 + (additivePersistence (sumList x));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let x = digitsOfInt n in\n  match x with\n  | [] -> 0\n  | head::[] -> 0\n  | head::tail -> 1 + (additivePersistence (sumList x));;\n"}
{"hw": "hw1", "index": 1248, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else ((digitsOfInt n) / 10) :: (n % 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1249, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1250, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1251, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let newList = [] in\n  match l with\n  | [] -> newList\n  | head::tail -> (listReverse tail) :: newList :: head;;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1252, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let newList = [] in\n  match l with\n  | [] -> []\n  | head::[] -> head\n  | head::tail -> (listReverse tail) :: head;;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1253, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let newList = [] in\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) :: head;;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1254, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let newList = [] in\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> [listReverse tail; head];;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1255, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let newList = [] in\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> [listReverse [tail]; head];;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1256, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> [listReverse [tail]; head];;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1257, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse [tail]) @ [head];;\n", "fix": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::[] -> [head]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 1258, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n <= 0\n  then []\n  else if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 1259, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 1260, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [7] else [8];;\n"}
{"hw": "hw1", "index": 1261, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then 7;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [7] else [8];;\n"}
{"hw": "hw1", "index": 1262, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [7];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [7] else [8];;\n"}
{"hw": "hw1", "index": 1263, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n mod 10) = 0 then n else (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1264, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1265, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1266, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1267, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n::ns -> let tailn = digitsOfInt ns in if x then x :: tailn else tailn;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1268, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> [listReverse t] @ [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 1269, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 1270, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h :: (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw3", "index": 1271, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1272, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1273, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1274, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1275, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a + x), (a + x)) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1276, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a + x), (a + x)) in\n    let base = (0, 0) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1277, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1278, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1279, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1280, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x + a), (x + a)) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1281, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x + a), (x + a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1282, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1283, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + a in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,temp) = a in\n      let s = (x1 + x2) + carry in\n      let carry' = s / 10 in\n      let rem = s mod 10 in\n      let acc = rem :: temp in\n      if (List.length acc) = (List.length l1)\n      then (0, (carry' :: acc))\n      else (carry', acc) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1284, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0 then (clone 0 difference) :: l1;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1285, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0\n  then (clone 0 difference1) :: l1\n  else if difference2 > 0 then (clone 0 difference2) :: l2;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1286, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0 then (clone 0 difference1) :: l1;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1287, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0 then (clone 0 2) :: l1;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1288, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0 then [clone 0 2];;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1289, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0 then (((clone 0 difference1) :: l1), l2);;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1290, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference1 > 0 then (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1291, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in if difference1 > 0 then retTuple;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1292, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = l1 * l2 in if difference1 > 0 then retTuple;;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in retTuple;;\n"}
{"hw": "hw3", "index": 1293, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in\n  if difference1 > 0 then (l1, l2) else if difference2 > 0 then (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  let retTuple = (l1, l2) in\n  if difference1 > 0\n  then (l1, l2)\n  else if difference2 > 0 then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1294, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then ((l1 :: (clone 0 difference2)), l2)\n  else\n    if difference1 > 0 then (l1, (l2 :: (clone 0 difference1))) else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference1 = (List.length l1) - (List.length l2) in\n  let difference2 = (List.length l2) - (List.length l1) in\n  if difference2 > 0\n  then (((clone 0 difference2) @ l1), l2)\n  else\n    if difference1 > 0 then (l1, ((clone 0 difference1) @ l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1295, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1296, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = a in let base f = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1297, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x a = x a in let base f = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1298, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1299, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = f = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1300, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x a = x x a in let base f x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f' = x (a f') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1301, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f' = f' (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f' = x (a f') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1302, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = f in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1303, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = h ^ (sep :: t) in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1304, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | x::t -> x * x in\n  let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = match x with | 0 -> a | x -> x * x in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1305, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 1306, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 1307, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 1308, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw2", "index": 1309, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX | 1 -> buildY\n  else\n    (match rand (2, 7) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1310, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX | 1 -> buildY\n  else\n    (match rand (2, 7) with\n     | 2 -> buildSine build (rand, (depth - 1))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1311, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 0) with | 0 -> buildX | 1 -> buildY\n  else\n    (match rand (2, 7) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1312, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX | 1 -> buildY | 2 -> buildX\n  else\n    (match rand (2, 7) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1313, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX | 1 -> buildY\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1314, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1315, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1316, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 1) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 1) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1317, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 1) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 1) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 7) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1318, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCirc (c1,c2) = Circ (c1, c2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOscillate n = Oscillate n;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 2) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 25) with\n     | 0 ->\n         if depth < 5\n         then buildX ()\n         else\n           buildCirc\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 1 ->\n         if depth < 5\n         then buildY ()\n         else\n           buildCirc\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2|7|8 -> buildSine (build (rand, (depth - 1)))\n     | 3|9|13 -> buildCosine (build (rand, (depth - 1)))\n     | 4|10|14 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5|11|15 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6|12 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 17|18|19|23|25 -> buildCirc (build (rand, (depth - 1)))\n     | 20|21|22|16 -> buildOscillate (build (rand, (depth - 1)))\n     | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr\n  | Oscillate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCirc c1 = Circ c1;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOscillate n = Oscillate n;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 2) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 25) with\n     | 0 ->\n         if depth < 5\n         then buildX ()\n         else buildCirc (build (rand, (depth - 1)))\n     | 1 ->\n         if depth < 5\n         then buildY ()\n         else buildCirc (build (rand, (depth - 1)))\n     | 2|7|8 -> buildSine (build (rand, (depth - 1)))\n     | 3|9|13 -> buildCosine (build (rand, (depth - 1)))\n     | 4|10|14 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5|11|15 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6|12 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 17|18|19|23|25 -> buildCirc (build (rand, (depth - 1)))\n     | 20|21|22|16 -> buildOscillate (build (rand, (depth - 1)))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1319, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr\n  | Oscillate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCirc c1 = Circ c1;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOscillate n = Oscillate n;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 2) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 25) with\n     | 0 ->\n         if depth < 5\n         then buildX ()\n         else\n           buildCirc\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 1 ->\n         if depth < 5\n         then buildY ()\n         else\n           buildCirc\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2|7|8 -> buildSine (build (rand, (depth - 1)))\n     | 3|9|13 -> buildCosine (build (rand, (depth - 1)))\n     | 4|10|14 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5|11|15 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6|12 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 17|18|19|23|25 -> buildCirc (build (rand, (depth - 1)))\n     | 20|21|22|16 -> buildOscillate (build (rand, (depth - 1)))\n     | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr\n  | Oscillate of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCirc c1 = Circ c1;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOscillate n = Oscillate n;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (0, 2) with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (match rand (0, 25) with\n     | 0 ->\n         if depth < 5\n         then buildX ()\n         else buildCirc (build (rand, (depth - 1)))\n     | 1 ->\n         if depth < 5\n         then buildY ()\n         else buildCirc (build (rand, (depth - 1)))\n     | 2|7|8 -> buildSine (build (rand, (depth - 1)))\n     | 3|9|13 -> buildCosine (build (rand, (depth - 1)))\n     | 4|10|14 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5|11|15 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6|12 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 17|18|19|23|25 -> buildCirc (build (rand, (depth - 1)))\n     | 20|21|22|16 -> buildOscillate (build (rand, (depth - 1)))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1320, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX x' -> printf \"%s\" x\n  | VarY y' -> printf \"%s\" y\n  | Sine sin -> printf \"sin(%s)\" sin\n  | Cosine cos -> printf \"cos(%s)\" cos\n  | Average ave -> printf \"((%s+%s)/2)\" ave\n  | Times t -> printf \"%s*%s\" t\n  | Thresh th -> printf \"(%s<*%s?%s:%s)\" th;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1321, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf (\"%s\" x)\n  | VarY  -> printf \"%s\" y\n  | Sine sin -> printf \"sin(%s)\" sin\n  | Cosine cos -> printf \"cos(%s)\" cos\n  | Average (e1,e2) -> printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) -> printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1322, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.sprintf (\"%s\" x)\n  | VarY  -> printf \"%s\" y\n  | Sine sin -> printf \"sin(%s)\" sin\n  | Cosine cos -> printf \"cos(%s)\" cos\n  | Average (e1,e2) -> printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) -> printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1323, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf \"sin(%s)\" sin\n  | Cosine cos -> Printf.printf \"cos(%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1324, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(%s)\" sin)\n  | Cosine cos -> Printf.printf \"cos(%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1325, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin( %s )\" sin)\n  | Cosine cos -> Printf.printf \"cos(%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1326, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.sprintf (\"sin( %s )\" sin)\n  | Cosine cos -> Printf.printf \"cos(%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1327, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin( %s )\", sin)\n  | Cosine cos -> Printf.printf \"cos(%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1328, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(pi*%s)\" sin)\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1329, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(pi*%s)\" ^ sin)\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1330, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(pi*\" ^ (sin ^ \")\"))\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1331, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf \"%s\"\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(pi*%s\" ^ (sin ^ \")\"))\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1332, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf x\n  | VarY  -> Printf.printf \"%s\"\n  | Sine sin -> Printf.printf (\"sin(pi*%s\" ^ (sin ^ \")\"))\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1333, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf x\n  | VarY  -> Printf.printf y\n  | Sine sin -> Printf.printf (\"sin(pi*%s\" ^ (sin ^ \")\"))\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1334, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> Printf.printf x\n  | VarY  -> Printf.printf y\n  | Sine sin -> Printf.printf (\"sin(pi*%s\" ^^ (sin ^^ \")\"))\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1335, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sin -> \"sin(pi*\" ^ ((eval sin) ^ \")\")\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1336, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sin -> \"sin(pi*\" ^ ((eval sin x y) ^ \")\")\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1337, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sin -> \"sin(pi*\" ^ ((eval (sin, x, y)) ^ \")\")\n  | Cosine cos -> Printf.printf \"cos(pi*%s)\" cos\n  | Average (e1,e2) -> Printf.printf \"((%s+%s)/2)\" e1 e2\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1338, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sin -> \"sin(pi*\" ^ ((eval (sin, x, y)) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> Printf.printf \"%s*%s\" t1 t2\n  | Thresh (th1,th2,th3,th4) ->\n      Printf.printf \"(%s<*%s?%s:%s)\" th1 th2 th3 th4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1339, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi * sine)\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1340, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin sine\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1341, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi * (eval sine))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1342, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (eval sine)\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1343, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi * (eval (sine, x, y)))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1344, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (eval (sine, x, y))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1345, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> \"\" ^ (sin (pi * (eval (sine, x, y))))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1346, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> \"\" ^ (sin (pi *. (eval (sine, x, y))))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1347, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cos -> \"cos(pi*\" ^ ((eval (cos, x, y)) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((eval (e1, x, y)) ^ (\"+\" ^ ((eval (e2, x, y)) ^ \")/2)\")))\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1348, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) / 2)\n  | Times (t1,t2) -> (eval (t1, x, y)) ^ (\"*\" ^ (eval (t2, x, y)))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((eval (th1, x, y)) ^\n           (\"<*\" ^\n              ((eval (th2, x, y)) ^\n                 (\"?\" ^\n                    ((eval (th3, x, y)) ^ (\":\" ^ ((eval (th4, x, y)) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1349, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1350, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1351, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y);;\n"}
{"hw": "hw2", "index": 1352, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) -> ((eval circ1) ** 2) + (eval circ2)\n  | NatLog nlog -> log nlog;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1353, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) -> ((eval circ1) ** 2) + ((eval circ2) ** 2)\n  | NatLog nlog -> log nlog;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1354, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2) + ((eval (circ2, x, y)) ** 2)\n  | NatLog nlog -> log eval (nlog, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1355, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) + ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log eval (nlog, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1356, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      (exp eval (circ1, x, y) 2.0) + (exp eval (circ2, x, y) 2.0)\n  | NatLog nlog -> log eval (nlog, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1357, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      (exp (eval (circ1, x, y) 2.0)) + (exp eval (circ2, x, y) 2.0)\n  | NatLog nlog -> log eval (nlog, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1358, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log eval (nlog, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | NatLog nlog -> log (eval (nlog, x, y));;\n"}
{"hw": "hw2", "index": 1359, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Fibonacci of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | Arcsin m4 -> asin (eval (nlog, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Arcsin of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | Arcsin m4 -> asin (eval (m4, x, y));;\n"}
{"hw": "hw2", "index": 1360, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Arcsin of expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Quad of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | Arcsin m4 -> (eval (m4, x, y)) ** 4.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Quad of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      ((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0)\n  | Quad m4 -> (eval (m4, x, y)) ** 4.0;;\n"}
{"hw": "hw2", "index": 1361, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) *. (1 +. (sqrt 5))) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) *. (1.0 +. (sqrt 5.0))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1362, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) * (1 +. (sqrt 5))) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) *. (1.0 +. (sqrt 5.0))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1363, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) *. (1.0 +. (sqrt 5))) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | GoldTimes of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | GoldTimes m4 -> ((eval (m4, x, y)) *. (1.0 +. (sqrt 5.0))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1364, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | NatLog m4 -> (-1) *. (eval (m4, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | NatLog m4 -> (-1.0) *. (eval (m4, x, y));;\n"}
{"hw": "hw2", "index": 1365, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | NatLog m4 -> (eval (m4, x, y)) ** 4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (((eval (circ1, x, y)) ** 2.0) +. ((eval (circ2, x, y)) ** 2.0))\n  | NatLog m4 -> (eval (m4, x, y)) ** 4.0;;\n"}
{"hw": "hw2", "index": 1366, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 -> sin ((pi * 1.0) /. (eval (m4, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 -> sin ((pi *. 1.0) /. (eval (m4, x, y)));;\n"}
{"hw": "hw2", "index": 1367, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 ->\n      let x = eval (m4, x, y) in\n      x /. (sqrt (((eval (m4, x, y)) ** 2) +. (x ** 2)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ (circ1,circ2) ->\n      sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 ->\n      let x = eval (m4, x, y) in\n      x /. (sqrt (((eval (m4, x, y)) ** 2.0) +. (x ** 2.0)));;\n"}
{"hw": "hw2", "index": 1368, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ circ1 -> sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 ->\n      let x = eval (m4, x, y) in\n      x /. (sqrt (((1.0 -. x) ** 2.0) +. (x ** 2.0)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr\n  | Oscillate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine sine -> sin (pi *. (eval (sine, x, y)))\n  | Cosine cosine -> cos (pi *. (eval (cosine, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (th1,th2,th3,th4) ->\n      if (eval (th1, x, y)) < (eval (th2, x, y))\n      then eval (th3, x, y)\n      else eval (th4, x, y)\n  | Circ circ1 -> sqrt (abs_float (1.0 -. ((eval (circ1, x, y)) ** 2.0)))\n  | Oscillate m4 ->\n      let x = eval (m4, x, y) in\n      x /. (sqrt (((1.0 -. x) ** 2.0) +. (x ** 2.0)));;\n"}
{"hw": "hw2", "index": 1369, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<*\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<*\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1370, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | NatLog nlog -> \"ln(\" ^ (nlog ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | NatLog nlog -> \"ln(\" ^ ((exprToString nlog) ^ \")\");;\n"}
{"hw": "hw2", "index": 1371, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | NatLog nlog -> \"ln(\" ^ (nlog ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | NatLog of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | NatLog nlog -> \"ln(\" ^ ((exprToString nlog) ^ \")\");;\n"}
{"hw": "hw2", "index": 1372, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Fibonacci of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | Arcsin m4 -> \"asin(\" ^ ((exprToString m4) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Arcsin of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ (circ1,circ2) ->\n      \"(\" ^ ((exprToString circ1) ^ (\"^2+\" ^ ((exprToString circ2) ^ \")\")))\n  | Arcsin m4 -> \"asin(\" ^ ((exprToString m4) ^ \")\");;\n"}
{"hw": "hw2", "index": 1373, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr* expr\n  | Oscillate of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ circ1 -> \"sqrt(|1-\" ^ ((exprToString circ1) ^ \"^2|)\")\n  | Oscillate m4 ->\n      \"(\" ^\n        ((exprToString m4) ^\n           (\"/((1-\" ^\n              ((exprToString m4) ^ (\")^2+\" ^ ((exprToString m4) ^ \"^2))\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Circ of expr\n  | Oscillate of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sine -> \"sin(pi*\" ^ ((exprToString sine) ^ \")\")\n  | Cosine cosine -> \"cos(pi*\" ^ ((exprToString cosine) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | Circ circ1 -> \"sqrt(|1-\" ^ ((exprToString circ1) ^ \"^2|)\")\n  | Oscillate m4 ->\n      \"(\" ^\n        ((exprToString m4) ^\n           (\"/((1-\" ^\n              ((exprToString m4) ^ (\")^2+\" ^ ((exprToString m4) ^ \"^2))\")))));;\n"}
{"hw": "hw2", "index": 1374, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin (f,b) = (b, ((f b) = b)) in (fin, b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin bt = (bt, ((f bt) = bt)) in (fin, b));;\n"}
{"hw": "hw2", "index": 1375, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let fin (f',b') = (b', ((f' b') = b')) in ((fin (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin bt = (bt, ((f bt) = bt)) in (fin, b));;\n"}
{"hw": "hw2", "index": 1376, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let fin (f',b') = let nfb = f' b' in (nfb, (nfb = b')) in\n     ((fin (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin bt = (bt, ((f bt) = bt)) in (fin, b));;\n"}
{"hw": "hw2", "index": 1377, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let fin b' = (b', ((f b') = b')) in ((fin b), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin bt = (bt, ((f bt) = bt)) in (fin, b));;\n"}
{"hw": "hw2", "index": 1378, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let fin bt = (bt, ((f bt) = bt)) in ((fin b), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fin bt = (bt, ((f bt) = bt)) in (fin, b));;\n"}
{"hw": "hw2", "index": 1379, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem (h, seen) with | true  -> [] | false  -> [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if true then [] else [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1380, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [] else [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if true then [] else [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1381, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then [] else [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1382, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then [] else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1383, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h seen) then [] else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1384, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw1", "index": 1385, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n =\n  n = ((n mod 10) + (additivePersistence (n / 10)));;\n", "fix": "\nlet rec additivePersistence n = (additivePersistence (n mod 10)) + n;;\n"}
{"hw": "hw1", "index": 1386, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n = n = (additivePersistence (n / 10));;\n", "fix": "\nlet rec additivePersistence n = (additivePersistence (n mod 10)) + n;;\n"}
{"hw": "hw1", "index": 1387, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n n = additivePersistence (n mod 10);;\n", "fix": "\nlet rec additivePersistence n = (additivePersistence (n mod 10)) + n;;\n"}
{"hw": "hw1", "index": 1388, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n = n = (additivePersistence (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 1389, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match digits n with | x::[] -> 0 | _ -> additivePersistence (sumList n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | x::[] -> 0\n  | n -> 1 + (additivePersistence (sumList n));;\n"}
{"hw": "hw1", "index": 1390, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | [] -> 0 | h::t -> digitalRoot (sumList n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n = match digits n with | x::[] -> x;;\n"}
{"hw": "hw1", "index": 1391, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | [] -> 0 | h::t -> digitalRoot (digits (sumList n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n = match digits n with | x::[] -> x;;\n"}
{"hw": "hw1", "index": 1392, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> 0 | h::t -> digitalRoot (digits (sumList n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n = match digits n with | x::[] -> x;;\n"}
{"hw": "hw1", "index": 1393, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> digitalRoot (digits (sumList n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n = match digits n with | x::[] -> x;;\n"}
{"hw": "hw1", "index": 1394, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot t);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (sumList t));;\n"}
{"hw": "hw1", "index": 1395, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (digits t));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (sumList t));;\n"}
{"hw": "hw1", "index": 1396, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match n with | x::[] -> x | h::t -> h + (digitalRoot (digits t));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (sumList t));;\n"}
{"hw": "hw1", "index": 1397, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> t + (digitalRoot (sumList h));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (sumList t));;\n"}
{"hw": "hw1", "index": 1398, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot t);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot (sumList t));;\n"}
{"hw": "hw1", "index": 1399, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match digits n with | x::[] -> x | h::t -> h + (digitalRoot t);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n"}
{"hw": "hw1", "index": 1400, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1401, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: [] :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1402, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1403, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1404, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1405, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ ([] @ (digitsOfInt (n / 10)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1406, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else (digitsOfInt (n mod 10)) @ [];;\n"}
{"hw": "hw1", "index": 1407, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1408, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1409, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | h::t -> listReverse h | [] -> [];;\n", "fix": "\nlet rec listReverse l = match l with | h::t -> listReverse [h] | [] -> [];;\n"}
{"hw": "hw1", "index": 1410, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | h::t -> [h] @ (listReverse [t]);;\n", "fix": "\nlet rec listReverse l = match l with | h::t -> [h] @ (listReverse t);;\n"}
{"hw": "hw2", "index": 1411, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | (0,2) -> buildX ()\n    | (3,5) -> buildY ()\n    | (6,10) -> buildSine (build (rand, (depth - 1)))\n    | (11,18) -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1412, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | (0,2) -> buildX (build (rand, (depth - 1)))\n    | (3,5) -> buildY ()\n    | (6,10) -> buildSine (build (rand, (depth - 1)))\n    | (11,18) -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1413, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | (0,2) -> buildX (build (rand, (depth - 1)))\n    | (3,5) -> buildY ()\n    | (6,10) -> buildSine (build (rand, (depth - 1)))\n    | (11,18) -> buildCosine (build (rand, (depth - 1)))\n  else ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1414, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | (0,2) -> buildX ()\n    | (3,5) -> buildY ()\n    | (6,10) -> buildSine (build (rand, (depth - 1)))\n    | (11,18) -> buildCosine (build (rand, (depth - 1)))\n  else ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1415, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand with\n    | (6,10) -> buildSine (build (rand, (depth - 1)))\n    | (11,18) -> buildCosine (build (rand, (depth - 1)))\n  else ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1416, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1417, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> buildSine (eval (e, x, y))\n  | Cosine e -> buildCosine (eval (e, x, y))\n  | Average (e1,e2) -> buildAverage ((eval e1), (eval e2))\n  | Times (e1,e2) -> buildTimes ((eval e1), e2)\n  | Thresh (e1,e2,e3,e4) ->\n      buildThresh ((eval e1), (eval e2), (eval e3), (eval e4));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1418, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval e))\n  | Cosine e -> buildCosine (eval (e, x, y))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1419, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> buildCosine (eval (e, x, y))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1420, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos * (pi *. (eval e))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1421, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos * (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1422, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos * (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1423, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> buildAverage (x, y)\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1424, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1425, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> buildTimes (x, y)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1426, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> buildThresh (x, y, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1427, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Half of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Neg e -> (-1.0) *. (eval (e, x, y))\n  | Half e -> (eval (e, x, y)) /. 2.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Half of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Neg e -> (-1.0) *. (eval (e, x, y))\n  | Half e -> (eval (e, x, y)) /. 2.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1428, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AveThree of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Neg e -> (-1.0) *. (eval (e, x, y))\n  | AveThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AveThree of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Neg e -> (-1.0) *. (eval (e, x, y))\n  | AveThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1429, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 1430, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 1431, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX s -> printf \"%s\" s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 1432, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Printf.printf \"%s\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 1433, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Printf.printf VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"VarX\";;\n"}
{"hw": "hw2", "index": 1434, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine  -> \"Sine\"\n  | Cosine  -> \"Cosine\"\n  | Average  -> \"Average\"\n  | Times  -> \"Times\"\n  | Thresh  -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1435, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e -> \"Sine\"\n  | Cosine e -> \"Cosine\"\n  | Average e -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1436, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e -> \"Sine\"\n  | Cosine e -> \"Cosine\"\n  | Average (e,e) -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1437, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e -> \"Sine\"\n  | Cosine e -> \"Cosine\"\n  | Average (expr,expr) -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1438, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e -> \"Sine\"\n  | Cosine e -> \"Cosine\"\n  | Average expr -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1439, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"VarY\"\n  | Sine e -> \"Sine\"\n  | Cosine e -> \"Cosine\"\n  | Average expr -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1440, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"Sin (pi*%s)\" % s\n  | Cosine e -> \"Cosine\"\n  | Average expr -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1441, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\"\n  | Average expr -> \"Average\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1442, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average e -> \"(%s*%s)/2\" % e\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1443, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average e -> \"(%s*%s)/2\" % (e e)\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1444, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average e -> \"(%s + %s)/2\" e e\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1445, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average  -> \"(%s + %s)/2\" e p\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1446, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average e -> \"(%s + %s)/2\" e p\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1447, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average e -> \"(%s + %s)/2\" e\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1448, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average (e,ex) -> \"(\" exprToString e \"+\" exprToString ex \")/2\"\n  | Times e -> \"Times\"\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1449, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average (e,ex) -> \"((\" exprToString e \"+\" exprToString ex \")/2)\"\n  | Times (e,ex) -> exprToString e \"*\" exprToString ex\n  | Thresh e -> \"Thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1450, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*%s)\" e\n  | Cosine e -> \"cos (pi*%s)\" e\n  | Average (e,ex) -> \"((\" exprToString e \"+\" exprToString ex \")/2)\"\n  | Times (e,ex) -> exprToString e \"*\" exprToString ex\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" exprToString e1 \"<\" exprToString e2 \"?\" exprToString e3 \":\"\n        exprToString e4 \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1451, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" exprToString e \")\"\n  | Cosine e -> \"cos (pi*\" exprToString e \")\"\n  | Average (e,ex) -> \"((\" exprToString e \"+\" exprToString ex \")/2)\"\n  | Times (e,ex) -> exprToString e \"*\" exprToString ex\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" exprToString e1 \"<\" exprToString e2 \"?\" exprToString e3 \":\"\n        exprToString e4 \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1452, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" exprToString e \")\"\n  | Cosine e -> \"cos (pi*\" exprToString e \")\"\n  | Average (e,ex) -> \"((\" exprToString e \"+\" exprToString ex \")/2)\"\n  | Times (e,ex) -> exprToString e \"*\" exprToString ex\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" exprToString e1 \"<\" exprToString e2 \"?\" exprToString e3 \":\"\n        exprToString e4 \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1453, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" exprToString e \")\"\n  | Average (e,ex) -> \"((\" exprToString e \"+\" exprToString ex \")/2)\"\n  | Times (e,ex) -> exprToString e \"*\" exprToString ex\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" exprToString e1 \"<\" exprToString e2 \"?\" exprToString e3 \":\"\n        exprToString e4 \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1454, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Half of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Half e -> (exprToString e) ^ \"/2\"\n  | Neg e -> \"-\" ^ (exprToString e)\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Half of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Half e -> (exprToString e) ^ \"/2\"\n  | Neg e -> \"-\" ^ (exprToString e)\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1455, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AddMul of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Neg e -> (exprToString e) ^ \" * -1.0\"\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | AveThree (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ (exprToString e3 \")/3\")))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AveThree of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Neg e -> (exprToString e) ^ \" * -1.0\"\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | AveThree (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/3\")))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1456, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AddMul of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Neg e -> (exprToString e) ^ \" * -1.0\"\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | AveThree (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/3\")))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Neg of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | AveThree of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Neg e -> (exprToString e) ^ \" * -1.0\"\n  | Average (e,ex) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString ex) ^ \")/2)\")))\n  | Times (e,ex) -> (exprToString e) ^ (\"*\" ^ (exprToString ex))\n  | AveThree (e1,e2,e3) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")/3\")))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1457, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1458, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (((wwhile (f, b)), b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1459, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile (if (wwhile (f, b)) = b then b else ((wwhile (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1460, "problem": "fixpoint", "bad": "\nlet rec fix t x = if x = (t x) then x else t x;;\n\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile ((fix b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1461, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if f = b then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1462, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if true then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1463, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = true then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1464, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = true then b else ((f f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1465, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = true then b else (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1466, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if f = true then b else (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1467, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if f = true then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1468, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if f = true then b else ((wwhile (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1469, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile (if f = true then b else ((wwhile ((f b), b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1470, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile (match f b with | false  -> wwhile (f, b) | b -> (b, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1471, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1472, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else (b, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1473, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else (false, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1474, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then true else (false, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,t) -> if t = true then wwhile (f, h) else h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let t = f b in if b = t then (b, false) else (t, true) in g),\n      b);;\n"}
{"hw": "hw2", "index": 1475, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = List.mem seen h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1476, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1477, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1478, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1479, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else [h] @ [seen] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 1480, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] ->\n          (match x with\n           | (x1,x2) when (x1 + x2) <= 9 -> 0 :: (x1 + x2) :: a\n           | (x1,x2) when (x1 + x2) > 9 -> 1 :: ((x1 + x2) - 9) :: a)\n      | h::t ->\n          (match x with\n           | (x1,x2) when ((x1 + x2) + h) <= 9 -> 0 :: ((x1 + x2) + h) :: t\n           | (x1,x2) when ((x1 + x2) + h) > 9 -> 1 :: (((x1 + x2) + h) - 9)\n               :: t) in\n    let base = [] in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1481, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] ->\n          (match x with\n           | (x1,x2) when (x1 + x2) <= 9 -> 0 :: (x1 + x2) :: a\n           | (x1,x2) when (x1 + x2) > 9 -> 1 :: ((x1 + x2) - 9) :: a)\n      | h::t ->\n          (match x with\n           | (x1,x2) when ((x1 + x2) + h) <= 9 -> 0 :: ((x1 + x2) + h) :: t\n           | (x1,x2) when ((x1 + x2) + h) > 9 -> 1 :: (((x1 + x2) + h) - 9)\n               :: t) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1482, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] ->\n          (match x with\n           | (x1,x2) when (x1 + x2) <= 9 -> (0, (x1 + x2)) :: a\n           | (x1,x2) when (x1 + x2) > 9 -> (1, ((x1 + x2) - 9)) :: a)\n      | (h1::t1,y) ->\n          (match x with\n           | (x1,x2) when ((x1 + x2) + h1) <= 9 -> (0, ((x1 + x2) + h1)) :: y\n           | (x1,x2) when ((x1 + x2) + h1) > 9 -> (1, (((x1 + x2) + h) - 9))\n               :: y) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1483, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] ->\n          (match x with\n           | (x1,x2) when (x1 + x2) <= 9 -> (0, (x1 + x2)) :: a\n           | (x1,x2) when (x1 + x2) > 9 -> (1, ((x1 + x2) - 9)) :: a)\n      | (h1::t1,h2::t2) ->\n          (match x with\n           | (x1,x2) when ((x1 + x2) + h1) <= 9 -> (0, ((x1 + x2) + h1)) ::\n               h2 :: t2\n           | (x1,x2) when ((x1 + x2) + h1) > 9 -> (1, (((x1 + x2) + h1) - 9))\n               :: h2 :: t2) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1484, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] ->\n          (match x with\n           | (x1,x2) when (x1 + x2) <= 9 -> (0, (x1 + x2)) :: a\n           | (x1,x2) when (x1 + x2) > 9 -> (1, ((x1 + x2) - 9)) :: a)\n      | (z,y)::t ->\n          (match x with\n           | (x1,x2) when ((x1 + x2) + z) <= 9 -> (0, ((x1 + x2) + z)) :: a\n           | (x1,x2) when ((x1 + x2) + z) > 9 -> (1, (((x1 + x2) + z) - 9))\n               :: a) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1485, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1486, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1487, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (sum / 10) :: (sum mod 10) :: a\n      | h::t -> (sum / 10) :: (h + (sum mod 10)) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | (0,[]) -> ((b / 10), [b mod 10])\n      | (y,h::t) -> ((b / 10), ((b mod 10) :: (h + y) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1488, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (0, ((sum / 10) :: (sum mod 10) :: a))\n      | (h1,h)::t -> (0, ((sum / 10) :: (h + (sum mod 10)) :: t)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | (0,[]) -> ((b / 10), [b mod 10])\n      | (y,h::t) -> ((b / 10), ((b mod 10) :: (h + y) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1489, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (0, ((sum / 10) :: (0, (sum mod 10)) :: a))\n      | (h1,h)::t -> (0, (sum / 10)) :: (0, (h + (sum mod 10))) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | (0,[]) -> ((b / 10), [b mod 10])\n      | (y,h::t) -> ((b / 10), ((b mod 10) :: (h + y) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1490, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | [] -> (0, (sum / 10)) :: (0, (sum mod 10)) :: a\n      | (h1,h)::t -> (0, (sum / 10)) :: (0, (h + (sum mod 10))) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | (0,[]) -> ((b / 10), [b mod 10])\n      | (y,h::t) -> ((b / 10), ((b mod 10) :: (h + y) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1491, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)) l2)));;\n", "fix": "\nlet rec clone x n =\n  match n with | y when y <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) <= (List.length l2) with\n  | true  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  | false  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n"}
{"hw": "hw3", "index": 1492, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  let diff = leng1 - leng2 in\n  if diff != 0\n  then\n    let zeros = clone 0 (abs diff) in\n    (if diff < 0 then ((zeros @ l1), l2) else (l1, (zeros @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (cin,ls) ->\n          (match x with\n           | (a,b) ->\n               let di = (cin + a) + b in ((di / 10), ((di mod 10) :: ls))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (co,res) = List.fold_left f base args in co :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (l = [])\n  then []\n  else\n    (let rec helper i acc l = helper (i - 1) (bigAdd acc l) l in helper i []);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  let diff = leng1 - leng2 in\n  if diff != 0\n  then\n    let zeros = clone 0 (abs diff) in\n    (if diff < 0 then ((zeros @ l1), l2) else (l1, (zeros @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (cin,ls) ->\n          (match x with\n           | (a,b) ->\n               let di = (cin + a) + b in ((di / 10), ((di mod 10) :: ls))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (co,res) = List.fold_left f base args in co :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (l = [])\n  then []\n  else\n    (let rec helper i acc l = helper (i - 1) (bigAdd acc l) l in\n     helper i [] l);;\n"}
{"hw": "hw3", "index": 1493, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  let diff = leng1 - leng2 in\n  if diff != 0\n  then\n    let zeros = clone 0 abs diff in\n    (if diff < 0\n     then List.combine (zeros @ l1) l2\n     else List.combine l1 (zero @ l2))\n  else List.combine l1 l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  let diff = leng1 - leng2 in\n  if diff != 0\n  then\n    let zeros = clone 0 (abs diff) in\n    (if diff < 0 then ((zeros @ l1), l2) else (l1, (zeros @ l2)))\n  else (l1, l2);;\n"}
{"hw": "hw3", "index": 1494, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1495, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1496, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1497, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1498, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 1499, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 7) with\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | 3 -> buildSine (build (rand, (depth - 1)))\n    | 4 -> buildCosine (build (rand, (depth - 1)))\n    | 5 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ());;\n"}
{"hw": "hw2", "index": 1500, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 7) with\n    | 1 -> VarX\n    | 2 -> VarY\n    | 3 -> buildSine (build (rand, (depth - 1)))\n    | 4 -> buildCosine (build (rand, (depth - 1)))\n    | 5 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ());;\n"}
{"hw": "hw2", "index": 1501, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else (match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ());;\n"}
{"hw": "hw2", "index": 1502, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | _ -> buildSine buildX\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else\n    (match rand (1, 2) with\n     | _ -> buildY ()\n     | 1 -> buildX ()\n     | 2 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (1, 5) with\n    | _ -> buildSine (buildX ())\n    | 1 -> buildSine (build (rand, (depth - 1)))\n    | 2 -> buildCosine (build (rand, (depth - 1)))\n    | 3 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else\n    (match rand (1, 2) with\n     | _ -> buildY ()\n     | 1 -> buildX ()\n     | 2 -> buildY ());;\n"}
{"hw": "hw2", "index": 1503, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval e'))\n  | Cosine e' -> cos (pi * (eval e'))\n  | Average (e1,e2) -> ((eval e1) + (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) * (eval e2)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1504, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) + (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) * (eval e2)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1505, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1506, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1507, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> (e1 +. e2) /. 2.0\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1508, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> int_to_string x | VarY y -> int_to_string y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ (exprToString e')\n  | Cosine e' -> \"cos(pi*\" ^ (exprToString e')\n  | Average (e',e'') ->\n      \"((\" ^ ((exprToString e') ^ (\"+\" ^ ((exprToString e'') ^ \")/2)\")))\n  | Times (e',e'') -> (exprToString e') ^ (\"*\" ^ (exprToString e''))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4)))))));;\n"}
{"hw": "hw2", "index": 1509, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1510, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((f, (b, (if (f b) == b then b else f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1511, "problem": "fixpoint", "bad": "\nlet f' f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((f' f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1512, "problem": "fixpoint", "bad": "\nlet f' (f,b) = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((f' (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1513, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((let f' b = (f b) = b in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1514, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1515, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = if (f b) = b then b else f b in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1516, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b' = if (f b) = b then b else f b in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1517, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b' = if (f b') = b then b else f b' in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1518, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = if (f b) = b then b else f b in f' f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1519, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((let f' f b = (f b) = b in f'), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1520, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) = wwhile ((let f' b = (f b) = b in f'), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, true) else ((f b), false) in f'), b);;\n"}
{"hw": "hw2", "index": 1521, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, false) else ((f b), true) in f' b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f' b = if (f b) = b then (b, false) else ((f b), true) in f'), b);;\n"}
{"hw": "hw2", "index": 1522, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f,(h1,h2)) -> if h2 then f h1 else wwhile (h1, h2);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1523, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f,(h1,h2)) -> if h2 then wwhile f h1 else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1524, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f,(h1,h2)) -> if h2 then wwhile (f, h1) else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1525, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (f,(h1,h2)) -> if h2 then wwhile (f, (h1, h2)) else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1526, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (f,(h1,h2)) -> if h2 then wwhile (f, h1) else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1527, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw2", "index": 1528, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (f,(h1,h2)) -> if h2 then wwhile (f, h1) else h1;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h1,h2) -> if h2 then wwhile (f, h1) else h1;;\n"}
{"hw": "hw1", "index": 1529, "problem": "additivePersistence", "bad": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else (digitsOfIntHelper ((n - (n mod 10)) / 10)) @ [n mod 10];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec additivePersistence n = if n >= 10 then sumList (digitsOfInt n);;\n", "fix": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else (digitsOfIntHelper ((n - (n mod 10)) / 10)) @ [n mod 10];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec aPHelper n = if n >= 10 then sumList (digitsOfInt n) else n;;\n\nlet rec additivePersistence n = aPHelper n;;\n"}
{"hw": "hw1", "index": 1530, "problem": "additivePersistence", "bad": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec additivePersistence n = sumList digitsOfInt n;;\n", "fix": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1531, "problem": "additivePersistence", "bad": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec additivePersistence n = if n > 10 then sumList (digitsOfInt n);;\n", "fix": "\nlet rec sumListHelper total xs =\n  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;\n\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n\nlet rec sumList xs = sumListHelper 0 xs;;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1532, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper (n > 10);;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n"}
{"hw": "hw1", "index": 1533, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper [n > 10];;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n"}
{"hw": "hw1", "index": 1534, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper (n >= 10);;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n"}
{"hw": "hw1", "index": 1535, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper (n > 10);;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n"}
{"hw": "hw1", "index": 1536, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper [n > 10];;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n < 1\n  then []\n  else [n mod 10] @ (digitsOfIntHelper (n - ((n mod 10) / 10)));;\n\nlet rec digitsOfInt n = digitsOfIntHelper n;;\n"}
{"hw": "hw1", "index": 1537, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tail -> (listReverse tail) :: hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tail -> (listReverse tail) @ [hd];;\n"}
{"hw": "hw1", "index": 1538, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tail -> (listReverse tail) :: hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tail -> (listReverse tail) @ [hd];;\n"}
{"hw": "hw1", "index": 1539, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tail -> (listReverse tail) @ hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tail -> (listReverse tail) @ [hd];;\n"}
{"hw": "hw1", "index": 1540, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | (h::tail)::[] -> listReverse tail;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::tail -> (listReverse tail) @ [h];;\n"}
{"hw": "hw1", "index": 1541, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tail -> (listReverse tail) @ [h];;\n\nlet palindrome w = explode (listReverse w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tail -> (listReverse tail) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 1542, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tail -> (listReverse tail) @ [h];;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tail -> (listReverse tail) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw3", "index": 1543, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then clone l1 ((List.length l2) - (List.length l1))\n  else clone l2 ((List.length l1) - (List.length l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1544, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1545, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1546, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1547, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | h::t -> if h = 0 then removeZero t else l | _ -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + sum) / 10) :: ((h + sum) mod 10) :: t\n      | _ -> [sum / 10; sum mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1548, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((clone 0 ((List.length l2) - (List.length l1))) @ l1) l2\n  else\n    if (List.length l1) > (List.length l2)\n    then l1 ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n    else l1 l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1549, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1550, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1551, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1552, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 1553, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec recCounter n count =\n    if n < 10\n    then count\n    else recCounter ((sumList (digitsOfInt n)) (count + 1)) in\n  recCounter n 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let rec recCounter n count =\n    if n < 10\n    then count\n    else (recCounter (sumList (digitsOfInt n)) count) + 1 in\n  recCounter n 0;;\n"}
{"hw": "hw1", "index": 1554, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else ((digitsOfInt n) / 10) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1555, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1556, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = (explode w) = w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 1557, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (explode w) = (listReverse w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 1558, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (explode w) = (listReverse explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 1559, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ ((digitofInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1560, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1561, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1562, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1563, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else (digitsOfInt n) / 10;;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1564, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1565, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 1566, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else (digitsOfInt n) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1567, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) mod 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else (digitsOfInt n) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1568, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse l) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse l) @ [h];;\n"}
{"hw": "hw1", "index": 1569, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 1570, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | [] -> [] | h::t -> [h; digitsOfInt t]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1571, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | h::t -> [h; digitsOfInt t]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1572, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [(digitsOfInt n) / 10] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1573, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else ((digitsOfInt n) / 10) @ ([] @ [n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1574, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1575, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [] @ (([n mod 10] digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1576, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [[]; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1577, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [(digitsOfInt n) / 10] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1578, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1579, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ([] @ [n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [] @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1580, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1581, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1582, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let m = n in if n < 0 then [] else [digitsOfInt (m / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1583, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let m = n in if n < 0 then [] else [[digitsOfInt (m / 10)]; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1584, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let m = n in if n < 0 then [] else [(digitsOfInt m) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1585, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let m = n in if n < 0 then [] else [digitsOfInt (n / 10); m mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1586, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); m mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1587, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [((digitsOfInt n) / 10) :: (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1588, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1589, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [(digitsOfInt (n / 10)) @ (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1590, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else ([] :: (digitsOfInt (n / 10))) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1591, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1592, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1593, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n mod 10) > 0 then [n mod 10] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1594, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1595, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1596, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw2", "index": 1597, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval e1))\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1598, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1599, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1 x y))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1600, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1601, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) / 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1602, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1603, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1604, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Sqrt of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ExtremeExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sqrt e1 -> sqrt (abs (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | ExtremeExp (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Sqrt of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ExtremeExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet abs x = if x > 0.0 then x else -. x;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sqrt e1 -> sqrt (abs (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | ExtremeExp (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1605, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let x = f b in match x with | b -> (x, false) | _ -> ((x, true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1606, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let x = f b in match x with | b -> (x, false) | _ -> (x, true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1607, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let y = f b in match y with | b -> (y, false) | _ -> (y, true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1608, "problem": "fixpoint", "bad": "\nlet fpHelper (f,x,y) =\n  let n = f x in match n with | y -> (n, y, false) | _ -> (n, y, false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fpHelper (f, b, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1609, "problem": "fixpoint", "bad": "\nlet fpHelper (f,x,y) =\n  let n = f x in match n with | y -> (n, false) | _ -> (n, false);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fpHelper (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1610, "problem": "fixpoint", "bad": "\nlet helper (f,a,y) = let x = f a in if x = y then (x, false) else (x, true);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (helper, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1611, "problem": "fixpoint", "bad": "\nlet helper (f,a) = let x = f a in if x = a then (x, false) else (x, true);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (helper, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1612, "problem": "fixpoint", "bad": "\nlet helper (f,a,y) =\n  let x = f a in if x = y then ((f, x, y), false) else ((f, x, y), true);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in\n  match c' with | false  -> (b', c') | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let y = f x in if y = x then (y, false) else (y, true) in\n      helper), b);;\n"}
{"hw": "hw2", "index": 1613, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 1614, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (y,z) = x in (y + z) @ a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1615, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (y,z) = x in [y + z] @ a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1616, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (y,z) = x in [y +. z] @ a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1617, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in ([y + z] @ a) / 10))\n      else (0, ((let (y,z) = x in [y + z] @ a))) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1618, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in [(y + z) / 10] @ a))\n      else (0, ((let (y,z) = x in [y + z] @ a))) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1619, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in [(y + z) / 10] @ a))\n      else (0, ((let (y,z) = x in [y + z] @ a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1620, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then let (y,z) = x in [(y + z) / 10] @ a\n      else (let (y,z) = x in [y + z] @ a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1621, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then let (y,z) = x in [(y + z) / 10] @ a\n      else (let (y,z) = x in [y + z] @ a) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1622, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in [(y + z) mod 10] @ a))\n      else (0, ((let (y,z) = x in [y + z] @ a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1623, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in [(y + z) mod 10])) @ a\n      else (0, (let (y,z) = x in [y + z])) @ a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1624, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then [(1, ((let (y,z) = x in (y + z) mod 10)))] @ a\n      else (0, (let (y,z) = x in [y + z])) @ a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1625, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then [(1, ((let (y,z) = x in (y + z) mod 10)))] @ a\n      else [(0, ((let (y,z) = x in y + z)))] @ a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1626, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then [(1, ((let (y,z) = x in (y + z) mod 10)))] @ a\n      else [(0, ((let (y,z) = x in y + z)))] @ a in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1627, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then [(1, ((let (y,z) = x in (y + z) mod 10)))] @ a\n      else [(0, ((let (y,z) = x in y + z)))] @ a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1628, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (y,z) = x in (y + z) > 9\n      then (1, (let (y,z) = x in (y + z) mod 10)) + a\n      else (0, (let (y,z) = x in y + z)) + a in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1629, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in (0, (let (y,z) = x in [(y + z) + carry] @ a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1630, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        clone 1 (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 10\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        if (let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) = 10)\n        then (let (carry,ans) = a in (1, ([9] @ ans)))\n        else\n          (let (carry,ans) = a in\n           (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1631, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 9\n      then\n        let (carry,ans) = a in\n        clone (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans)) 2\n      else\n        (let (carry,ans) = a in\n         (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 10\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        if (let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) = 10)\n        then (let (carry,ans) = a in (1, ([9] @ ans)))\n        else\n          (let (carry,ans) = a in\n           (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1632, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 10\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        if (let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) = 10)\n        then (1, 9)\n        else\n          (let (carry,ans) = a in\n           (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) > 10\n      then\n        let (carry,ans) = a in\n        (1, (let (y,z) = x in [((y + z) + carry) mod 10] @ ans))\n      else\n        if (let (carry,ans) = a in let (y,z) = x in ((y + z) + carry) = 10)\n        then (let (carry,ans) = a in (1, ([9] @ ans)))\n        else\n          (let (carry,ans) = a in\n           (0, (let (y,z) = x in [(y + z) + carry] @ ans))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1633, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else (match l with | [] -> [] | h::t -> [h * i] @ (mulByDigit t));;\n", "fix": "\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else (match l with | [] -> [] | h::t -> [h * i] @ (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 1634, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ [l2]));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 1635, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = x (a z) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1636, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x x = (x * x) + a in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1637, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1638, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \"; \" l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1639, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (sepConcat \"; \" l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1640, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat \"; \" l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1641, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 1642, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec additivePersistence n = if n >= 10 then digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet myHelper n = let n = digitsOfInt n in sumList n;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else (let x = myHelper n in 1 + (additivePersistence x));;\n"}
{"hw": "hw1", "index": 1643, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if n >= 10 then sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet myHelper n = let n = digitsOfInt n in sumList n;;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else (let x = myHelper n in 1 + (additivePersistence x));;\n"}
{"hw": "hw1", "index": 1644, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n >= 10\n  then let n = digitsOfInt n\n       and f = sumList n in digitalRoot n\n  else n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let x = n mod 10\n        and n = n / 10 in (digitsOfInt n) @ [x]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec helper n = let n = digitsOfInt n in sumList n;;\n\nlet rec digitalRoot n = if n < 10 then n else helper n;;\n"}
{"hw": "hw1", "index": 1645, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = n mod 10 in (digitsOfInt n) :: x);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = n mod 10 in (digitsOfInt n) @ [x]);;\n"}
{"hw": "hw1", "index": 1646, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then let x = n mod 10 in (digitsOfInt n) :: x else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = n mod 10 in (digitsOfInt n) @ [x]);;\n"}
{"hw": "hw1", "index": 1647, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = n mod 10 in (digitsOfInt n) @ x);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (let x = n mod 10 in (digitsOfInt n) @ [x]);;\n"}
{"hw": "hw1", "index": 1648, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then 0\n    else (let x = n mod 10\n          and r = n / 10 in (digitsOfInt r) @ [x]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then []\n    else (let x = n mod 10\n          and r = n / 10 in (digitsOfInt r) @ [x]);;\n"}
{"hw": "hw1", "index": 1649, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> 0 | h::t -> h @ [];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 1650, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> 0 | h::t -> [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 1651, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> 0 | h::t -> (listReverse t) @ [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 1652, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (Array.length xs) > 0 then (List.hd xs) + (sumList xs);;\n", "fix": "\nlet rec sumList xs = if xs = [] then 0 else (List.hd xs) + (sumList xs);;\n"}
{"hw": "hw1", "index": 1653, "problem": "sumList", "bad": "\nlet rec sumList xs = if (List.length xs) > 0 then (List.hd xs) + (sumList xs);;\n", "fix": "\nlet rec sumList xs = if xs = [] then 0 else (List.hd xs) + (sumList xs);;\n"}
{"hw": "hw1", "index": 1654, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if xs = [] then 0 else (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n"}
{"hw": "hw1", "index": 1655, "problem": "sumList", "bad": "\nlet rec sumList xs = if xs = [] then 0 else (List.hd xs) + (sumList tl xs);;\n", "fix": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n"}
{"hw": "hw1", "index": 1656, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 1657, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | h::t -> let h::t = xs in h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw2", "index": 1658, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | (h1,h2)::t -> if k = h2 then h1 else (h1, h2) :: (assoc (d, k, t))\n  | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  let (h1,h2)::t = l in\n  match k with | h2 -> h1 | _ -> if l = [] then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1659, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | h::t ->\n      let (h1,h2) = h in if k = h2 then h1 else (h1, h2) :: (assoc (d, k, t))\n  | _ -> d;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  let (h1,h2)::t = l in\n  match k with | h2 -> h1 | _ -> if l = [] then d else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1660, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (buildX ()) || (buildY ())\n  | _ ->\n      (buildSine (build (rand, (depth - 1)))) ||\n        ((buildCosine (build (rand, (depth - 1)))) ||\n           (buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1661, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if ((rand ()) mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      (match rand with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1662, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1663, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1664, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1665, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1 *. x\n  | VarY  -> 1 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1666, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1667, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> float (((eval (e1, x, y)) +. (eval (e2, x, y))) / 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1668, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1669, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) ->\n      ((1.0 *. (eval (e1, x, y))) +. (eval (e2, x, y))) / 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1670, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0 *. x\n  | VarY  -> 1.0 *. y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1671, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Ceiling of expr\n  | LT of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Ceiling e' -> ceil e'\n  | LT (a,b,c) ->\n      if ((eval (a, x, y)) +. (eval (b, x, y))) < (eval (c, x, y))\n      then (eval (a, x, y)) +. (eval (b, x, y))\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Ceiling of expr\n  | LT of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Ceiling e' -> ceil (eval (e', x, y))\n  | LT (a,b,c) ->\n      if ((eval (a, x, y)) +. (eval (b, x, y))) < (eval (c, x, y))\n      then (eval (a, x, y)) +. (eval (b, x, y))\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 1672, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Ceiling of expr\n  | LT of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Ceiling e' -> ceil (eval e')\n  | LT (a,b,c) ->\n      if ((eval (a, x, y)) +. (eval (b, x, y))) < (eval (c, x, y))\n      then (eval (a, x, y)) +. (eval (b, x, y))\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Ceiling of expr\n  | LT of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Ceiling e' -> ceil (eval (e', x, y))\n  | LT (a,b,c) ->\n      if ((eval (a, x, y)) +. (eval (b, x, y))) < (eval (c, x, y))\n      then (eval (a, x, y)) +. (eval (b, x, y))\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 1673, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average  -> (e' + e') / 2\n  | Times  -> e' * e'\n  | Thresh  -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1674, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average  -> e' + e'\n  | Times  -> e' * e'\n  | Thresh  -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1675, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average  -> (e' + (exprToString e')) / 2\n  | Times  -> e' * e'\n  | Thresh  -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1676, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average e' -> (e' + e') / 2\n  | Times e' -> e' * e'\n  | Thresh e' -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1677, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average (e',e') -> (e' + e') / 2\n  | Times e' -> e' * e'\n  | Thresh e' -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1678, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times e' -> e' * e'\n  | Thresh e' -> (e' < (e' ?e) : e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1679, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (pi * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1680, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (3.142 * e')\n  | Cosine e' -> cos (3.142 * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1681, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (3.142 *. e')\n  | Cosine e' -> cos (3.142 *. e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1682, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (3.142 * a)\n  | Cosine e' -> cos (3.142 * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1683, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (3.142 *. e')\n  | Cosine e' -> cos (3.142 * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1684, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi *. e')\n  | Cosine e' -> cos (3.142 * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1685, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> e\n  | Sine e' -> sin (pi * e')\n  | Cosine e' -> cos (3.142 * e')\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1686, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (pi * (exprToString e'))\n  | Cosine e' -> cos (3.142 * (exprToString e'))\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1687, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 * (exprToString e'))\n  | Cosine e' -> cos (3.142 * (exprToString e'))\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1688, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 *. (exprToString e'))\n  | Cosine e' -> cos (3.142 * (exprToString e'))\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1689, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 *. (exprToString e'))\n  | Cosine e' -> cos (3.142 *. (exprToString e'))\n  | Average (a,b) -> (a + b) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1690, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 *. (exprToString e'))\n  | Cosine e' -> cos (3.142 *. (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1691, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 * (exprToString e'))\n  | Cosine e' -> cos (3.142 * (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1692, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3 * (exprToString e'))\n  | Cosine e' -> cos (3.142 * (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> a * b\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1693, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e' -> sin (3.142 *. (exprToString e'))\n  | Cosine e' -> cos (3.142 *. (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> (exprToString a) * (exprToString b)\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1694, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" ^ e\n  | VarY  -> \"\" ^ e\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> cos (3.142 *. (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> (exprToString a) * (exprToString b)\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1695, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> cos (3.142 *. (exprToString e'))\n  | Average (a,b) -> ((exprToString a) + (exprToString b)) / 2\n  | Times (a,b) -> (exprToString a) * (exprToString b)\n  | Thresh (a,b,c,d) -> (a < (b ?c) : d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1696, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^ (a ^ (\"< \" ^ (b ^ (\" ? \" ^ (c ^ (\" : \" ^ (d ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi * \" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi * \" ^ ((exprToString e') ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\" + \" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\" * \" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"< \" ^\n              ((exprToString b) ^\n                 (\" ? \" ^\n                    ((exprToString c) ^ (\" : \" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1697, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1698, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1699, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((match f b with | b -> b | _ -> wwhile (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1700, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((match f b with | b -> b | _ -> (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1701, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1702, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let inc f' = f (f b) in inc f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1703, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1704, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), (b = (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1705, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), (b == (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1706, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let f' (f,b) = ((f b), (b == (f b))) in ((f' (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1707, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let f' (f,b) = ((f b), (b = (f b))) in ((f' (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1708, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let f' b = ((f b), (b = (f b))) in ((f' (f, b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), (b = (f b))) in f'), b);;\n"}
{"hw": "hw2", "index": 1709, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1710, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1711, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  if not f b then b else (let (b',c) = f b in wwhile (f, b'));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 1712, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  if not (f b) then b else (let (b',c) = f b in wwhile (f, b'));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c) = f b in if not c then b' else wwhile (f, b');;\n"}
{"hw": "hw1", "index": 1713, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1714, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10] @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1715, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt (n / 10)] @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1716, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt (n / 10)] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1717, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt (n / 10)] :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1718, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1719, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1720, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [[digitsOfInt (n / 10)]; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1721, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1722, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1723, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw2", "index": 1724, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> VarX | 1 -> VarY)\n  | n ->\n      (match rand (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1725, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = ((eval (a, x, y)), (x2 = (eval (b, x, y)))) in\n      if x1 < x2 then eval a_less else eval b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1726, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = ((eval (a, x, y)), (x2 = (eval (b, x, y)))) in\n      if x1 < x2 then eval a_less else eval b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1727, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else ((eval b_less), x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1728, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then ((eval a_less), x, y) else ((eval b_less), x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) *. 0.5\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1729, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1730, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) /. (eval (b, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      let x1 = eval (a, x, y) in\n      let x2 = eval (b, x, y) in\n      if x1 < x2 then eval (a_less, x, y) else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1731, "problem": "fixpoint", "bad": "\nlet helper f b = if (f b) = b then true else false;;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper (f, b)), b);;\n", "fix": "\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n"}
{"hw": "hw2", "index": 1732, "problem": "fixpoint", "bad": "\nlet helper f b = if (f b) = b then true else false;;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f b), b);;\n", "fix": "\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n"}
{"hw": "hw2", "index": 1733, "problem": "fixpoint", "bad": "\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f b), b);;\n", "fix": "\nlet helper f b = if (f b) = b then (true, b) else (false, (f b));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((helper f), b);;\n"}
{"hw": "hw2", "index": 1734, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then false else true in wwhile ((f1 f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f1 f2 x = if (f2 x) = x then (false, x) else (true, (f2 x)) in\n  wwhile ((f1 f), b);;\n"}
{"hw": "hw2", "index": 1735, "problem": "removeDuplicates", "bad": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter (t h)) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1736, "problem": "removeDuplicates", "bad": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if a = h then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = h :: (filter t h) in helper (seen', rest') in\n  removeDuplicates (helper []);;\n", "fix": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1737, "problem": "removeDuplicates", "bad": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen @ h in\n        let rest' = filter (t, h) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet rec filter l a =\n  match l with\n  | [] -> []\n  | h::t -> if h = a then filter t a else h :: (filter t a);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        let rest' = filter t h in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1738, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then wwhile (f b') else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1739, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1740, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1741, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1742, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1743, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::l' -> (match h with | (a,b) -> if a = k then b assoc (d, k, l'));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::l' -> (match h with | (a,b) -> if a = k then b else assoc (d, k, l'));;\n"}
{"hw": "hw2", "index": 1744, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand 0 1) = 0 then buildX () else buildY ())\n  else\n    (let x = rand 0 6 in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> []);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (let x = rand (0, 6) in\n     match x with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1745, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1746, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1747, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Boring of expr* expr\n  | SumTan of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Boring (e1,e2) -> 3 *. ((eval (e1, x, y)) +. (4 *. (eval (e2, x, y))))\n  | SumTan (e1,e2,e3) ->\n      ((tan (eval (e1, x, y))) +. (tan (eval (e2, x, y)))) +.\n        (tan (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Boring of expr* expr\n  | SumTan of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Boring (e1,e2) -> 3. *. ((eval (e1, x, y)) +. (4. *. (eval (e2, x, y))))\n  | SumTan (e1,e2,e3) ->\n      ((tan (eval (e1, x, y))) +. (tan (eval (e2, x, y)))) +.\n        (tan (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 1748, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | [] -> []\n  | h::e' ->\n      (match h with\n       | VarX  -> \"x\" ^ (exprToString e')\n       | VarY  -> \"y\" ^ (exprToString e')\n       | Sine  -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n       | Cosine  -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n       | Average  ->\n           let (e1,e2) = h in\n           \"((\" ^\n             ((exprToString e1) ^\n                (\"+\" ^ ((exprToString e2) ^ (\")/2)\" ^ (exprToString e')))))\n       | Times  ->\n           let (e1,e2) = h in\n           (exprToString e1) ^\n             (\"*\" ^ ((exprToString e2) ^ (exprToString e')))\n       | Thresh  ->\n           let (e1,e2,e3,e4) = h in\n           \"(\" ^\n             ((exprToString e1) ^\n                (\"<\" ^\n                   ((exprToString e2) ^\n                      (\"?\" ^\n                         ((exprToString e3) ^\n                            (\":\" ^\n                               ((exprToString e4) ^ (\")\" ^ (exprToString e'))))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1749, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | [] -> []\n  | h::e' ->\n      (match h with\n       | VarX  -> \"x\" ^ (exprToString e')\n       | VarY  -> \"y\" ^ (exprToString e')\n       | Sine e1 ->\n           \"sin(pi*\" ^ ((exprToString e1) ^ (\")\" ^ (exprToString e')))\n       | Cosine e1 ->\n           \"cos(pi*\" ^ ((exprToString e1) ^ (\")\" ^ (exprToString e')))\n       | Average (e1,e2) ->\n           \"((\" ^\n             ((exprToString e1) ^\n                (\"+\" ^ ((exprToString e2) ^ (\")/2)\" ^ (exprToString e')))))\n       | Times (e1,e2) ->\n           (exprToString e1) ^\n             (\"*\" ^ ((exprToString e2) ^ (exprToString e')))\n       | Thresh (e1,e2,e3,e4) ->\n           \"(\" ^\n             ((exprToString e1) ^\n                (\"<\" ^\n                   ((exprToString e2) ^\n                      (\"?\" ^\n                         ((exprToString e3) ^\n                            (\":\" ^\n                               ((exprToString e4) ^ (\")\" ^ (exprToString e'))))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1750, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Harmonic of expr* expr\n  | Log of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Harmonic (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^\n              ((exprToString e2) ^\n                 (\")/(\" ^ ((exprToString e1) ^ (\"+\" ^ (exprToString e2 \")\")))))))\n  | Log (e1,e2,e3) ->\n      \"(log(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^\n              ((exprToString e2 \")/\") ^ (\"log(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Harmonic of expr* expr\n  | Log of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Harmonic (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^\n              ((exprToString e2) ^\n                 (\")/(\" ^\n                    ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")\")))))))\n  | Log (e1,e2,e3) ->\n      \"(log(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^\n              ((exprToString e2) ^\n                 (\")/\" ^ (\"log(\" ^ ((exprToString e3) ^ \"))\"))))));;\n"}
{"hw": "hw2", "index": 1751, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Harmonic of expr* expr\n  | Log of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Harmonic (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^\n              ((exprToString e2) ^\n                 (\")/(\" ^\n                    ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")\")))))))\n  | Log (e1,e2,e3) ->\n      \"(log(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^\n              ((exprToString e2 \")/\") ^ (\"log(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Harmonic of expr* expr\n  | Log of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Harmonic (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"*\" ^\n              ((exprToString e2) ^\n                 (\")/(\" ^\n                    ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")\")))))))\n  | Log (e1,e2,e3) ->\n      \"(log(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^\n              ((exprToString e2) ^\n                 (\")/\" ^ (\"log(\" ^ ((exprToString e3) ^ \"))\"))))));;\n"}
{"hw": "hw2", "index": 1752, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), ((f x) = x)) in (h, b));;\n"}
{"hw": "hw2", "index": 1753, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), ((f x) = x)) in (h, b));;\n"}
{"hw": "hw2", "index": 1754, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (buildY (rand, (depth - 1))), (buildX (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1755, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildY () | _ -> buildX ()\n  else\n    (let r = rand (0, 6) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildX ()))\n     | 4 ->\n         ((buildThresh\n             ((build (rand, (depth - 1))), (buildX ()), (buildY ()))),\n           (buildX ())));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSinCos e = SinCos e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildY () | _ -> buildX ()\n  else\n    (let r = rand (0, 6) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 -> buildAverage ((build (rand, (depth - 1))), (buildY ()))\n     | 3 -> buildTimes ((build (rand, (depth - 1))), (buildX ()))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (buildX ()), (buildY ()),\n             (buildX ()))\n     | 5 -> buildSinCos (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1756, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.14 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if ex1 < ex2 then eval (ex3, x, y) else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.14 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.0\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if ex1 < ex2 then eval (ex3, x, y) else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 1757, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.14 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.0\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | SinCos ex ->\n      (sin (pi *. (eval (ex, x, y)))) *. (cos (pi *. (eval (ex, x, y))))\n  | Three (ex1,ex2,ex3) ->\n      ((eval (ex1, x, y)) *. (cos (pi *. (eval (ex2, x, y))))) *.\n        (sin (pi *. (eval (ex3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | Three of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.14 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.0\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | SinCos ex ->\n      (sin (pi *. (eval (ex, x, y)))) *. (cos (pi *. (eval (ex, x, y))))\n  | Three (ex1,ex2,ex3) ->\n      ((eval (ex1, x, y)) *. (cos (pi *. (eval (ex2, x, y))))) *.\n        (sin (pi *. (eval (ex3, x, y))));;\n"}
{"hw": "hw2", "index": 1758, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VaryY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1759, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString expr =\n  match expr with\n  | \"VarX\" -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString expr =\n  match expr with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1760, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((ex t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((ex t) ^ \")\")\n  | Average (ex1,ex2) -> \"(\" ^ ((ex ex1) ^ (\"*\" ^ ((ex ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (ex ex1) ^ (\"*\" ^ (ex ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((ex ex1) ^\n           (\"<\" ^ ((ex ex2) ^ (\"?\" ^ ((ex ex3) ^ (\":\" ^ ((ex ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1761, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = if e = VarX then \"x\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"(\" ^ ((exprToString ex1) ^ (\"*\" ^ ((exprToString ex2) ^ \")/2\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1762, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | Three of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | SinCos ex ->\n      \"sin(pi*\" ^\n        ((exprToString ex) ^ (\")*cos(pi*\" ^ ((exprToString ex) ^ \")\")))\n  | Three (ex1,ex2,ex3) ->\n      (exprToString ex1) ^\n        (\"*cos(pi*\" ^\n           ((exprToString ex2) ^ (\")*sin(pi*\" ^ (exprToString ex3 \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | Three of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | SinCos ex ->\n      \"sin(pi*\" ^\n        ((exprToString ex) ^ (\")*cos(pi*\" ^ ((exprToString ex) ^ \")\")))\n  | Three (ex1,ex2,ex3) ->\n      (exprToString ex1) ^\n        (\"*cos(pi*\" ^\n           ((exprToString ex2) ^ (\")*sin(pi*\" ^ ((exprToString ex3) ^ \")\"))));;\n"}
{"hw": "hw2", "index": 1763, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let xx = f b in if b = xx then (xx, false) else (xx, true) in\n      g), b);;\n"}
{"hw": "hw2", "index": 1764, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) = wwhile ((let (i,t) = f b in i = b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let xx = f b in if b = xx then (xx, false) else (xx, true) in\n      g), b);;\n"}
{"hw": "hw2", "index": 1765, "problem": "fixpoint", "bad": "\nlet fp f b = let (i,t) = f b in if i = b then b;;\n\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) = wwhile ((fp f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let g b = let xx = f b in if b = xx then (xx, false) else (xx, true) in\n      g), b);;\n"}
{"hw": "hw2", "index": 1766, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [] in\n        let rest' = List.rev t in\n        if List.mem h rest'\n        then rest = t\n        else h :: (seen' helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1767, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [] in\n        let rest' = List.rev t in\n        if List.mem h rest'\n        then rest = t\n        else seen' = (h :: (seen' helper (seen', rest'))) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1768, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [] in\n        let rest' = List.rev t in\n        if List.mem h rest'\n        then rest' = t\n        else rest' = (t helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1769, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [] in\n        let rest' = List.rev t in\n        if List.mem h rest'\n        then rest' = t\n        else (let seen' = h :: seen' in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1770, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [] in\n        let rest' = List.rev t in\n        if (List.mem h rest') = false\n        then let seen' = h :: seen' in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1771, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        let rest' = List.rev t in\n        if (List.mem h rest') = false\n        then let seen' = h :: seen' in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1772, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let rest' = List.rev t in\n        let seen' = seen in\n        if (List.mem h rest') = false then h :: (seen' helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1773, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let rest' = List.rev t in\n        let seen' = seen in\n        if (List.mem h rest') = false then seen' helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1774, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let rest' = List.rev t in\n        let seen' = seen in\n        (if (List.mem h rest') = false then h :: seen'; helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1775, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (if (List.mem h List.rev t) = false then h :: seen';\n         (let rest' = t in helper (seen', rest'))) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1776, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: seen in\n        if (List.mem h List.rev t) = false\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1777, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = h :: seen in\n        if (List.mem h r) = false\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1778, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        if List.mem h r\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1779, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        if List.mem h r\n        then\n          let seen' = h :: seen in\n          let seen' = seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1780, "problem": "removeDuplicates", "bad": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let r = List.rev t in\n          let seen' = seen in\n          if (List.mem h r) = false then seen' := (h :: seen) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1781, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = seen in\n        (if 1 = 2 then seen' := (h :: seen);\n         (let rest' = t in helper (seen', rest'))) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let assignSeen h r seen = if List.mem h r then seen else h :: seen in\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = assignSeen h r seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1782, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = seen in\n        (if 1 = 2 then seen' := (h :: seen');\n         (let rest' = t in helper (seen', rest'))) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let assignSeen h r seen = if List.mem h r then seen else h :: seen in\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let r = List.rev t in\n        let seen' = assignSeen h r seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1783, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = if f b then f (f, b) else 1;;\n", "fix": "\nlet rec wwhile (f,b) = let (i,t) = f b in if t then wwhile (f, i) else i;;\n"}
{"hw": "hw2", "index": 1784, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sin e -> sin (pi * e)\n  | Cosine e -> cos (pi * (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1785, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1786, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * eva; (e, x, y))\n  | Cosine e -> cos (pi * (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1787, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1788, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1789, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Quarter of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e -> e *. e\n  | Quarter e -> e /. 4.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Quarter of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Quarter e -> (eval (e, x, y)) /. 4.0;;\n"}
{"hw": "hw2", "index": 1790, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> Printf.printf \"x\" exprToString e\n  | VarY e -> Printf.printf \"y\" exprToString e\n  | Sine e -> Printf.printf \"sin(pi*%s)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" exprToString e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1791, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" exprToString e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1792, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" (!exprToString) e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1793, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" (exprToString e)\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1794, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1795, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\"\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1796, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> ((Printf.printf \"sin(pi*%s)\"), (exprToString e))\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1797, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%d)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1798, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1799, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"%s\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1800, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> (Printf.printf \"sin(pi*\") ^ ((exprToString e) ^ \")\")\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1801, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf (\"sin(pi*\" ^ ((exprToString e) ^ \")\"))\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1802, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1803, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"x\"\n  | VarY  -> Printf.printf \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s\" Printf.printf exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1804, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> Printf.printf \"sin(pi*%s)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1805, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*%s)\" exprToString e\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1806, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ (exprToString e)\n  | Cosine e -> Printf.printf \"cos(pi*%s)\" (!exprToString) e\n  | Average (e1,e2) ->\n      Printf.printf \"((%s + %s)/2)\" exprToString e1 exprToString e2\n  | Times (e1,e2) -> Printf.printf \"%s * %s\" exprToString e1 exprToString e2\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.printf \"(%s<%s ? %s : %s)\" exprToString e1 exprToString e2\n        exprToString e3 exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1807, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ ((\" + \" exprToString e2) ^ \")/2)\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1808, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e -> \"%s*%s\" exprToString e exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e -> (exprToString e) ^ (\"*\" ^ (exprToString e));;\n"}
{"hw": "hw2", "index": 1809, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e -> \"%s*%s\" exprToString e exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Square e -> (exprToString e) ^ (\"*\" ^ (exprToString e));;\n"}
{"hw": "hw1", "index": 1810, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) + (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1811, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1812, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1813, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1814, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1815, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1816, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1817, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> t @ h;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> t @ [h];;\n"}
{"hw": "hw1", "index": 1818, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 1819, "problem": "additivePersistence", "bad": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfIntHelper (n / 10));;\n\nlet rec digitsOfInt n = List.rev (digitsOfIntHelper n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  if ((sumList digits n) / 10) = 0\n  then sumList digits n\n  else additivePersiste;;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfIntHelper (n / 10));;\n\nlet rec digitsOfInt n = List.rev (digitsOfIntHelper n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if ((sumList (digits n)) / 10) = 0 then acc else acc + 1 in\n  count 1 n;;\n"}
{"hw": "hw1", "index": 1820, "problem": "additivePersistence", "bad": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfIntHelper (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (digitsOfIntHelper n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if (sumList (digits n)) mod (10 not 0) then acc else acc + 1 in\n  count 1 n;;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfIntHelper (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (digitsOfIntHelper n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if ((sumList (digits n)) mod 10) <> 0 then acc else acc + 1 in\n  count 1 n;;\n"}
{"hw": "hw1", "index": 1821, "problem": "additivePersistence", "bad": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if ((sumList (digits n)) / 10) = 0 then acc + 1 else (count acc) + (1 n) in\n  count 0 n;;\n", "fix": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if ((sumList (digits n)) / 10) = 0 then acc + 1 else count (acc + 1) n in\n  count 0 n;;\n"}
{"hw": "hw1", "index": 1822, "problem": "additivePersistence", "bad": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if n < 10 then acc else (acc + 1) (sumList (digits n)) in\n  count 0 n;;\n", "fix": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if n < 10 then acc else count (acc + 1) (sumList (digits n)) in\n  count 0 n;;\n"}
{"hw": "hw1", "index": 1823, "problem": "additivePersistence", "bad": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if n < 10 then acc else count (acc + 1) sumList (digits n) in\n  count 0 n;;\n", "fix": "\nlet rec intToReverseList n =\n  if n <= 0 then [] else (n mod 10) :: (intToReverseList (n / 10));;\n\nlet rec listReverseHelper l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet rec digitsOfInt n = listReverseHelper (intToReverseList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  let rec count acc n =\n    if n < 10 then acc else count (acc + 1) (sumList (digits n)) in\n  count 0 n;;\n"}
{"hw": "hw1", "index": 1824, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n < 0 then [] else (digits n) / 1;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1825, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) / 1;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1826, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1827, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else (n mod 10) :: digitsOfInt;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1828, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1829, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n >= 0 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1830, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet palindrome w = if (explode w) = (listReverse (explode w)) then true;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec go i =\n    function\n    | [] -> i\n    | headElement::tailList -> go (headElement :: i) tailList in\n  go [] l;;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 1831, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1832, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else (digitsOfInt n) / 10;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1833, "problem": "digitsOfInt", "bad": "\nlet rec lastListElement n =\n  match n with\n  | [] -> failwith \"ERROR: List must be of size 1 or greater\"\n  | x::[] -> x\n  | x::y -> lastListElement y;;\n\nlet rec popOffLast n =\n  match n with | [] -> [] | x::[] -> [] | x::y -> x :: (popOffLast y);;\n\nlet rec catLists x y =\n  if y = []\n  then x\n  else\n    (match x with\n     | [] -> y\n     | x::[] -> x :: y\n     | h::t -> catLists (popOffLast x) ((lastListElement x) :: y));;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else digitsOfInt (catLists (n / 10) [n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1834, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::y -> (listReverse y) :: x;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::y -> (listReverse y) @ [x];;\n"}
{"hw": "hw1", "index": 1835, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1836, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1837, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1838, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1839, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1840, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw2", "index": 1841, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> ()\n  | 1 -> if (rand mod 2) = 0 then buildX else buildY\n  | n when n > 1 -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if true then buildX () else buildY ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1842, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand mod 2) = 0 then buildX else buildY\n  | n when n > 0 -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if true then buildX () else buildY ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1843, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with | 0 -> buildX | n -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1844, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand mod 2) == 0 then buildX () () else buildY () ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1845, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand mod 2) == 0 then buildX else buildY\n  | n -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1846, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if rand mod 2 then buildX () else buildY ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | n -> buildSine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 1847, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (243, 98723)), depth) with\n  | (x,0) when (x mod 2) = 0 -> buildY ()\n  | (x,0) when (x mod 2) = 1 -> buildX ()\n  | (x,n) when (n mod 5) = 0 -> buildSine (build (x, (n - 1)))\n  | (x,n) when (n mod 5) = 4 -> buildCosine (build (x, (n - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (243, 98723)), depth) with\n  | (x,0) when (x mod 2) = 0 -> buildY ()\n  | (x,0) when (x mod 2) = 1 -> buildX ()\n  | (x,n) when (n > 0) && ((x mod 5) = 0) ->\n      buildSine (build (rand, (n - 1)))\n  | (x,n) when (n > 0) && ((x mod 5) = 1) ->\n      buildCosine (build (rand, (n - 1)))\n  | (x,n) when (n > 0) && ((x mod 5) = 2) ->\n      buildAverage ((build (rand, (n - 1))), (build (rand, (n - 1))))\n  | (x,n) when (n > 0) && ((x mod 5) = 3) ->\n      buildTimes ((build (rand, (n - 1))), (build (rand, (n - 1))))\n  | (x,n) when (n > 0) && ((x mod 5) = 4) ->\n      buildThresh\n        ((build (rand, (n - 1))), (build (rand, (n - 1))),\n          (build (rand, (n - 1))), (build (rand, (n - 1))));;\n"}
{"hw": "hw2", "index": 1848, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine a -> cos (pi *. (eval (a, x, y)))\n  | Cosine a -> sin (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine a -> cos (pi *. (eval (a, x, y)))\n  | Cosine a -> sin (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 1849, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((a < 1.0) && (a > (-1.0))) || ((b < 1.0) && (b > (-1.0)))\n      then 0.5\n      else a **. b\n  | TowerInv (a,b,c) ->\n      if ((a < 1.0) && (a > (-1.0))) || ((b < 1.0) && (b > (-1.0)))\n      then 0.5\n      else 1 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | TowerInv (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else\n        1.0 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n"}
{"hw": "hw2", "index": 1850, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else a ** b\n  | TowerInv (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else 1 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | TowerInv (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else\n        1.0 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n"}
{"hw": "hw2", "index": 1851, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | TowerInv (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else 1 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | TowerInv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | TowerInv (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else\n        1.0 /. ((eval (a, x, y)) ** ((eval (b, x, y)) ** (eval (c, x, y))));;\n"}
{"hw": "hw2", "index": 1852, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | Tower (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else ((eval (a, x, y)) + (eval (b, x, y))) + (eval (c, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) ** (eval (b, x, y))\n  | Tower (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else ((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y));;\n"}
{"hw": "hw2", "index": 1853, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) mod (eval (b, x, y))\n  | Tower (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else ((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else (eval (a, x, y)) +. (eval (b, x, y))\n  | Tower (a,b,c) ->\n      if ((x < 1.0) && (x > (-1.0))) || ((y < 1.0) && (y > (-1.0)))\n      then 0.5\n      else ((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y));;\n"}
{"hw": "hw2", "index": 1854, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if (x < 1.0) && ((x > (-1.0)) && ((y < 1.0) && (y > (-1.0))))\n      then x *. y\n      else (eval (a, x, y)) ** (eval (b, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if (x < 1.0) && ((x > (-1.0)) && ((y < 1.0) && (y > (-1.0))))\n      then x *. y\n      else (eval (a, x, y)) ** (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1855, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) ->\n      if\n        (((-1.0) < x) < 1.0) && ((x > (-1.0)) && ((y < 1.0) && (y > (-1.0))))\n      then x *. y\n      else (eval (a, x, y)) ** (eval (b, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1856, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) -> x + y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1857, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) -> (eval (a, x, y)) + (eval (b, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Power (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1858, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) + ((eval (b, x, y)) ** 2.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) +. ((eval (b, x, y)) ** 2.0);;\n"}
{"hw": "hw2", "index": 1859, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) + ((eval (b, x, y)) ** 2.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) +. ((eval (b, x, y)) ** 2.0);;\n"}
{"hw": "hw2", "index": 1860, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2) +. ((eval (b, x, y)) ** 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) +. ((eval (b, x, y)) ** 2.0);;\n"}
{"hw": "hw2", "index": 1861, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SqDist (a,b) -> ((eval (a, x, y)) ** 2.0) +. ((eval (b, x, y)) ** 2.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos (a,b) ->\n      sin ((pi *. (eval (a, x, y))) *. (cos (pi *. (eval (b, x, y)))));;\n"}
{"hw": "hw2", "index": 1862, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Tower of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | Power (x,y) -> (ex x) ^ (\"^\" ^ (ex y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | Power (x,y) -> (ex x) ^ (\"^\" ^ (ex y));;\n"}
{"hw": "hw2", "index": 1863, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | SqDist (x,y) -> (ex x) ^ (\"^2+\" ^ ((ex y) ^ \"^2\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | SqDist (x,y) -> (ex x) ^ (\"^2+\" ^ ((ex y) ^ \"^2\"));;\n"}
{"hw": "hw2", "index": 1864, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | SqDist (x,y) ->\n      \"(\" ^ ((ex x) ^ (\")\" ^ (\"^2+\" ^ (\"(\" ^ ((ex y \")\") ^ \"^2\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SqDist of expr* expr;;\n\nlet rec exprToString e =\n  let ex = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((ex x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((ex x) ^ \")\")\n  | Average (x,y) -> \"((\" ^ ((ex x) ^ (\"+\" ^ ((ex y) ^ \")/2)\")))\n  | Times (x,y) -> (ex x) ^ (\"*\" ^ (ex y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((ex w) ^\n           (\"<\" ^ ((ex x) ^ (\"?\" ^ ((ex y) ^ (\":\" ^ ((ex z) ^ \")\")))))))\n  | SqDist (x,y) ->\n      \"(\" ^ ((ex x) ^ (\")\" ^ (\"^2+\" ^ (\"(\" ^ ((ex y) ^ (\")\" ^ \"^2\"))))));;\n"}
{"hw": "hw2", "index": 1865, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, (((f b) = (f (b - 1))) && ((f b) = b)));;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1866, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (((f b) = (f (b - 1))) && ((f b) = b))), b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1867, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((f, (((f b) == (f (b - 1))) && ((f b) == b))), b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1868, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1869, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (f < 100)), b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1870, "problem": "fixpoint", "bad": "\nlet intboolf f x = ((f x), ((f x) < 1));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (intboolf, b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1871, "problem": "fixpoint", "bad": "\nlet intboolf f b = ((f b), ((f b) == 0));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (intboolf, b);;\n", "fix": "\nlet func (f,b) b = ((f b), ((f b) == b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((func (f, b)), b);;\n"}
{"hw": "hw2", "index": 1872, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b), ((f b) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n"}
{"hw": "hw2", "index": 1873, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1874, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1875, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (seen, h) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1876, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> f b' | (b',false ) -> b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 1877, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (b',c') -> if c' then f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw1", "index": 1878, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0\n  then n mod 10\n  else additivePersistence sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0\n  then n mod 10\n  else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1879, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0\n  then n mod 10\n  else additivePersistence (sumList digitsOfInt n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) <= 0\n  then n mod 10\n  else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1880, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1881, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else n mod (10 append digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1882, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 1] append digitsOfInt (n / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1883, "problem": "palindrome", "bad": "\nlet rec endChar l =\n  match l with | [] -> [] | h::[] -> [h] | h::t -> endChar t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec removeLast l =\n  match l with | [] -> [] | h::[] -> [] | h::t -> h :: (removeLast t);;\n\nlet palindrome w =\n  let rec palin ls =\n    match ls with\n    | [] -> true\n    | h::[] -> true\n    | h::t -> if h = (endChar t) then palin (removeLast t) else false in\n  palin (explode w);;\n", "fix": "\nlet rec endChar l =\n  match l with | [] -> [] | h::[] -> [h] | h::t -> endChar t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec removeLast l =\n  match l with | [] -> [] | h::[] -> [] | h::t -> h :: (removeLast t);;\n\nlet palindrome w =\n  let rec palin ls =\n    match ls with\n    | [] -> true\n    | h::[] -> true\n    | h::t -> if [h] = (endChar t) then palin (removeLast t) else false in\n  palin (explode w);;\n"}
{"hw": "hw1", "index": 1884, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1885, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ([(digitsOfInt n) / 1] 0);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1886, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10; (digitsOfInt n) / 10;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1887, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then Printf.fprintf \"%d\\n\" 0\n  else Print.fprintf \"%d \" digitsOfInt (n / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1888, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int digitsOfInt (n / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1889, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else (print_int n) / 10; digitsOfInt (n / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then print_int 0 else print_int (n / 10); digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1890, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with\n  | _ when n <= 0 -> []\n  | _ when n > 0 -> (digitsOfInt r) :: digit;;\n", "fix": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with\n  | _ when n <= 0 -> []\n  | _ when n > 0 -> (digitsOfInt r) @ [digit];;\n"}
{"hw": "hw1", "index": 1891, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with | _ when n <= 0 -> [] | _ when n > 0 -> [digitsOfInt r; digit];;\n", "fix": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with\n  | _ when n <= 0 -> []\n  | _ when n > 0 -> (digitsOfInt r) @ [digit];;\n"}
{"hw": "hw1", "index": 1892, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with\n  | _ when n <= 0 -> []\n  | _ when n > 0 -> (digitsOfInt r) @ digit;;\n", "fix": "\nlet rec digitsOfInt n =\n  let digit = n mod 10\n  and r = n / 10 in\n  match n with\n  | _ when n <= 0 -> []\n  | _ when n > 0 -> (digitsOfInt r) @ [digit];;\n"}
{"hw": "hw1", "index": 1893, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [1];;\n"}
{"hw": "hw1", "index": 1894, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n & 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1895, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | (h::t)::[] -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw3", "index": 1896, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone 0 ((List.length l1) - (List.length l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone 0 ((List.length l2) - (List.length l1))\n    else [];;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1897, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args l1 l2 = match l1 with | [] -> [] | h1::t1 -> t1 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1898, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet addTuple (l1,l2) = l1 + l2;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = List.map addTuple (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1899, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet addTuple (l1,l2) = l1 + l2;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = List.map addTuple (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1900, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in x1 + x2 in\n    let base = failwith \"tbh\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1901, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in x1 + x2 in\n    let base = () in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1902, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in x1 + x2 in\n    let base = (0, 0) List.combine l1 l2 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1903, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in x1 + x2 in\n    let base = [(0, 0)] List.combine l1 l2 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1904, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in a + x in\n    let base = x1 + x2 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1905, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in ((((x1 + x2) + a) / 10), (((x1 + x2) + a) mod 10)) in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1906, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (((x1 + x2) / 10), a) in\n    let base = ((0, 0), []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1907, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = ((0, 0), []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1908, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in res + carry in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1909, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [res; carry] in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in res @ [carry] in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1910, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = [] in\n  let args = List.rev l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1911, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in\n  let base = (0, []) in\n  let args = l1 (tenEx 0 l2) in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1912, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    match x2 with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) res in\n  let base = (0, []) in\n  let args = l1 (tenEx 0 l2) in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1913, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    match x2 with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) res in\n  let base = (0, []) in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1914, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,res) = a in\n    match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) res in\n  let base = (0, []) in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1915, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,res) = a in\n    match x with | [] -> [] | h::t -> (0, (bigAdd (mulByDigit h l1) res)) in\n  let base = (0, []) in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1916, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,res) = a in\n    match x with | [] -> [] | h::t -> (res, (bigAdd (mulByDigit h l1) res)) in\n  let base = (0, []) in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1917, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) a in\n  let base = (0, []) in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1918, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) a in\n  let base = 0 in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1919, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) a in\n  let base = [] in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in [carry] @ res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1920, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) a in\n  let base = [] in\n  let args = tenEx 0 l2 in\n  let (carry,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1921, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) a in\n  let base = [] in\n  let args = tenEx 0 l2 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1922, "problem": "bigMul", "bad": "\nlet rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet rec tenEx x y =\n  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> [] | h::t -> bigAdd (mulByDigit h l1) t in\n  let base = [] in\n  let args = tenEx 0 l2 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1923, "problem": "bigMul", "bad": "\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet bigMul l1 l2 =\n  let f a x = let (x1,x2) = x in let (carry,res) = a in carry @ a in\n  let base = [] in\n  let args = List.rev (helper l1 l2) in\n  let (carry,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1924, "problem": "bigMul", "bad": "\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet bigMul l1 l2 =\n  let f a x = let (x1,x2) = x in let (carry,res) = a in carry @ res in\n  let base = [] in\n  let args = List.rev (helper l1 l2) in\n  let (carry,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      ((((x1 + x2) + carry) / 10), ((((x1 + x2) + carry) mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in [carry] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper l1 l2 =\n  match l1 with | [] -> [] | h::t -> (h, l2) :: (helper t l2);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (carry,res) = a in\n    ((carry @ [0]), (bigAdd ((mulByDigit x1 x2) @ carry) res)) in\n  let base = ([], []) in\n  let args = List.rev (helper l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1925, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n with\n  | 0 -> []\n  | h::t ->\n      let f a x = a in let base = \"[\" in let l = a in List.fold_left f base l;;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1926, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n > 0 then match x with | h::t -> h @ (clone t (n - 1));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1927, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n > 0 then match x with | h::t -> [h] @ (clone t (n - 1));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1928, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n > 0 then match x with | h::t -> [h] :: (clone t (n - 1));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1929, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> [h * i] @ (0 * (mulByDigit i t));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> [h * i] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 1930, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let carry = i * x in\n    match a with\n    | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n    | _ -> [carry / 10; carry mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n"}
{"hw": "hw3", "index": 1931, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone 0 ((List.length l1) - (List.length l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone 0 ((List.length l2) - (List.length l1))\n    else \"(\" ^ \")\";;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1932, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) :: l1 :: l2\n  else\n    if (List.length l1) < (List.length l2)\n    then clone 0 ((List.length l2) - (List.length l1))\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1933, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l1\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ (l1 @ [l2])\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1934, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l1\n  else\n    if (List.length l1) < (List.length l2)\n    then [(clone 0 ((List.length l2) - (List.length l1))) @ l1] @ [l2]\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1935, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then [(l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))]\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ (l1 @ l2)\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1936, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 @ [(clone 0 ((List.length l1) - (List.length l2))) @ l2]\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ (l1 @ l2)\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1937, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else [];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1938, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a ^ x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1939, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a :: x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1940, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1941, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1942, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x @ a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1943, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = [x + a] in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1944, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs + x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = x b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1945, "problem": "pipe", "bad": "\nlet pipe fs = let f a x b = b a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1946, "problem": "pipe", "bad": "\nlet pipe fs = let f a x b = b x in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1947, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x b = x + b in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x b = pipe b in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1948, "problem": "pipe", "bad": "\nlet pipe fs = let f a x b = b a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x b = a b in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1949, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sl t) in\n      let base = x in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1950, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sl t) in\n      let base = x in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1951, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = t in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1952, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a ** x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1953, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a +. (x *. x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1954, "problem": "stringOfList", "bad": "\nlet rec stringOfList f l =\n  match l with | [] -> 0 | h::t -> h + (stringOfList f t);;\n\nlet stringOfList f l =\n  match l with | [] -> 0 | h::t -> h + (stringOfList f t);;\n\nlet stringOfList f l =\n  match l with | [] -> \"\" | h::t -> (string_of_int h) ^ (stringOfList f t);;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1955, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (string_of_int a) ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1956, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = string_of_int h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw2", "index": 1957, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let g = makeRand (0, 1) in match g with | 0 -> VarX | 1 -> VarY\n  else\n    (let g = makeRand (0, 4) in\n     match g with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 -> Average (build (rand, (depth - 1)))\n     | 3 -> Times (build (rand, (depth - 1)))\n     | 4 -> Thresh (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let g = rand (0, 1) in match g with | 0 -> VarX | 1 -> VarY\n  else\n    (let g = rand (0, 4) in\n     match g with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1958, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let g = rand (0, 1) in match g with | 0 -> VarX | 1 -> VarY\n  else\n    (let g = rand (0, 4) in\n     match g with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 -> Thresh ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let g = rand (0, 1) in match g with | 0 -> VarX | 1 -> VarY\n  else\n    (let g = rand (0, 4) in\n     match g with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         Thresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1959, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (3.14 *. (eval (n, x, y)))\n  | Consine n -> cos (3.14 *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (3.14 *. (eval (n, x, y)))\n  | Cosine n -> cos (3.14 *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y));;\n"}
{"hw": "hw2", "index": 1960, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (3.14 *. (eval (n, x, y)))\n  | Cosine n -> cos (3.14 *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (3.14 *. (eval (n, x, y)))\n  | Cosine n -> cos (3.14 *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y));;\n"}
{"hw": "hw2", "index": 1961, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (m, x, y) in\n      if d > 1 then eval (m, x, y) else (eval (m, x, y)) ** (eval (n, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (m, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y));;\n"}
{"hw": "hw2", "index": 1962, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Log n ->\n      let d = eval (n, x, y) in\n      if not (d = 1) then log (eval (n, x, y)) else log 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Log n ->\n      let d = eval (n, x, y) in\n      if not (d = 1.0) then log (eval (n, x, y)) else log 1.0;;\n"}
{"hw": "hw2", "index": 1963, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d = (eval (m, x, y)) *. (eval (n, x, y)) in\n      if d > 0.0 then 1 else d /. (eval (o, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d = (eval (m, x, y)) *. (eval (n, x, y)) in\n      if d > 0.0 then 1.0 else d /. (eval (o, x, y));;\n"}
{"hw": "hw2", "index": 1964, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d =\n        (((eval (m, x, y)) * (eval (n, x, y))) * (eval (o, x, y))) /\n          (((eval (m, x, y)) + (eval (n, x, y))) + (eval (o, x, y))) in\n      if d > 1.0 then 1.0 else if d < (-1.0) then (-1.0) else d;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d =\n        (((eval (m, x, y)) *. (eval (n, x, y))) *. (eval (o, x, y))) /.\n          (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y))) in\n      if d > 1.0 then 1.0 else if d < (-1.0) then (-1.0) else d;;\n"}
{"hw": "hw2", "index": 1965, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = (eval (m, x, y)) ** (eval (n, x, y)) in\n      if (d > 1.0) || (d < (-1.0)) then 1.0\n  | Op (m,n,o) ->\n      let d =\n        (((eval (m, x, y)) *. (eval (n, x, y))) *. (eval (o, x, y))) /.\n          (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y))) in\n      if d > 1.0 then 1.0 else if d < (-1.0) then (-1.0) else d;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d > 1.0\n      then eval (m, x, y)\n      else (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d =\n        (((eval (m, x, y)) *. (eval (n, x, y))) *. (eval (o, x, y))) /.\n          (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y))) in\n      if d > 1.0 then 1.0 else if d < (-1.0) then (-1.0) else d;;\n"}
{"hw": "hw2", "index": 1966, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      (sqrt\n         (abs (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)))))\n        /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d = ((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)) in\n      (sqrt (d ** d)) /. 3.0;;\n"}
{"hw": "hw2", "index": 1967, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d = ((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)) in\n      (sqrt (sqrt (d * d))) /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) ** (eval (n, x, y))\n  | Op (m,n,o) ->\n      let d = ((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)) in\n      (sqrt (sqrt (d *. d))) /. 3.0;;\n"}
{"hw": "hw2", "index": 1968, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Op (m,n,o) -> 1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Op (m,n,o) -> 1.0;;\n"}
{"hw": "hw2", "index": 1969, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d < 0\n      then (eval (m, x, y)) ** (d *. (-1.0))\n      else (eval (m, x, y)) ** d\n  | Op (m,n,o) ->\n      (sqrt (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)))) /.\n        3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine n -> sin (pi *. (eval (n, x, y)))\n  | Cosine n -> cos (pi *. (eval (n, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.0\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y)\n  | Power (m,n) ->\n      let d = eval (n, x, y) in\n      if d < 0.0\n      then (eval (m, x, y)) ** (d *. (-1.0))\n      else (eval (m, x, y)) ** d\n  | Op (m,n,o) ->\n      (sqrt (((eval (m, x, y)) +. (eval (n, x, y))) +. (eval (o, x, y)))) /.\n        3.0;;\n"}
{"hw": "hw2", "index": 1970, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX n -> \"x\"\n  | VarY n -> \"y\"\n  | Sine n -> \"sin(\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(\" ^ ((exprToString n) ^ \")\")\n  | Average n ->\n      let (x,y) = n in\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times n ->\n      let (x,y) = n in\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh n ->\n      let (x,y,z,w) = n in\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString w)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString w)))))));;\n"}
{"hw": "hw2", "index": 1971, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(\" ^ ((exprToString n) ^ \")\")\n  | Average n ->\n      let (x,y) = n in\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times n ->\n      let (x,y) = n in\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh n ->\n      let (x,y,z,w) = n in\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString w)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString w)))))));;\n"}
{"hw": "hw2", "index": 1972, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(\" ^ ((exprToString Times (pi, x)) ^ \")\")\n  | Cosine n -> \"cos(\" ^ ((exprToString Times (pi, x)) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) ->\n      \"(\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) ->\n      \"(\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")\")))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1973, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" (exprToString y))\n  | Log n -> \"log \" ^ (exprToString n);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Log of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Log n -> \"log \" ^ (exprToString n);;\n"}
{"hw": "hw2", "index": 1974, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              (exprToString ^\n                 (\"*\" ^\n                    ((exprToString \")/(\") ^\n                       ((exprToString x) ^\n                          (\"+\" ^\n                             ((exprToString y) ^ ((\"+\" exprToString) ^ \")\")))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              ((exprToString y) ^\n                 (\"*\" ^\n                    ((exprToString z) ^\n                       (\")/(\" ^\n                          ((exprToString x) ^\n                             (\"+\" ^\n                                ((exprToString y) ^\n                                   (\"+\" ^ ((exprToString z) ^ \")\")))))))))));;\n"}
{"hw": "hw2", "index": 1975, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              ((exprToString y) ^\n                 (\"*\" ^\n                    (((exprToString z) \")/(\") ^\n                       ((exprToString x) ^\n                          (\"+\" ^\n                             ((exprToString y) ^\n                                ((\"+\" (exprToString z)) ^ \")\")))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              ((exprToString y) ^\n                 (\"*\" ^\n                    ((exprToString z) ^\n                       (\")/(\" ^\n                          ((exprToString x) ^\n                             (\"+\" ^\n                                ((exprToString y) ^\n                                   (\"+\" ^ ((exprToString z) ^ \")\")))))))))));;\n"}
{"hw": "hw2", "index": 1976, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              ((exprToString y) ^\n                 (\"*\" ^\n                    ((exprToString z) ^\n                       (\")/(\" ^\n                          ((exprToString x) ^\n                             (\"+\" ^\n                                ((exprToString y) ^\n                                   ((\"+\" (exprToString z)) ^ \")\"))))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Op of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine n -> \"sin(pi*\" ^ ((exprToString n) ^ \")\")\n  | Cosine n -> \"cos(pi*\" ^ ((exprToString n) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))))\n  | Power (x,y) -> (exprToString x) ^ (\"**\" ^ (exprToString y))\n  | Op (x,y,z) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"*\" ^\n              ((exprToString y) ^\n                 (\"*\" ^\n                    ((exprToString z) ^\n                       (\")/(\" ^\n                          ((exprToString x) ^\n                             (\"+\" ^\n                                ((exprToString y) ^\n                                   (\"+\" ^ ((exprToString z) ^ \")\")))))))))));;\n"}
{"hw": "hw2", "index": 1977, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f' x = if (f x) = b then f x else (f x) + 1 in wwhile (f', b);;\n", "fix": "\nlet fixpoint (f,b) = let rec g x = if (f x) = b then x else g (x + 1) in g 0;;\n"}
{"hw": "hw2", "index": 1978, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f' x = if (f x) = b then f x else f (x + 1) in wwhile (f', b);;\n", "fix": "\nlet fixpoint (f,b) = let rec g x = if (f x) = b then x else g (x + 1) in g 0;;\n"}
{"hw": "hw2", "index": 1979, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = if (f x) = b then f x else f (x + 1) in g 0), b);;\n", "fix": "\nlet fixpoint (f,b) = let rec g x = if (f x) = b then x else g (x + 1) in g 0;;\n"}
{"hw": "hw2", "index": 1980, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let g x = f b in ((f b), ((f b) = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = let g x = let n = f x in (n, (n = x)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1981, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = List.mem h seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1982, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') =\n    match c' with\n    | false  -> b'\n    | true  -> let b' = b' + 1 in let c' = f b' in helper (b', c') in\n  helper ((f b), (f b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in match c' with | false  -> b';;\n"}
{"hw": "hw2", "index": 1983, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile f b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in match c' with | false  -> b';;\n"}
{"hw": "hw2", "index": 1984, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f b');;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in match c' with | false  -> b';;\n"}
{"hw": "hw3", "index": 1985, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> x + y in\n    let base = [] in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1986, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> x + y in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1987, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> (x + y) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1988, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> (1, ((x + y) :: a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1989, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y) -> (((x + y) / 10), (((x + y) mod 10) :: a)) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1990, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y) -> ((x + y) / 10) :: ((x + y) mod 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1991, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,z) ->\n          (match x with\n           | (x,y) -> ((((x + y) + w) / 10), ((((x + y) + w) mod 10) :: z))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1992, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> b @ ((w mod 10) :: ((y + z), (w / 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> ((y + z), (b @ ([w mod 10] @ [w / 10]))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1993, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((w,b),(y,z)) -> b @ ((w mod 10) :: (w / 10)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> ((y + z), (b @ ([w mod 10] @ [w / 10]))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1994, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | ((w,b),(y,z)) -> b @ ([w mod 10] @ [w / 10]) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> ((y + z), (b @ ([w mod 10] @ [w / 10]))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1995, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((w,b),(y,z)) -> ((y + z), (b @ w)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((w,b),(y,z)) -> ((y + z), (b @ [w])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1996, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((w,b),(y,z)) -> ((y + z), (b @ [w])) in\n    let base = (0, []) in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((w,b),(y,z)) -> ((y + z), (b @ [w])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1997, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> ((((w + y) + z) / 10), (((y + z) mod 10) :: b)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) -> ((((w + y) + z) / 10), (((y + z) mod 10) :: b)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1998, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with | ((c,l),x) -> ((c * 10), (l + (bigMul (x * c) l1))) in\n  let base = (1, l1) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) ->\n          ((((w + y) + z) / 10), ((((w + y) + z) mod 10) :: b)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 1 then bigAdd l (mulByDigit (i - 1) l) else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((c,l),x) -> ((c * 10), (bigAdd l (mulByDigit (x * c) l1))) in\n  let base = (1, l1) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1999, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n <= 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n <= 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2000, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) ->\n          ((((w + y) + z) / 10), ((((w + y) + z) mod 10) :: b)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i - 1) l) else 0;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t when h == 0 -> removeZero t | h::t -> h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((w,b),(y,z)) ->\n          ((((w + y) + z) / 10), ((((w + y) + z) mod 10) :: b)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n"}
{"hw": "hw3", "index": 2001, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2002, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2003, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x m n = m a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2004, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x a = a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2005, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2006, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2007, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2008, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base n = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2009, "problem": "pipe", "bad": "\nlet identity a = a;;\n\nlet pipe fs =\n  let f a x = a x in let base = identity in List.fold_left f base fs;;\n", "fix": "\nlet identity a = a;;\n\nlet pipe fs =\n  let f a x = a in let base = identity in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2010, "problem": "pipe", "bad": "\nlet identity a = a;;\n\nlet pipe fs =\n  let f a x x = x a in let base = identity in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base m = m in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2011, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x y = x (a y) in let base m = m in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base m = m in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2012, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat sep a) :: x in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2013, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat sep a) @ x in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2014, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat (sep, x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2015, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2016, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2017, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (sepConcat (sep, x))) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2018, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2019, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l map f;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2020, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l.map f;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2021, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2022, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2023, "problem": "stringOfList", "bad": "\nlet stringOfList f l = List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2024, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2025, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2026, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2027, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"; \", (List.map (f, l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2028, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let strs = List.map (f, l) in sepConcat \"; \" strs;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" l;;\n"}
{"hw": "hw3", "index": 2029, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2030, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map (f, l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2031, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \", (List.map (f, l)))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2032, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map (f, l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2033, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l l = sepConcat \"; \" List.map (f, l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2034, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l l = sepConcat \"; \" (List.map (f, l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2035, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l l = sepConcat \"; \" (List.map f);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2036, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw1", "index": 2037, "problem": "digitalRoot", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else (let summed = sumList n in digitalRoot summed);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let modded = n mod 10 in\n     let quotient = n / 10 in\n     let head = digitsOfInt quotient in head @ [modded]);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10\n  then n\n  else\n    (let intList = digits n in let sum = sumList intList in digitalRoot sum);;\n"}
{"hw": "hw1", "index": 2038, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let x = n mod 10 in if n > 9 then (digitsOfInt (n / 10)) :: x else n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let x = n mod 10 in if n > 9 then (digitsOfInt (n / 10)) @ [x] else [n];;\n"}
{"hw": "hw1", "index": 2039, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let x = n mod 10 in if n > 9 then (digitsOfInt (n / 10)) @ [x] else n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let x = n mod 10 in if n > 9 then (digitsOfInt (n / 10)) @ [x] else [n];;\n"}
{"hw": "hw1", "index": 2040, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t] @ h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2041, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2042, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  match w with\n  | [] -> true\n  | h::t ->\n      let separated = explode w in\n      let reversed = listReverse separated in\n      if w == reversed then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let separated = explode w in\n  let reversed = listReverse separated in\n  if separated == reversed then true else false;;\n"}
{"hw": "hw1", "index": 2043, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  match w with\n  | [] -> true\n  | h::t ->\n      let separated = explode w in\n      let reversed = listReverse separated in\n      if separated == reversed then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let separated = explode w in\n  let reversed = listReverse separated in\n  if separated == reversed then true else false;;\n"}
{"hw": "hw1", "index": 2044, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = if w = (listReverse (explode w)) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 2045, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | h -> h | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::_ -> h | h::t -> h + (sumList t);;\n"}
{"hw": "hw3", "index": 2046, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2047, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2048, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let newCarry = tupleSum / 10 in\n      let nextDigit = tupleSum mod 10 in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2049, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (val1,val2) = x in\n    let (lastCarry,lastTupleMult) = a in\n    let tupleMult = (val1 * val2) + lastCarry in\n    let newCarry = tupleMult / 10 in\n    let nextDigit = tupleMult mod 10 in\n    (newCarry, (nextDigit :: lastTupleMult)) in\n  let base = (1, []) in\n  let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (val1,val2) = x in\n    let (lastCarry,lastTupleMult) = a in\n    let tupleMult = (val1 * val2) + lastCarry in\n    let newCarry = tupleMult / 10 in\n    let nextDigit = tupleMult mod 10 in\n    (newCarry, (nextDigit :: lastTupleMult)) in\n  let base = (1, []) in\n  let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2050, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec clone x n = sepConcat \";\" clone ((x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2051, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec clone x n = sepConcat \";\" (clone ((x n) - 1));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2052, "problem": "clone", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet rec clone x n = sepConcat \";\" ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2053, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else (clone x n) - 1;;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2054, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2055, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: (clone ((x n) - 1));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2056, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: (clone (x, (n - 1)));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2057, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: (clone (x (n - 1)));;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2058, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else if i = 1 then l else bigAdd (l, (mulByDigit ((i - 1), l)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2059, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else if i = 1 then l else ((bigAdd l), (mulByDigit ((i - 1), l)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2060, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else bigAdd l mulByDigit ((i - 1), l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2061, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else if i = 1 then l else bigAdd l (mulByDigit ((i - 1), l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2062, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else if i = 1 then l else bigAdd [l] [mulByDigit ((i - 1), l)];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2063, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else bigAdd [l] [mulByDigit (i - 1) l];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2064, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else bigAdd l mulByDigit ((i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2065, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else bigAdd l (mulByDigit ((i - 1) l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2066, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then 0 else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    let n = (List.length l2) - (List.length l1) in (((clone 0 n) @ l1), l2)\n  else\n    if (List.length l2) < (List.length l1)\n    then\n      (let n = (List.length l1) - (List.length l2) in\n       (l1, ((clone 0 n) @ l2)))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet sumHelper sum =\n  let newCarry = sum / 10 in\n  let nextDigit = sum mod 10 in (newCarry, nextDigit);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (val1,val2) = x in\n      let (lastCarry,lastTupleSum) = a in\n      let tupleSum = (val1 + val2) + lastCarry in\n      let (newCarry,nextDigit) = sumHelper tupleSum in\n      (newCarry, (nextDigit :: lastTupleSum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2067, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then let n = (List.length l2) - (List.length l1) in clone (0 n)\n  else\n    if (List.length l2) < (List.length l1)\n    then (let n = (List.length l1) - (List.length l2) in clone (0 n))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 2068, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then let n = (List.length l2) - (List.length l1) in clone 0 n\n  else\n    if (List.length l2) < (List.length l1)\n    then (let n = (List.length l1) - (List.length l2) in clone 0 n)\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 2069, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then let n = (List.length l2) - (List.length l1) in clone 0 n\n  else\n    if (List.length l2) < (List.length l1)\n    then (let n = (List.length l1) - (List.length l2) in clone 0 n);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 2070, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let func y = x (a y) in func in\n  let base = let func y = y in func in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2071, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ ((sepConcat (\";\" l)) ^ \"]\"));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2072, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map l) ^ ((sepConcat (\";\" l)) ^ \"]\"));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2073, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (f l)) ^ ((sepConcat (\";\" l)) ^ \"]\"));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2074, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\", (List.map (f l)))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2075, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2076, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map (f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2077, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2078, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2079, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2080, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" (List.map f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2081, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, ((clone 0 (length1 - length2)) @ l2))\n  else (((clone 0 (length2 - length1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let sum = (x1 + x2) + a1 in\n      let carry = sum / 10 in (carry, (a @ [sum % 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, ((clone 0 (length1 - length2)) @ l2))\n  else (((clone 0 (length2 - length1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let sum = (x1 + x2) + a1 in\n      let carry = sum / 10 in (carry, ((sum mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2082, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, ((clone 0 (length1 - length2)) @ l2))\n  else (((clone 0 (length2 - length1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let sum = (x1 + x2) + a1 in\n      let carry = sum / 10 in (carry, ((sum mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, ((clone 0 (length1 - length2)) @ l2))\n  else (((clone 0 (length2 - length1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let sum = (x1 + x2) + a1 in\n      let carry = sum / 10 in (carry, ((sum mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2083, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = a x y in let base x' = x' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x' = x' in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2084, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2085, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then (((clone 0 ((-1) * len)) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::l' -> (match x with | 0 -> removeZero l' | _ -> x :: l');;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (o,r) = a in\n      ((((x1 + x2) + o) / 10), ((((x1 + x2) + o) mod 10) :: r)) in\n    let base = (0, []) in\n    let args =\n      List.rev (List.combine ((clone 0 1) :: l1) ((clone 0 1) :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then (((clone 0 ((-1) * len)) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::l' -> (match x with | 0 -> removeZero l' | _ -> x :: l');;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (o,r) = a in\n      ((((x1 + x2) + o) / 10), ((((x1 + x2) + o) mod 10) :: r)) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2086, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2087, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then (((clone 0 ((-1) * len)) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::l' -> (match x with | 0 -> removeZero l' | _ -> x :: l');;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (o,r) = a in\n      ((((x1 + x2) + o) / 10), ((((x1 + x2) + o) mod 10) :: r)) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l mulByDigit (i - 1) l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then (((clone 0 ((-1) * len)) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::l' -> (match x with | 0 -> removeZero l' | _ -> x :: l');;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (o,r) = a in\n      ((((x1 + x2) + o) / 10), ((((x1 + x2) + o) mod 10) :: r)) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2088, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then ((((clone 0 (-1)) * len) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len = (List.length l1) - (List.length l2) in\n  if len <= 0\n  then (((clone 0 ((-1) * len)) @ l1), l2)\n  else (l1, ((clone 0 len) @ l2));;\n"}
{"hw": "hw3", "index": 2089, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2090, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2091, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2092, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2093, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x l = x (a l) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2094, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2095, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Square a -> (eval (a, x, y)) *. (eval (a, x, y))\n  | Volume (vol_1,vol_2,vol_3) ->\n      ((eval (vol_1, x, y)) *. (eval (vol_2, x, y))) *. (eval (vol_3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Square a -> (eval (a, x, y)) *. (eval (a, x, y))\n  | Volume (vol_1,vol_2,vol_3) ->\n      ((eval (vol_1, x, y)) *. (eval (vol_2, x, y))) *. (eval (vol_3, x, y));;\n"}
{"hw": "hw2", "index": 2096, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqaure of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Square a -> (eval (a, x, y)) *. (eval (a, x, y))\n  | Volume (vol_1,vol_2,vol_3) ->\n      ((eval (vol_1, x, y)) *. (eval (vol_2, x, y))) *. (eval (vol_3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Square a -> (eval (a, x, y)) *. (eval (a, x, y))\n  | Volume (vol_1,vol_2,vol_3) ->\n      ((eval (vol_1, x, y)) *. (eval (vol_2, x, y))) *. (eval (vol_3, x, y));;\n"}
{"hw": "hw2", "index": 2097, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let a = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((ex t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((ex t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))))\n  | Extra (s,t,u) ->\n      \"sin(pi*\" ^\n        ((ex s) ^\n           (\") * cos (\" ^\n              ((ex t) ^ (\") * sin(\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))))\n  | Stuff t -> \"cos(pi*\" ^ (\"(sin(pi*\" ^ ((ex t) ^ \")))\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2098, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let a = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((ex t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((ex t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))))\n  | Extra (s,t,u) ->\n      \"sin(pi*\" ^\n        ((ex s) ^ (\") * cos (\" ^ ((ex t) ^ (\") * sin(\" ^ ((ex u) ^ \")\")))))\n  | Stuff t -> \"cos(pi*\" ^ (\"(sin(pi*\" ^ ((ex t) ^ \")))\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2099, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let a = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((e t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((e t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((e s) ^ (\"+\" ^ ((e t) ^ \")/2)\")))\n  | Times (s,t) -> (e s) ^ (\"*\" ^ (e t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((e s) ^ (\"<\" ^ ((e t) ^ (\"?\" ^ ((e u) ^ (\":\" ^ ((e v) ^ \")\")))))))\n  | Extra (s,t,u) ->\n      \"sin(pi*\" ^\n        ((e s) ^ (\") * cos (\" ^ ((e t) ^ (\") * sin(\" ^ ((e u) ^ \")\")))))\n  | Stuff t -> \"cos(pi*\" ^ (\"(sin(pi*\" ^ ((e t) ^ \")))\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2100, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let a = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((e t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((e t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((e s) ^ (\"+\" ^ ((e t) ^ \")/2)\")))\n  | Times (s,t) -> (e s) ^ (\"*\" ^ (e t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((e s) ^ (\"<\" ^ ((e t) ^ (\"?\" ^ ((e u) ^ (\":\" ^ ((e v) ^ \")\")))))))\n  | Stuff t -> \"cos(pi*\" ^ (\"(sin(pi*\" ^ ((e t) ^ \")))\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2101, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let a = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((e t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((e t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((e s) ^ (\"+\" ^ ((e t) ^ \")/2)\")))\n  | Times (s,t) -> (e s) ^ (\"*\" ^ (e t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((e s) ^ (\"<\" ^ ((e t) ^ (\"?\" ^ ((e u) ^ (\":\" ^ ((e v) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2102, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))))\n  | Square s -> \"(\" ^ ((exprToString s) ^ \")^2\")\n  | Volume (s,t,u) ->\n      \"Vol(H: \" ^\n        ((exprToString s) ^\n           (\", W: \" ^\n              ((exprToString t) ^ (\", L: \" ^ ((exprToString u) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))))\n  | Square s -> \"(\" ^ ((exprToString s) ^ \")^2\")\n  | Volume (s,t,u) ->\n      \"Vol(H: \" ^\n        ((exprToString s) ^\n           (\", W: \" ^\n              ((exprToString t) ^ (\", L: \" ^ ((exprToString u) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2103, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqaure of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))))\n  | Square s -> \"(\" ^ ((exprToString s) ^ \")^2\")\n  | Volume (s,t,u) ->\n      \"Vol(H: \" ^\n        ((exprToString s) ^\n           (\", W: \" ^\n              ((exprToString t) ^ (\", L: \" ^ ((exprToString u) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((exprToString t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((exprToString t) ^ \")\")\n  | Average (s,t) ->\n      \"((\" ^ ((exprToString s) ^ (\"+\" ^ ((exprToString t) ^ \")/2)\")))\n  | Times (s,t) -> (exprToString s) ^ (\"*\" ^ (exprToString t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((exprToString s) ^\n           (\"<\" ^\n              ((exprToString t) ^\n                 (\"?\" ^ ((exprToString u) ^ (\":\" ^ ((exprToString v) ^ \")\")))))))\n  | Square s -> \"(\" ^ ((exprToString s) ^ \")^2\")\n  | Volume (s,t,u) ->\n      \"Vol(H: \" ^\n        ((exprToString s) ^\n           (\", W: \" ^\n              ((exprToString t) ^ (\", L: \" ^ ((exprToString u) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2104, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match makeRand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      let rando = makeRand (0, 4) in\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2105, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand (makeRand (0, 4)) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      let rando = makeRand (0, 4) in\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2106, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand ((makeRand (0, 4)), (makeRand (0, 4))) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      let rando = makeRand (0, 4) in\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2107, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      let rando = makeRand (0, 4) in\n      (match rand with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2108, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2109, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | depth ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2110, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2\n  | Times (v,w) -> (eval (v, x, y)) * (eval (w, x, y))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2111, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2\n  | Times (v,w) -> (eval (v, x, y)) * (eval (w, x, y))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2112, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2113, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2114, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2115, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      (eval (v, x, y)) < (eval (w, x, y) ?eval (q, x, y) eval (r, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y));;\n"}
{"hw": "hw2", "index": 2116, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      (eval (v, x, y)) < (eval (w, x, y) ?eval (q, x, y) eval (r, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      if (eval (v, x, y)) < (eval (w, x, y))\n      then eval (q, x, y)\n      else eval (r, x, y);;\n"}
{"hw": "hw2", "index": 2117, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      if (eval (v, x, y)) < (eval (w, x, y))\n      then eval (q, x, y)\n      else eval (r, x, y)\n  | Divide (v,w) -> (eval (v, x, y)) / (eval (w, x, y))\n  | Super (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) * (eval (v, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | Super of expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      if (eval (v, x, y)) < (eval (w, x, y))\n      then eval (q, x, y)\n      else eval (r, x, y)\n  | Divide (v,w) -> (eval (v, x, y)) /. (eval (w, x, y))\n  | Super (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) *. (eval (v, x, y));;\n"}
{"hw": "hw2", "index": 2118, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | Super of expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      if (eval (v, x, y)) < (eval (w, x, y))\n      then eval (q, x, y)\n      else eval (r, x, y)\n  | Divide (v,w) -> (eval (v, x, y)) / (eval (w, x, y))\n  | Super (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) * (eval (v, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | Super of expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (v,w,q,r) ->\n      if (eval (v, x, y)) < (eval (w, x, y))\n      then eval (q, x, y)\n      else eval (r, x, y)\n  | Divide (v,w) -> (eval (v, x, y)) /. (eval (w, x, y))\n  | Super (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) *. (eval (v, x, y));;\n"}
{"hw": "hw2", "index": 2119, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average v ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString v) ^ \")/2\")))\n  | Times v -> (exprToString v) ^ (\"*\" ^ (exprToString v))\n  | Thresh v ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString v) ^\n              (\"?\" ^ ((exprToString v) ^ (\":\" ^ (exprToString v))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n"}
{"hw": "hw2", "index": 2120, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times v -> (exprToString v) ^ (\"*\" ^ (exprToString v))\n  | Thresh v ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString v) ^\n              (\"?\" ^ ((exprToString v) ^ (\":\" ^ (exprToString v))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))));;\n"}
{"hw": "hw2", "index": 2121, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))))\n  | Divide (v,w) -> (exprToString v) ^ (\"/\" ^ (exprToString w))\n  | Super (v,w) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"+\" ^ ((exprToString w) ^ (\") *\" ^ (exprToString v)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | Super of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ (exprToString y))))))\n  | Divide (v,w) -> (exprToString v) ^ (\"/\" ^ (exprToString w))\n  | Super (v,w) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"+\" ^ ((exprToString w) ^ (\") *\" ^ (exprToString v)))));;\n"}
{"hw": "hw2", "index": 2122, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> if b f b then b else f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2123, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (NOT (b = (f b))))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2124, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (NOT (b = (f b))))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (b != (f b)))), b);;\n"}
{"hw": "hw2", "index": 2125, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.rev (List.mem h t) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2126, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else [seen; h] in\n        let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2127, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else seen :: h in\n        let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2128, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let temp = f b in wwhile (temp, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  let (b',c') = temp in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2129, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = wwhile ((f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let temp = f b in\n  let (b',c') = temp in if c' = true then wwhile (f, b') else b';;\n"}
{"hw": "hw3", "index": 2130, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match l1 with | [] -> [] | h::t -> (x + h) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      if sum > 9\n      then (1, (((sum - 10) + (fst a)) :: (snd a)))\n      else (0, ((sum + (fst a)) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n"}
{"hw": "hw3", "index": 2131, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match l1 with | [] -> [] | h::t -> (0, ((x + h) :: a)) in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      if sum > 9\n      then (1, (((sum - 10) + (fst a)) :: (snd a)))\n      else (0, ((sum + (fst a)) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n"}
{"hw": "hw3", "index": 2132, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match l1 with | [] -> [] | h::t -> (0, ((x + h) :: a)) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      if sum > 9\n      then (1, (((sum - 10) + (fst a)) :: (snd a)))\n      else (0, ((sum + (fst a)) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n"}
{"hw": "hw3", "index": 2133, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match l1 with | [] -> (0, []) | h::t -> (0, ((x + h) :: a)) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst x) + (snd x) in\n      if sum > 9\n      then (1, (((sum - 10) + (fst a)) :: (snd a)))\n      else (0, ((sum + (fst a)) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (List.rev l1) (List.rev l2)));;\n"}
{"hw": "hw3", "index": 2134, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2135, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (clone 0 (l1.length - l2.length) l2))\n  else ((clone 0 (l2.length - l1.length)), l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2136, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - List.length)) @ l1), l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else if n = 1 then [x] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2137, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2138, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2139, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2140, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2141, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base x = x in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw2", "index": 2142, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (0, 4) in\n     if num = 0\n     then buildSine (build (rand, (depth - 1)))\n     else if num = 1 then buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (0, 4) in\n     if num = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if num = 1 then buildCosine (build (rand, (depth - 1))) else buildX ());;\n"}
{"hw": "hw2", "index": 2143, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2144, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2145, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2146, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Zero;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Zero  -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Zero;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Zero  -> 0.0;;\n"}
{"hw": "hw2", "index": 2147, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((let helper f = not f in helper), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper func = let result = f b in (result, (result = b)) in helper),\n      b);;\n"}
{"hw": "hw2", "index": 2148, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((let helper func = func in helper), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper func = let result = f b in (result, (result = b)) in helper),\n      b);;\n"}
{"hw": "hw2", "index": 2149, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper func = let (value,result) = f b in value * (not result) in\n      helper), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if result then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper func = let result = f b in (result, (result = b)) in helper),\n      b);;\n"}
{"hw": "hw2", "index": 2150, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2151, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = true then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2152, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  match (((rand 2), 6), depth) with\n  | (c,0) -> if c > 3 then BuildX () else BuildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (2, 6)), depth) with\n  | (c,0) -> if c > 3 then buildX () else buildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)))\n  | (3,_) -> buildCosine (build (rand, (depth - 1)))\n  | (4,_) ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (5,_) ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (6,_) ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2153, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3) = Darius (e1, e2, e3);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (2, 6)), depth) with\n  | (c,0) -> if c > 3 then buildX () else buildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)))\n  | (3,_) -> buildCosine (build (rand, (depth - 1)))\n  | (4,_) ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (5,_) ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (6,_) ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDarius (e1,e2,e3) = Darius (e1, e2, e3);;\n\nlet buildMirana e = Mirana e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (2, 8)), depth) with\n  | (c,0) -> if c > 3 then buildX () else buildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)))\n  | (3,_) -> buildCosine (build (rand, (depth - 1)))\n  | (4,_) ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (5,_) ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (6,_) ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (7,_) -> buildMirana (build (rand, (depth - 1)))\n  | (8,_) ->\n      buildDarius\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2154, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMirana e = Mirana e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3) = Darius (e1, e2, e3);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (2, 8)), depth) with\n  | (c,0) -> if c > 3 then buildX () else buildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)))\n  | (3,_) -> buildCosine (build (rand, (depth - 1)))\n  | (4,_) ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (5,_) ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (6,_) ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (7,_) -> buildMirana (build (rand, (depth - 1)))\n  | (8,_) ->\n      buildDarius\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildDarius (e1,e2,e3) = Darius (e1, e2, e3);;\n\nlet buildMirana e = Mirana e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match ((rand (2, 8)), depth) with\n  | (c,0) -> if c > 3 then buildX () else buildY ()\n  | (2,_) -> buildSine (build (rand, (depth - 1)))\n  | (3,_) -> buildCosine (build (rand, (depth - 1)))\n  | (4,_) ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (5,_) ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (6,_) ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | (7,_) -> buildMirana (build (rand, (depth - 1)))\n  | (8,_) ->\n      buildDarius\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2155, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos (pi *. (eval ee))\n  | Average (e1,e2) ->\n      (((eval e) +. (eval e)) /. 2) (((eval e) +. (eval e)) /. 2)\n  | Times (e1,e2) -> (eval e) *. (eval e)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2156, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin ((pi *. (eval e)), x, y)\n  | Cosine e -> cos (pi *. (eval ee))\n  | Average (e1,e2) ->\n      (((eval e) +. (eval e)) /. 2) (((eval e) +. (eval e)) /. 2)\n  | Times (e1,e2) -> (eval e) *. (eval e)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2157, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      (((eval e) +. (eval e)) /. 2) (((eval e) +. (eval e)) /. 2)\n  | Times (e1,e2) -> (eval e) *. (eval e)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2158, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2\n  | Times (e1,e2) -> (eval e) *. (eval e)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2159, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval e) *. (eval e)\n  | Thresh (e1,e2,e3,e4) -> ((eval e1) < (eval e2 ?eval e3) : eval e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2160, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) mod (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      let comb = (eval (e1, x, y)) +. (eval (e2, x, y)) in\n      mod_float comb (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2161, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) log eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      let comb = (eval (e1, x, y)) +. (eval (e2, x, y)) in\n      mod_float comb (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2162, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) log eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      let comb = (eval (e1, x, y)) +. (eval (e2, x, y)) in\n      mod_float comb (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2163, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      mod_float ((eval (e1, x, y)) +. (eval (e2, x, y))) eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      let comb = (eval (e1, x, y)) +. (eval (e2, x, y)) in\n      mod_float comb (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2164, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      mod_float (((eval (e1, x, y)) +. (eval (e2, x, y))) eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mirana of expr\n  | Darius of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Mirana e -> abs_float (eval (e, x, y))\n  | Darius (e1,e2,e3) ->\n      let comb = (eval (e1, x, y)) +. (eval (e2, x, y)) in\n      mod_float comb (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2165, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"e\"\n  | VarY  -> \"e\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> (exprToString e) ^ (\"\" ^ (exprToString e))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\" ? \" ^\n                    ((exprToString e) ^ (\" : \" ^ ((exprToString e) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"e\"\n  | VarY  -> \"e\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2166, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2167, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2168, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let func x = f in ((f, ((f x) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2169, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let func x = f in ((f, (f x not b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2170, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, (not ((f x) = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2171, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, (not ((f b) = b))) b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2172, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let func x = f in (f, (not ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2173, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let func x = f x in (f, (not ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2174, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let f2 x = f x in ((f x), ((f x) = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2175, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let f2 x = f x in ((f x), (3 < 4))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2176, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let f2 x = f x in ((f x), false)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2177, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let f2 x = f x in (f, false)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2178, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f b), (3 < 4))), b);;\n"}
{"hw": "hw2", "index": 2179, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), ((not f b) = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f b) = b)))), b);;\n"}
{"hw": "hw2", "index": 2180, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem (h, l)) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if 3 > 0 then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2181, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, l) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if 3 > 0 then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2182, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, l) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h l) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2183, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h l then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h l) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2184, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h t) then seen :: h else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2185, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2186, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = match x with | (x1,x2) -> x1 + x2 in if sum < 10 then x :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2187, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args =\n      let combine (a,b) = a + b in\n      List.map f (List.rev (List.combine (l1 l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2188, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2189, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [0] in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2190, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2191, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (1, 0) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2192, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = if x < 10 then a :: (0, x) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2193, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = if x < 10 then a @ (0, x) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (o,[]) -> (o, [x]) | (o,l) -> (o, (x :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2194, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> if x < 10 then (0, x) else (1, (x mod 10))\n      | (0,l) -> if x < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l))\n      | (1,l) ->\n          if (x + 1) < 10\n          then (0, ((x + 1) :: l))\n          else (1, ((x + (1 mod 10)) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> if x < 10 then (0, [x]) else (1, [x mod 10])\n      | (0,l) -> if x < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l))\n      | (1,l) ->\n          if (x + 1) < 10\n          then (0, ((x + 1) :: l))\n          else (1, ((x + (1 mod 10)) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2195, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          if o = 0\n          then (if x < 10 then (0, (x :: l)) else (1, (l :: (x mod 10))))\n          else\n            if (x + 1) < 10\n            then (0, ((x + 1) :: l))\n            else (1, ((x + (1 mod 10)) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          if o = 0\n          then (if x < 10 then (0, (l @ [x])) else (1, (l @ [x mod 10])))\n          else\n            if (x + 1) < 10\n            then (0, ((x + 1) :: l))\n            else (1, ((x + (1 mod 10)) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2196, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          if o = 0\n          then (if x < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)))\n          else\n            if o = 1\n            then\n              (if (x + 1) < 10\n               then (0, ((x + 1) :: l))\n               else (1, ((x + (1 mod 10)) :: l))) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = o + x in\n          if sum < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2197, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          if o = 0\n          then (if x < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)))\n          else\n            if o = 1\n            then\n              (if (x + 1) < 10\n               then (0, ((x + 1) :: l))\n               else (1, (((x + 1) mod 10) :: l))) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = o + x in\n          if sum < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2198, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          if o = 0\n          then (if x < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)))\n          else\n            if o = 1\n            then\n              (if (x + 1) < 10\n               then (0, (x :: l))\n               else (1, (((x + 1) mod 10) :: l))) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = o + x in\n          if sum < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2199, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = o + x in\n          if sum < 10 then (0, (x :: l)) else (1, ((x mod 10) :: 1)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = o + x in\n          if sum < 10 then (0, (x :: l)) else (1, ((x mod 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      List.map combine (List.rev (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2200, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ (-1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [(-1)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2201, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0; 0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2202, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = (mulByDigit x) + o in\n        if prod < 10\n        then (0, (prod :: l))\n        else ((prod / 10), ((prod mod 10) :: l)) in\n  let base = (0, []) in\n  let args =\n    let combine (a,b) = a + b in\n    (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2203, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = (mulByDigit l x) + o in\n        if prod < 10\n        then (0, (prod :: l))\n        else ((prod / 10), ((prod mod 10) :: l)) in\n  let base = (0, []) in\n  let args =\n    let combine (a,b) = a + b in\n    (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2204, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = (mulByDigit x l) + o in\n        if prod < 10\n        then (0, (prod :: l))\n        else ((prod / 10), ((prod mod 10) :: l)) in\n  let base = (0, []) in\n  let args =\n    let combine (a,b) = a + b in\n    (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2205, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = (mulByDigit (x l)) + o in\n        if prod < 10\n        then (0, (prod :: l))\n        else ((prod / 10), ((prod mod 10) :: l)) in\n  let base = (0, []) in\n  let args =\n    let combine (a,b) = a + b in\n    (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2206, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = mulByDigit x l in\n        if prod < 10\n        then (0, (prod :: l))\n        else ((prod / 10), ((prod mod 10) :: l)) in\n  let base = (0, []) in\n  let args =\n    let combine (a,b) = a + b in\n    (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2207, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (o,l) -> bigAdd (mulByDigit o l1) a in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2208, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (o,l) -> bigAdd (mulByDigit o l1) l in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit o l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2209, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd ((mulByDigit o) * (x l1)) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit (o * x) l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2210, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd ((mulByDigit o) * (x l1)) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2211, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit ((o * x) l1)) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2212, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit (o * (x l1))) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2213, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (mulByDigit ((o * m), l1)) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2214, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (o,l) -> ((10 * o), (bigAdd (((mulByDigit o) * m), l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2215, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) -> ((10 * o), (bigAdd (((mulByDigit o) * m), (l1 l)))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2216, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd ((mulByDigit prod), (l1 l)))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2217, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1 l))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (o,l) ->\n        let prod = o * x in ((10 * o), (bigAdd (mulByDigit prod l1) l)) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2218, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with | (place,l) -> ((place + 1), (bigAdd mulByDigit l l1)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with\n    | (place,l) -> ((place * 10), (bigAdd (mulByDigit (place * 10) l1) l)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2219, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with | (place,l) -> ((place + 1), (bigAdd (mulByDigit l l1))) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with\n    | (place,l) -> ((place * 10), (bigAdd (mulByDigit (place * 10) l1) l)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2220, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with\n    | (place,l) -> ((place * 10), (bigAdd (mulByDigit (place * l) l1) l)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a digit =\n    match a with\n    | (place,l) -> ((place * 10), (bigAdd (mulByDigit (place * digit) l1) l)) in\n  let base = (1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2221, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2222, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet rec mulByDigit i l =\n  let mult (i,l) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let prod = x + o in\n          if prod < 10 then (0, (prod :: l)) else (1, ((prod - 10) :: l)) in\n    let base = (0, []) in\n    let args = l in let (_,res) = List.fold_left f base args in res in\n  removeZero (mult i l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2223, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else mulByDigit (i - 1) bigAdd l l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2224, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else mulByDigit ((i - 1) bigAdd l l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2225, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else mulByDigit ((i - 1) (bigAdd l l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2226, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd (l, l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [0] else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2227, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else (bigAdd l multByDigit i) - (1 l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2228, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd (l mulByDigit ((i - 1) l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2229, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd (l mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2230, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd (l (mulByDigit (i - 1) l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2231, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then bigAdd l l else (mulByDigit i) - (1 l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2232, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then bigAdd l l else mulByDigit (i - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2233, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then bigAdd l l else mulByDigit ((i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i >= 0 then List.rev (mulByDigit (i - 1) l) else bigAdd l l;;\n"}
{"hw": "hw3", "index": 2234, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit (i - 1) bigAdd l l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then [0]\n  else if i = 1 then l else (let l' = bigAdd l l in mulByDigit (i - 1) l');;\n"}
{"hw": "hw3", "index": 2235, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit ((i - 1) bigAdd) l l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then [0]\n  else if i = 1 then l else (let l' = bigAdd l l in mulByDigit (i - 1) l');;\n"}
{"hw": "hw3", "index": 2236, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit ((i - 1) bigAdd l l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then [0]\n  else if i = 1 then l else (let l' = bigAdd l l in mulByDigit (i - 1) l');;\n"}
{"hw": "hw3", "index": 2237, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else mulByDigit (i - (1 bigAdd l l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then [0]\n  else if i = 1 then l else (let l' = bigAdd l l in mulByDigit (i - 1) l');;\n"}
{"hw": "hw3", "index": 2238, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l mulByDigit (i - 1) l';;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let difference = (List.length l1) - (List.length l2) in\n  if difference > 0\n  then (l1, ((clone 0 difference) @ l2))\n  else\n    if difference < 0\n    then (((clone 0 ((-1) * difference)) @ l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (o,l) ->\n          let sum = x + o in\n          if sum < 10 then (0, (sum :: l)) else (1, ((sum - 10) :: l)) in\n    let base = (0, []) in\n    let args =\n      let combine (a,b) = a + b in\n      (List.map combine (List.rev (List.combine l1 l2))) @ [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2239, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = x' a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = a x' in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2240, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = x' a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x x' in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2241, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = x' x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x x' in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2242, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = a x x' in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2243, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x x' = a ^ (x' ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2244, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2245, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw2", "index": 2246, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr\n  | Volume of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCotanget e = Cotangent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildVolume (l,w,h) = Volume (l, w, h);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let random = rand (0, 1) in (if random = 0 then buildX () else buildY ())\n  else\n    (let random = rand (0, 6) in\n     match random with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildCotanget (rand, (depth - 1))\n     | 6 -> buildVolume (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr\n  | Volume of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCotangent e = Cotangent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildVolume (l,w,h) = Volume (l, w, h);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let random = rand (0, 1) in (if random = 0 then buildX () else buildY ())\n  else\n    (let random = rand (0, 4) in\n     match random with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildCotangent (build (rand, (depth - 1)))\n     | 6 ->\n         buildVolume\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2247, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> Sine (pi *. (eval (e, x, y)))\n  | Cosine e -> Cosine (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) + (eval (e, x, y))) / 2\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (w,x,y,z) ->\n      (((eval (e, x, y)) *. (eval (e, x, y))) *. (eval (e, x, y))) *.\n        (eval (e, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2248, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> Sine (pi *. (eval (e, x, y)))\n  | Cosine e -> Cosine (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) / 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (w,x,y,z) ->\n      (((eval (e, x, y)) *. (eval (e, x, y))) *. (eval (e, x, y))) *.\n        (eval (e, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2249, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> Cosine (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) / 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (w,x,y,z) ->\n      (((eval (e, x, y)) *. (eval (e, x, y))) *. (eval (e, x, y))) *.\n        (eval (e, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2250, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) / 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (w,x,y,z) ->\n      (((eval (e, x, y)) *. (eval (e, x, y))) *. (eval (e, x, y))) *.\n        (eval (e, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2251, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> Average (((eval (e, x, y)) +. (eval (e, x, y))) / 2.0)\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (w,x,y,z) ->\n      (((eval (e, x, y)) *. (eval (e, x, y))) *. (eval (e, x, y))) *.\n        (eval (e, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2252, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) *.\n        (eval (d, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2253, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) *.\n        (eval (d, x, y) uncomment after implementing eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2254, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      ((((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) *.\n         (eval (d, x, y))) uncomment after implementing eval;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2255, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cotangent e -> 1.0 /. (tan (eval (e, x, y)))\n  | Volume (l,w,h) ->\n      ((eval (l, x, y)) * (eval (w, x, y))) * (eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cotangent e -> 1.0 /. (tan (eval (e, x, y)))\n  | Volume (l,w,h) ->\n      ((eval (l, x, y)) *. (eval (w, x, y))) *. (eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2256, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr* expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Squares e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Volume (l,w,h) ->\n      ((eval (l, x, y)) *. (eval (w, x, y))) *. (eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Squares e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Volume (l,w,h) ->\n      ((eval (l, x, y)) *. (eval (w, x, y))) *. (eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2257, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Squares e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Substract (j,k) -> (eval (j, x, y)) -. (eval (k, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Squares e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Substract (j,k) -> (eval (j, x, y)) -. (eval (k, x, y));;\n"}
{"hw": "hw2", "index": 2258, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" exprToString e \")\"\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average e ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times e -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2259, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" exprToString e \")\"\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average e -> ((\"((\" exprToString e), ((exprToString e \")\") / (2 \")\")))\n  | Times e -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2260, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" exprToString e \")\"\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average (x,y) ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times e -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2261, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" exprToString e \")\"\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average (x,y) ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2262, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ (exprToString e \")\")\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average (x,y) ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2263, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" exprToString e \")\"\n  | Average (x,y) ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2264, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      (\"((\" exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\")))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2265, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e \")\") / (2 \")\"))))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2266, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^\n        ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ (\")\" / (2 \")\")))))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2267, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times (x,y) -> exprToString e \"*\" exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2268, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> exprToString x \"*\" exprToString y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n"}
{"hw": "hw2", "index": 2269, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      (exprToString w) ^\n        (\"*\" ^\n           ((exprToString x) ^\n              (\"*\" ^ ((exprToString y) ^ (\"*\" exprToString z)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      (exprToString w) ^\n        (\"*\" ^\n           ((exprToString x) ^\n              (\"*\" ^ ((exprToString y) ^ (\"*\" ^ (exprToString z))))));;\n"}
{"hw": "hw2", "index": 2270, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotanget e ->\n      \"(\" ^ ((1.0 /. \"(\") ^ (tan ^ ((\"(\" exprToString e) ^ \")))\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2271, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e ->\n      \"(\" ^ ((1.0 /. \"(\") ^ (tan ^ ((\"(\" exprToString e) ^ \")))\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2272, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> 1 ^ \"/cot\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2273, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"contan\" ^ (exprToString e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2274, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"contan(\" ^ ((exprToString e) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2275, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cotangent of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Cotangent e -> \"cot(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2276, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> exprToString e \"*\" exprToString e\n  | Volume (l,w,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"*(\" ^ ((exprToString e) ^ (\")*\" ^ ((exprToString e) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Volume (l,w,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"*(\" ^ ((exprToString e) ^ (\")*\" ^ ((exprToString e) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2277, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr* expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Volume (l,w,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"*(\" ^ ((exprToString e) ^ (\")*\" ^ ((exprToString e) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Volume (l,w,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"*(\" ^ ((exprToString e) ^ (\")*\" ^ ((exprToString e) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2278, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) ->\n      \"(\" ^ ((exprToString e) ^ (\"-\" ^ (exprToString e \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) -> (exprToString e) ^ (\"-\" ^ (exprToString e));;\n"}
{"hw": "hw2", "index": 2279, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) ->\n      \"(\" ^ ((exprToString e) ^ (\"-\" ^ (exprToString e \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) -> (exprToString e) ^ (\"-\" ^ (exprToString e));;\n"}
{"hw": "hw2", "index": 2280, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) ->\n      \"(\" ^ ((exprToString j) ^ (\"-\" ^ (exprToString k \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Substract of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Substract (j,k) -> (exprToString e) ^ (\"-\" ^ (exprToString e));;\n"}
{"hw": "hw2", "index": 2281, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Volume (j,k,l) ->\n      (exprToString e) ^ (\"*\" ^ (exprToString e \"*\" exprToString e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squares of expr\n  | Volume of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString y) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ (exprToString z)))))))\n  | Squares e -> (exprToString e) ^ (\"*\" ^ (exprToString e))\n  | Volume (j,k,l) ->\n      (exprToString e) ^\n        (\"*\" ^ ((exprToString e) ^ (\"*\" ^ (exprToString e))));;\n"}
{"hw": "hw2", "index": 2282, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (f, b) then fixpoint f f b else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2283, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (f = b) then fixpoint f f b else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2284, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (f = b) then fixpoint (f, (f b)) else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2285, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (f = (f b)) then fixpoint (f f b) else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2286, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (f = (f b)) then fixpoint (f, (f b)) else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2287, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint f f b else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2288, "problem": "fixpoint", "bad": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint ((f b), b) else f b;;\n", "fix": "\nlet rec fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n\nlet fixpoint (f,b) = if not (b = (f b)) then fixpoint (f, (f b)) else f b;;\n"}
{"hw": "hw2", "index": 2289, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem = h) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem = h) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2290, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem = h) then h :: seen else seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem = h) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2291, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem = h) then h :: seen else seen in\n        let rest' = [t] in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2292, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2293, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2294, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | h::t -> if k = h then h else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (f,s) = h in if k = f then s else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 2295, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (f,s) = h in if k = f then s else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 2296, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (f,s) = h in if k = f then s else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (f,s) = h in if k = f then s else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 2297, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval e'))\n  | Cosine e' -> cos (pi * (eval e'))\n  | Average (e1,e2) -> ((eval e1) + (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) * (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2298, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2299, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2300, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2301, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2302, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Cube of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Cube e' -> (eval (e', x, y)) ^ 3\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Cube of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Cube e' -> (eval (e', x, y)) ** 3.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2303, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Cube of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Cube e' -> (eval (e', x, y)) ** 3\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Cube of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Cube e' -> (eval (e', x, y)) ** 3.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2304, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine e' -> Printf.sprintf (\"sin(%s)\", (exprToString e'))\n  | Cosine e' -> Printf.sprintf (\"cos(%s)\", (exprToString e'))\n  | Average (e1,e2) ->\n      Printf.sprintf (\"(%s+%s)/2\", (exprToString e1), (exprToString 2))\n  | Times (e1,e2) ->\n      Printf.sprintf (\"(%s*%s)\", (exprToString e1), (exprToString 2))\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf\n        (\"%s<%s?%s:%s)\", (exprToString e1), (exprToString e2),\n          (exprToString e3), (exprToString e4));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2305, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine f' -> Printf.sprintf (\"sin(%s)\", (exprToString f'))\n  | Cosine e' -> Printf.sprintf (\"cos(%s)\", (exprToString e'))\n  | Average (e1,e2) ->\n      Printf.sprintf (\"(%s+%s)/2\", (exprToString e1), (exprToString 2))\n  | Times (e1,e2) ->\n      Printf.sprintf (\"(%s*%s)\", (exprToString e1), (exprToString 2))\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf\n        (\"%s<%s?%s:%s)\", (exprToString e1), (exprToString e2),\n          (exprToString e3), (exprToString e4));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2306, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine e' -> Printf.sprintf (\"sin(pi*\" ^ ((exprToString e') ^ \")\"))\n  | Cosine e' -> Printf.sprintf (\"sin(pi*\" ^ ((exprToString e') ^ \")\"))\n  | Average (e1,e2) ->\n      Printf.sprintf\n        (\"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\"))))\n  | Times (e1,e2) ->\n      Printf.sprintf\n        (\"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\"))))\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf\n        (\"(\" ^\n           ((exprToString e1) ^\n              (\"<\" ^\n                 ((exprToString e2) ^\n                    (\"?\" ^\n                       ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\"))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2307, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Exp e' -> \"e^\" ^ (exprToString e');;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Exp of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Exp e' -> \"e^\" ^ (exprToString e');;\n"}
{"hw": "hw2", "index": 2308, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let b' = f b in if b != b' then true else false), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let f' b' = ((f b'), ((f b') != b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 2309, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let b' = f b in (b', (b' != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let f' b' = ((f b'), ((f b') != b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 2310, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let b' = f b in (b', (b' = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let f' b' = ((f b'), ((f b') != b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 2311, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let q = f b in (q, (q != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let f' b' = ((f b'), ((f b') != b')) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 2312, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2313, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2314, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2315, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else [seen; h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 2316, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n = (digits n 5) :: list;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match digits n with | [] -> 0 | h::t -> addNumbs (h :: t);;\n"}
{"hw": "hw1", "index": 2317, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match digits n with | [] -> 0 | h::t -> addNumbs n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match digits n with | [] -> 0 | h::t -> addNumbs (h :: t);;\n"}
{"hw": "hw1", "index": 2318, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | [] -> 0\n  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | [] -> 0\n  | h::t -> if (addNumbs (h :: t)) >= 10 then 1 else 2;;\n"}
{"hw": "hw1", "index": 2319, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 2320, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 2321, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 2322, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 2323, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 2324, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2325, "problem": "palindrome", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet cutTail z = match listReverse z with | [] -> [] | h::t -> t;;\n\nlet getHeads x = match listReverse x with | [] -> [] | h::t -> h;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads y =\n  match y with\n  | [] -> true\n  | h::t -> if h = (getHeads t) then matchHeads (cutTail t) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2326, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> explode w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2327, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads y = match y with | [] -> [] | h::t -> t;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2328, "problem": "palindrome", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet cutTail z = match listReverse z with | [] -> [] | h::t -> t;;\n\nlet getHeads x = match listReverse x with | [] -> [] | h::t -> h;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads y =\n  match y with\n  | [] -> true\n  | h::t -> if h = (getHeads t) then matchHeads (cutTail t) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> [] | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2329, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> [] | h::t -> w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2330, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> [] | h::t -> w @ [];;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2331, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = x;;\n\nlet palindrome w = match explode w with | [] -> [] | h::t -> matchHeads w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match explode x with | h::t -> false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads w;;\n"}
{"hw": "hw1", "index": 2332, "problem": "palindrome", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match explode x with\n  | h::t ->\n      if (getHeads (explode x)) = []\n      then true\n      else if [h] = (getHeads t) then true else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;\n\nlet loseTail z = match listReverse z with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | h::t ->\n      if (getHeads x) = []\n      then true\n      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2333, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x y =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (explode w) (listReverse (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2334, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x y =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads [\"b\"; \"o\"; \"b\"] (listReverse (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2335, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x y =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listReverse (explode w)) (listReverse (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2336, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads (x,y) =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead y)\n      then matchHeads (t, (getTail y))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listReverse (explode w)) (listReverse (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2337, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads (x,y) =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead y)\n      then matchHeads (t, (getTail y))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2338, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2339, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listReverse (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads [[\"b\"]];;\n"}
{"hw": "hw1", "index": 2340, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (h :: t);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2341, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> matchHeads t;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2342, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (getTail (explode w));;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2343, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2344, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads explode w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2345, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2346, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listReverse (explode w));;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2347, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (getTail (listReverse (explode w)));;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2348, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (listReverse t)\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2349, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x)) then matchHeads t else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2350, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2351, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads ((explode w) @ []);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2352, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if (getHead x) = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with | [] -> true | h::t -> if true then true else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2353, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t -> if (getHead x) = (getHead (listReverse x)) then true else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with | [] -> true | h::t -> if true then true else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2354, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead (listReverse x))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> true;;\n"}
{"hw": "hw1", "index": 2355, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead (listReverse t))\n      then matchHeads (getTail (listReverse t))\n      else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> true;;\n"}
{"hw": "hw1", "index": 2356, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = match explode w with | [] -> true | h::t -> true;;\n"}
{"hw": "hw1", "index": 2357, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listList xs = match xs with | [] -> [[]] | h::t -> [h] @ (listList t);;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listList (explode w));;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listList xs =\n  match xs with | [] -> [[]] | h::t -> [[h]] @ (listList t);;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listList (explode w));;\n"}
{"hw": "hw1", "index": 2358, "problem": "palindrome", "bad": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listList xs = match xs with | [] -> [[]] | h::t -> [h] @ (listList t);;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (listList w);;\n", "fix": "\nlet getHead h = match h with | [] -> [] | h::t -> h;;\n\nlet getTail t = match t with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listList xs =\n  match xs with | [] -> [[]] | h::t -> [[h]] @ (listList t);;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | h::t -> matchHeads (listList (explode w));;\n"}
{"hw": "hw1", "index": 2359, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> listReverse (explode w);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads w =\n  match w with\n  | [] -> true\n  | h::t -> if h = (List.hd (listReverse w)) then true else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2360, "problem": "palindrome", "bad": "\nlet getHead y = match y with | [] -> [] | h::t -> h;;\n\nlet getTail i = match i with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x = match x with | [] -> true | h::t -> true;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw1", "index": 2361, "problem": "palindrome", "bad": "\nlet getHead y = match y with | [] -> \"u\" | h::t -> h;;\n\nlet getTail i = match i with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n", "fix": "\nlet getHead y = match y with | [] -> 'u' | h::t -> h;;\n\nlet getTail i = match i with | [] -> [] | h::t -> t;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec matchHeads x =\n  match x with\n  | [] -> true\n  | h::t ->\n      if h = (getHead t) then matchHeads (getTail (listReverse t)) else false;;\n\nlet palindrome w =\n  match explode w with | [] -> true | h::t -> matchHeads (explode w);;\n"}
{"hw": "hw2", "index": 2362, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX\n  | 2 -> buildY\n  | 3 -> buildSine (build (rand, (depth - 1)))\n  | 4 -> buildCosine (build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine (build (rand, (depth - 1)))\n  | 4 -> buildCosine (build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2363, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval e)\n  | Cosine e -> cos (eval e)\n  | Average (e,f) -> ((eval e) + (eval f)) / 2\n  | Times (e,f) -> (eval e) * (eval f)\n  | Thresh (e,f,g,h) ->\n      (match (eval e) < (eval f) with | true  -> eval g | false  -> eval h);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2364, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) + (eval (f, x, y))) / 2\n  | Times (e,f) -> (eval (e, x, y)) * (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2365, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) / 2\n  | Times (e,f) -> (eval (e, x, y)) * (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2366, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) / 2.0\n  | Times (e,f) -> (eval (e, x, y)) * (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2367, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) * (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e,f) -> ((eval (e, x, y)) +. (eval (f, x, y))) /. 2.0\n  | Times (e,f) -> (eval (e, x, y)) *. (eval (f, x, y))\n  | Thresh (e,f,g,h) ->\n      (match (eval (e, x, y)) < (eval (f, x, y)) with\n       | true  -> eval (g, x, y)\n       | false  -> eval (h, x, y));;\n"}
{"hw": "hw2", "index": 2368, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | TimesThree of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | TimesThree e ->\n      (exprToString e) ^\n        (\"*\" ^ ((exprToString f) ^ (\"*\" ^ (exprToString f))))\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | TimesThree of expr* expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | TimesThree (e,f,g) ->\n      (exprToString e) ^\n        (\"*\" ^ ((exprToString f) ^ (\"*\" ^ (exprToString g))))\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) -> (exprToString e) ^ (\"*\" ^ (exprToString f))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2369, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,true ) -> wwhile (f, h) | (h,false ) -> h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func a = match f b with | b -> (b, false) | x -> (x, true) in\n     ((func f), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,true ) -> wwhile (f, h) | (h,false ) -> h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g x = match f x with | x -> (x, false) | y -> (y, true) in (g, b));;\n"}
{"hw": "hw2", "index": 2370, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (h,true ) -> wwhile (f, h) | (h,false ) -> h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func b = match f b with | b -> (b, false) | x -> (x, true) in\n     ((func b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (h,true ) -> wwhile (f, h) | (h,false ) -> h;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g x = match f x with | x -> (x, false) | y -> (y, true) in (g, b));;\n"}
{"hw": "hw2", "index": 2371, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2372, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem seen h with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2373, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x [0]) + (x [1])) :: a in\n    let base = [] in\n    let args = failwith List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2374, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x [0]) + (x [1])) :: a in\n    let base = [] in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2375, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2376, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x [0]) + (x [1])) :: a in\n    let base = [(1, 1)] in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2377, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x [0]) + (x [1])) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2378, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2379, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (l1x + l2x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2380, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (l1x + l2x) :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2381, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2382, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) :: a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2383, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2384, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, l1x) :: a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2385, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) @ a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2386, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2387, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, 0) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2388, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (l1x, l2x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2389, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (l1x, l2x) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2390, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (1, (l1x + l2x)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2391, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2392, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2393, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2394, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2395, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2396, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1x,l2x) = x in (0, (l1x + l2x)) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2397, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let sum = (l1x + l2x) + (a1 [(List.length a1) - 1]) in (sum / 10) ::\n        (a1.(sum % 10)) :: a2 in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2398, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let sum = (l1x + l2x) + (a2 [0]) in (0. (sum % 10)) :: a2 in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2399, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in let sum = l1x + l2x in (0, ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2400, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let sum = l1x + l2x in\n      let a1 (0::[]) = (a1 [0]) + (sum / 10) in\n      ((0 :: a2), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2401, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let sum = (l1x + l2x) + (a1 [0]) in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2402, "problem": "bigAdd", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let sum = (l1x + l2x) + a1 in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2403, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      let terms =\n        match 2 with | [] -> (sum / 10) :: (sum mod 10) | _ -> sum mod 10 in\n      (((sum / 10) :: a1), (terms :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      match a2 with\n      | [] -> ((0 :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      | h::t -> (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2404, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      let terms =\n        match 2 with | [] -> (sum / 10) :: (sum mod 10) | h::t -> sum mod 10 in\n      (((sum / 10) :: a1), (terms :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      match a2 with\n      | [] -> ((0 :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      | h::t -> (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2405, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      let terms =\n        match a2 with | [] -> (sum / 10) :: (sum mod 10) | h::t -> sum mod 10 in\n      (((sum / 10) :: a1), (terms :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      match a2 with\n      | [] -> ((0 :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      | h::t -> (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2406, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      match a2 with\n      | [] -> (0, ((sum / 10) :: (sum mod 10) :: a2))\n      | h::t -> (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      match a2 with\n      | [] -> ((0 :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      | h::t -> (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2407, "problem": "bigMul", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      if (List.length a2) = ((List.length l1) - 1)\n      then (((sum / 10) :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      else (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let test = match a with | [] -> 1 | h::t -> 10 * h in\n    let multi = mulByDigit (test * x) l1 in ((test :: a), (bigAdd multi a)) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x = y\n  then (l1, l2)\n  else\n    if x < y\n    then (((clone 0 (y - x)) @ l1), l2)\n    else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (l1x,l2x) = x in\n      let (a1,a2) = a in\n      let test = match a1 with | [] -> 0 | h::t -> h in\n      let sum = (l1x + l2x) + test in\n      if (List.length a2) = ((List.length l1) - 1)\n      then (((sum / 10) :: a1), ((sum / 10) :: (sum mod 10) :: a2))\n      else (((sum / 10) :: a1), ((sum mod 10) :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (a1,a2) = a in\n    let test = match a1 with | [] -> 1 | h::t -> 10 * h in\n    let multi = mulByDigit (test * x) l1 in ((test :: a1), (bigAdd multi a2)) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2408, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (x fs) + a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2409, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2410, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2411, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2412, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2413, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x mb x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2414, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2415, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2416, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2417, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x combine x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2418, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x combine c = x (a c) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2419, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x combine c = a c in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2420, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x mb x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2421, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2422, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l) [\"\"];;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2423, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2424, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (sepConcat \";\" (List.map f l)) [(\"[\", \"]\")];;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (sepConcat \";\" (List.map f l)) [\"[\"; \"]\"];;\n"}
{"hw": "hw1", "index": 2425, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else additivePersistence sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n"}
{"hw": "hw1", "index": 2426, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else (additivePersistence sumList digitsOfInt n) + 1;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n"}
{"hw": "hw1", "index": 2427, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else additivePersistence (sumList ((digitsOfInt n) + 1));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n"}
{"hw": "hw3", "index": 2428, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2429, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((out,sum),[]) -> (0, sum)\n      | ((out,sum),(b,c)::l') ->\n          let d = (b + c) + out in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, ([carry] @ [(carry + b) + c]))\n                    else\n                      ((carry + 1),\n                        ([carry + 1] @ [((carry + b) + c) mod 10]))\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2430, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((out,sum),[]) -> (0, sum)\n      | ((out,sum),(b,c)::l') ->\n          let d = (b + c) + out in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, ([carry] @ [(carry + b) + c]))\n                    else\n                      ((carry + 1),\n                        ([carry + 1] @ [((carry + b) + c) mod 10]))\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2431, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, (carry :: ((carry + b) + c)))\n                    else\n                      ((carry + 1), ((carry + 1) ::\n                        (((carry + b) + c) mod 10)))\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        (((((h + b) + c) / 10) :: (((h + b) + c) mod 10)) @ t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2432, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else\n                      ((carry + 1), ((carry + 1) ::\n                        (((carry + b) + c) mod 10)))\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        (((((h + b) + c) / 10) :: (((h + b) + c) mod 10)) @ t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2433, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([[((h + b) + c) / 10]; ((h + b) + c) mod 10] @ t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2434, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1), ([((h + b) + c) / 10] ::\n                        [((h + b) + c) mod 10] :: t)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2435, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> 1 | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if not (h = 0) then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          (match a with\n           | (carry,sum) ->\n               (match sum with\n                | [] ->\n                    if ((carry + b) + c) < 10\n                    then (0, [carry; (carry + b) + c])\n                    else ((carry + 1), [carry + 1; ((carry + b) + c) mod 10])\n                | h::t ->\n                    if ((b + c) + h) < 10\n                    then (0, ([0] @ ([(b + c) + h] @ t)))\n                    else\n                      ((carry + 1),\n                        ([((h + b) + c) / 10] @ ([((h + b) + c) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2436, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else\n      if (List.length l2) < (List.length l1)\n      then (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 2437, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 2438, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = 0 \"to be implemented\" in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw2", "index": 2439, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if (k, x) then x else assoc (d, k, t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (k,x) -> x | _ -> assoc (d, k, t));;\n"}
{"hw": "hw2", "index": 2440, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e2))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2441, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. ((eval e1), x, y))\n  | Cosine e1 -> cos (pi *. (eval e2))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2442, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2443, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2444, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> x\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2445, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusY of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | SqXPlusY (e1,e2) ->\n      ((eval (e1, x, y)) *. (eval (e1, x, y))) + (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusY of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | SqXPlusY (e1,e2) ->\n      ((eval (e1, x, y)) *. (eval (e1, x, y))) +. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2446, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusY of expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusYDiv2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | SqXPlusY (e1,e2) ->\n      ((eval (e1, x, y)) *. (eval (e1, x, y))) +. ((eval (e2, x, y)) /. 2.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusYDiv2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | SqXPlusYDiv2 (e1,e2) ->\n      ((eval (e1, x, y)) *. (eval (e1, x, y))) +. ((eval (e2, x, y)) /. 2.0);;\n"}
{"hw": "hw2", "index": 2447, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | Cube e1 -> ((eval (e1, x, y)) *. (eval (e1, x, y))) *. (eval (e1, x, y))\n  | MultDivBy6 (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 6;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | TimesTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | Cube e1 -> ((eval (e1, x, y)) *. (eval (e1, x, y))) *. (eval (e1, x, y))\n  | MultDivBy6 (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 6.0;;\n"}
{"hw": "hw2", "index": 2448, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> sin e1\n  | Cosine e1 -> cos e1\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2449, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin e1\n  | Cosine e1 -> cos e1\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2450, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin expr e1\n  | Cosine e1 -> cos e1\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2451, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (exprToString e1)\n  | Cosine e1 -> cos e1\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2452, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (exprToString e1)\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2453, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (exprToString e1)\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) ->\n      ((exprToString e1) +. (exprToString e2)) /. (exprToString 2)\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> ((e1 * e2) * e3) * e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2454, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (exprToString e1)\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) ->\n      ((exprToString e1) +. (exprToString e2)) /. (exprToString 2)\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2455, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) ->\n      ((exprToString e1) +. (exprToString e2)) /. (exprToString 2)\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2456, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (3.142 * (exprToString e1))\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) ->\n      ((exprToString e1) +. (exprToString e2)) /. (exprToString 2)\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2457, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (3.142 *. (exprToString e1))\n  | Cosine e1 -> cos (exprToString e1)\n  | Average (e1,e2) ->\n      ((exprToString e1) +. (exprToString e2)) /. (exprToString 2)\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2458, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (3.142 *. (exprToString e1))\n  | Cosine e1 -> cos (3.142 *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2459, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Sine e1 -> sin (3.142 *. (exprToString e1))\n  | Cosine e1 -> cos (3.142 *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2460, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (\" ^^ ((3.142 *. (exprToString e1)) ^^ \")\")\n  | Cosine e1 -> cos (3.142 *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2461, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> cos (3.142 *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2462, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^^ ((exprToString e1) ^^ (\" + \" ^^ ((exprToString e2) ^^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^^ (\" * \" ^^ (exprToString e2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2463, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^^ ((exprToString e1) ^^ (\" + \" ^^ ((exprToString e2) ^^ \"/2)\")))\n  | Times (e1,e2) ->\n      (\"\" (exprToString e1)) ^^ (\" * \" ^^ ((exprToString e2) \"\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2464, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^^ ((exprToString e1) ^^ (\") + \" ^^ ((exprToString e2) ^^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^^ (\" * \" ^^ (exprToString e2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2465, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^^ ((exprToString e1) ^^ (\") + \" ^^ ((exprToString e2) ^^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^^ (\" * \" ^^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> \"x\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2466, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^^ ((exprToString e1) ^^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^^ ((exprToString e1) ^^ (\") + \" ^^ ((exprToString e2) ^^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^^ (\" * \" ^^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^^\n        ((exprToString e1) ^^\n           (\"<\" ^^\n              ((exprToString e2) ^^\n                 (\" ? \" ^^\n                    ((exprToString e3) ^^\n                       (\" : \" ^^ ((exprToString e4) ^^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi * \" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\") + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2467, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusY of expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusYDiv2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | SqXPlusY (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\" * \" ^\n              ((exprToString e1) ^ (\") + (\" ^ ((exprToString e2) ^ \"/2\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | SqXPlusYDiv2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | SqXPlusYDiv2 (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\" * \" ^\n              ((exprToString e1) ^ (\") + (\" ^ ((exprToString e2) ^ \"/2\")))));;\n"}
{"hw": "hw2", "index": 2468, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube  ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube e1 ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))));;\n"}
{"hw": "hw2", "index": 2469, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube e1 ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))))\n  | MultDivBy6  ->\n      (\"((\" (exprToString e1)) ^ (\" * \" ^ ((exprToString e2) ^ \") /6)\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube e1 ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))))\n  | MultDivBy6 (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" * \" ^ ((exprToString e2) ^ \") /6)\")));;\n"}
{"hw": "hw2", "index": 2470, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube e1 ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))))\n  | MultDivBy6 (e1,e2) ->\n      (\"((\" (exprToString e1)) ^ (\" * \" ^ ((exprToString e2) ^ \") /6)\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | TimesTimes of expr* expr* expr\n  | Cube of expr\n  | MultDivBy6 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | TimesTimes (e1,e2,e3) ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e2) ^ (\" * \" ^ (exprToString e3))))\n  | Cube e1 ->\n      (exprToString e1) ^\n        (\" * \" ^ ((exprToString e1) ^ (\" * \" ^ (exprToString e1))))\n  | MultDivBy6 (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" * \" ^ ((exprToString e2) ^ \") /6)\")));;\n"}
{"hw": "hw2", "index": 2471, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if not result then value else wwhile (f, value);;\n\nlet fixpoint (f,b) =\n  wwhile ((let func output = ((f b), ((f b) = b)) in func b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (value,result) = f b in if not result then value else wwhile (f, value);;\n\nlet fixpoint (f,b) =\n  wwhile ((let func output = ((f b), ((f b) = b)) in func), b);;\n"}
{"hw": "hw2", "index": 2472, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [] else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2473, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h seen) then [] else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2474, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2475, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2476, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [seen] else [seen] @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2477, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [seen] else [seen] @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2478, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [seen] else [seen @ h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2479, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2480, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine (padZero (l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2481, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2482, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> let (j,k) = x in if (j + k) > 10 then 1 :: h else 0 :: h in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2483, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> let (j,k) = x in if (j + k) > 10 then 1 :: h else 0 :: h in\n    let base = (0, 0) in\n    let args = List.combine ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2484, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> let (j,k) = x in if (j + k) > 10 then 1 :: h else 0 :: h in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1; List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2485, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 10\n          then ((j = 1), (k = ((j + k) - 10)))\n          else (j = (0 k)) = ((j + k) - 10) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1; List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2486, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = h in\n          if (j + k) > 10\n          then (j = (1 k)) = ((j + k) - 10)\n          else (j = (0 k)) = ((j + k) - 10) in\n    let base = (0, 0) in\n    let args = List.combine (clone l1 (List.length l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2487, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = h in\n          if (j + k) > 10 then (1, ((j + k) - 10)) else (0, ((j + k) - 10)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2488, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = h in\n          if (j + k) > 10 then (1, ((j + k) - 10)) else (0, (j + k)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2489, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = h in\n          if (j + k) > 10 then (1, ((j + k) - 10)) else (0, (j + k)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2490, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (j,k) -> if (j + k) > 10 then (1, ((j + k) - 10)) else (0, (j + k)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2491, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (j,k) -> if (j + k) > 10 then (1, ((j + k) - 10)) else (0, (j + k)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2492, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (j,k) ->\n          if (j + k) > 10\n          then (1, (a :: ((j + k) - 10)))\n          else (0, (a :: (j + k))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2493, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (j,k) ->\n          if (j + k) > 10\n          then (1, (x :: ((j + k) - 10)))\n          else (0, (x :: (j + k))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2494, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, (((x1 + x2) + a1) - 10))\n      else (0, ((x1 + x2) + a1)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2495, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, (((x1 + x2) + a1) - 10))\n      else (0, ((x1 + x2) + a1)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (x1 + x2) > 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2496, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (a1,a2) = a in bigAdd a2 ((mulByDigit (x l1) 10) ** a1) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet rec appZero x l = if x > 0 then l @ [] else appZero (x - 1) l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (a1,a2) = a in ((a1 + 1), (bigAdd a2 (appZero a1 (mulByDigit x l2)))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2497, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((x clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 2498, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else (clone x n) - 1;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 2499, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((10 * h) * i) + (mulByDigit i t);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}
{"hw": "hw3", "index": 2500, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x = bigAdd a x in\n  let base = 0 in let args = List.rev l in List.fold_left f base args;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}
{"hw": "hw3", "index": 2501, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x = bigAdd [a] x in\n  let base = 0 in let args = List.rev l in List.fold_left f base args;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}
{"hw": "hw3", "index": 2502, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if ((x1 + x2) + a1) >= 10\n      then (1, ((((x1 + x2) + a1) - 10) :: a2))\n      else (0, (((x1 + x2) + a1) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (carry,res) = List.fold_left f base args in carry :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}
{"hw": "hw3", "index": 2503, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  let sizDif = length1 - length2 in\n  if sizDif > 0\n  then l1 :: (clone 0 sizDif) :: l2\n  else ((clone 0) - sizDif) :: l1 :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2504, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  let sizDif = length1 - length2 in\n  if sizDif > 0\n  then l1 :: (clone 0 sizDif) :: l2\n  else (((clone 0) - sizDif) :: l1) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2505, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  let sizDif = length1 - length2 in\n  if sizDif > 0\n  then l1 :: (clone 0 sizDif) :: l2\n  else ((clone 0 (- sizDif)) :: l1) :: l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2506, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1 :: pad) :: l2\n  else (let pad = clone 0 (- sizDif) in (pad :: l1) :: l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2507, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in l1 :: pad :: l2\n  else (let pad = clone 0 (- sizDif) in (pad :: l1) :: l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2508, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in l1 ^ (pad ^ l2)\n  else (let pad = clone 0 (- sizDif) in (pad ^ l1) ^ l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2509, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in l1 (pad @ l2)\n  else (let pad = clone 0 (- sizDif) in (pad @ l1) l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2510, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in l1 ^ (\"],[\" ^ (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in (pad @ l1) ^ (\"],[\" ^ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let sizDif = (List.length l1) - (List.length l2) in\n  if sizDif > 0\n  then let pad = clone 0 sizDif in (l1, (pad @ l2))\n  else (let pad = clone 0 (- sizDif) in ((pad @ l1), l2));;\n"}
{"hw": "hw3", "index": 2511, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2512, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2513, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2514, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in let base = xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2515, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in\n  let base = \"string\" in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2516, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in\n  let base base = base in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2517, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in let base = \"\" in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2518, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x x = x * x in let base a x = a + x in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2519, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x a x = a + x in\n  let base = 0 in List.fold_left (fun a  -> fun x  -> a + (x * x)) 0 xs;;\n"}
{"hw": "hw3", "index": 2520, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2521, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2522, "problem": "stringOfList", "bad": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (List.map f l)) ^ \"]\");;\n", "fix": "\nlet sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2523, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Mix of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.0\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | Square ex -> ((eval ex), x, y) *. (eval (ex, x, y))\n  | Mix (ex1,ex2,ex3) ->\n      ((eval ((Times (ex1, ex2)), x, y)) +. (eval ((Times (ex2, ex3)), x, y)))\n        /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Mix of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.0\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | Square ex -> (eval (ex, x, y)) *. (eval (ex, x, y))\n  | Mix (ex1,ex2,ex3) ->\n      ((eval ((Times (ex1, ex2)), x, y)) +. (eval ((Times (ex2, ex3)), x, y)))\n        /. 2.0;;\n"}
{"hw": "hw2", "index": 2524, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Mix of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | Square ex -> \"(\" ^ ((exprToString ex) ^ \") ^ 2\")\n  | Mix (ex1,ex2,ex3) ->\n      exprToString Average ((Times (ex1, ex2)), (Times (ex2, ex3)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Mix of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | Square ex -> \"(\" ^ ((exprToString ex) ^ \") ^ 2\")\n  | Mix (ex1,ex2,ex3) ->\n      exprToString (Average ((Times (ex1, ex2)), (Times (ex2, ex3))));;\n"}
{"hw": "hw2", "index": 2525, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval a))\n  | Cosine a -> cos (pi * (eval a))\n  | Average (a,b) -> ((eval a) + (eval b)) / 2\n  | Times (a,b) -> (eval a) * (eval b)\n  | Thresh (a,b,c,d) -> ((eval a) < (eval b ?eval c) : eval d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2526, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin pi\n  | Cosine a -> cos (pi * (eval a))\n  | Average (a,b) -> ((eval a) + (eval b)) / 2\n  | Times (a,b) -> (eval a) * (eval b)\n  | Thresh (a,b,c,d) -> ((eval a) < (eval b ?eval c) : eval d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2527, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> (sin pi) * (eval a)\n  | Cosine a -> cos (pi * (eval a))\n  | Average (a,b) -> ((eval a) + (eval b)) / 2\n  | Times (a,b) -> (eval a) * (eval b)\n  | Thresh (a,b,c,d) -> ((eval a) < (eval b ?eval c) : eval d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2528, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval a))\n  | Average (a,b) -> ((eval a) + (eval b)) / 2\n  | Times (a,b) -> (eval a) * (eval b)\n  | Thresh (a,b,c,d) -> ((eval a) < (eval b ?eval c) : eval d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2529, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2530, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3.142 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2531, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let pi = 3 in\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2532, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2533, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2534, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2535, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) -> ((a *. a) +. (b *. b)) / 2.0\n  | MultHalf (a,b,c) -> ((a *. b) *. c) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (b, x, y))))\n        /. 2.0\n  | MultHalf (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2536, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) -> ((a *. a) +. (b *. b)) / 2.0\n  | MultHalf (a,b,c) -> ((a *. b) *. c) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (b, x, y))))\n        /. 2.0\n  | MultHalf (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2537, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (b, x, y))))\n        / 2.0\n  | MultHalf (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SquareAv (a,b) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (b, x, y))))\n        /. 2.0\n  | MultHalf (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2538, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average v ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString v) ^ \")/2)\")))\n  | Times v -> (exprToString v) ^ (\"*\" ^ (exprToString v))\n  | Thresh v ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"<\" ^\n              ((exprToString v) ^\n                 (\"?\" ^ ((exprToString v) ^ (\":\" ^ ((exprToString v) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2539, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SquareAv (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"^2 + \" ^ ((exprToString b) ^ \"^2)/2\")))\n  | MultHalf (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"*\" ^ ((exprToString c) ^ \")/2\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareAv of expr* expr\n  | MultHalf of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SquareAv (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"^2 + \" ^ ((exprToString b) ^ \"^2)/2\")))\n  | MultHalf (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"*\" ^ ((exprToString c) ^ \")/2\")))));;\n"}
{"hw": "hw2", "index": 2540, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then (wwhile f) * x else x;;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, y) else x;;\n"}
{"hw": "hw1", "index": 2541, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence sumList digitsOfInt n)\n  else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence (sumList (digitsOfInt n)))\n  else 0;;\n"}
{"hw": "hw1", "index": 2542, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence sumList digitsOfInt n)\n  else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence (sumList (digitsOfInt n)))\n  else 0;;\n"}
{"hw": "hw1", "index": 2543, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence sumList (digitsOfInt n))\n  else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if 0 >= n then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) != 0\n  then 1 + (additivePersistence (sumList (digitsOfInt n)))\n  else 0;;\n"}
{"hw": "hw1", "index": 2544, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2545, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 2546, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::xs' -> h + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 2547, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | o -> o | h::xs' -> h + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 2548, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n mod 10 in\n     let b = n / 10 in\n     match b with\n     | 0 -> if a = 0 then [] else (digitsOfInt b) @ [a]\n     | x -> (digitsOfInt b) @ [a]);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet oneRoot n =\n  let y = sumList (digits n) in\n  match y / 10 with | 0 -> if (y mod 10) = 0 then 0 else y | z -> y;;\n\nlet rec addHelp (n,m) =\n  let y = oneRoot n in\n  match y / 10 with | 0 -> m + 1 | z -> addHelp (y, (m + 1));;\n\nlet rec additivePersistence n = if n / 10 then 0 else addHelp (n, 0);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n mod 10 in\n     let b = n / 10 in\n     match b with\n     | 0 -> if a = 0 then [] else (digitsOfInt b) @ [a]\n     | x -> (digitsOfInt b) @ [a]);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet oneRoot n =\n  let y = sumList (digits n) in\n  match y / 10 with | 0 -> if (y mod 10) = 0 then 0 else y | z -> y;;\n\nlet rec addHelp (n,m) =\n  let y = oneRoot n in\n  match y / 10 with | 0 -> m + 1 | z -> addHelp (y, (m + 1));;\n\nlet rec additivePersistence n = if (n / 10) = 0 then 0 else addHelp (n, 0);;\n"}
{"hw": "hw1", "index": 2549, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | [] -> [] | h::t -> h @ [digitsOfInt t]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | 0 -> []);;\n"}
{"hw": "hw1", "index": 2550, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> [t] @ (listReverse h);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw3", "index": 2551, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> (0, (x + y)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          (match a with\n           | (m,n) ->\n               if ((i + j) + m) >= 10\n               then (1, ((((i + j) + m) - 10) :: n))\n               else (0, (((i + j) + m) :: n))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2552, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [(0, (x + y))] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          (match a with\n           | (m,n) ->\n               if ((i + j) + m) >= 10\n               then (1, ((((i + j) + m) - 10) :: n))\n               else (0, (((i + j) + m) :: n))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2553, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          (match a with\n           | (m,n) ->\n               (match n with\n                | [] -> []\n                | h::t ->\n                    if ((i + j) + m) >= 10\n                    then (1, (1 :: (((i + j) + m) - 10) :: t))\n                    else (0, (0 :: ((i + j) + m) :: t)))) in\n    let base = (0, [0]) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          (match a with\n           | (m,n) ->\n               (match n with\n                | [] -> (0, [])\n                | h::t ->\n                    if ((i + j) + m) >= 10\n                    then (1, (1 :: (((i + j) + m) - 10) :: t))\n                    else (0, (0 :: ((i + j) + m) :: t)))) in\n    let base = (0, [0]) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2554, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    (match 0 :: (List.rev l) with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [h]\n          | x::y ->\n              ((mulByDigit i (((i * x) + h) / 10)) :: y) @\n                [((i * x) + h) % 10]));;\n", "fix": "\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    (match 0 :: (List.rev l) with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [h]\n          | x::y ->\n              (mulByDigit i ((((i * x) + h) / 10) :: y)) @\n                [((i * x) + h) mod 10]));;\n"}
{"hw": "hw3", "index": 2555, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then List.append (clone 0 ((List.length l1) - (List.length l2))) l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2556, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2557, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2558, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 * ((clone 0 ((List.length l1) - (List.length l2))) @ l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2559, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2560, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2561, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2562, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2563, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2564, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = y x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2565, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun x  -> x) a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2566, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun x  -> x) a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2567, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2568, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2569, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = List.combine (padZero l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2570, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let (l1p,l2p) = padZero l1 l2 in\n    let args = List.combine l1p l2p in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2571, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2572, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2573, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2574, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2575, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2576, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2577, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2578, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2579, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([(x1 + x2) / 10], ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2580, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([(x1 + x2) / 10], ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  match diff with\n  | diff when diff > 0 -> (l1, (List.append (clone 0 diff) l2))\n  | diff when diff < 0 -> ((List.append (clone 0 (0 - diff)) l1), l2)\n  | 0 -> (l1, l2)\n  | _ -> ([], []);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      (((x1 + x2) / 10), ((((a1 + x1) + x2) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2581, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = (0, []) in\n  let args = List.rev l2 in\n  let (carry,res) = List.fold_left f base args in carry :: res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) @ a in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2582, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (((mulByDigit x l1) @ (clone 0 (List.length a))) :: a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) @ a in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2583, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) @ a in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2584, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) @ a in\n  let base = [] in\n  let args = List.rev l2 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2585, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = (a, ((mulByDigit x l1) @ (clone 0 (List.length a)))) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let y = i * x in\n    match a with\n    | h::t -> ((h + y) / 10) :: ((h + y) mod 10) :: t\n    | _ -> [y / 10; y mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (a1,a2) = a in (a1, ((mulByDigit x l1) @ (clone 0 (List.length a1)))) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2586, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2587, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), (total + ((mulByDigit (x l2)) * (10 ** pow)))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec listZeros n =\n  match n with | 0 -> [] | 1 -> [0] | x -> [0] @ (listZeros (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), ((bigAdd total (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2588, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), (total + ((mulByDigit x l2) * (10 ** pow)))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec listZeros n =\n  match n with | 0 -> [] | 1 -> [0] | x -> [0] @ (listZeros (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), ((bigAdd total (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2589, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), (((bigAdd total) + (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec listZeros n =\n  match n with | 0 -> [] | 1 -> [0] | x -> [0] @ (listZeros (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), ((bigAdd total (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2590, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec listZeros n =\n  match n with | 0 -> [] | 1 -> [0] | x -> [0] @ (listZeros (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), (((bigAdd total) + (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec listZeros n =\n  match n with | 0 -> [] | 1 -> [0] | x -> [0] @ (listZeros (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | n -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pow,total) = a in\n    ((pow + 1), ((bigAdd total (mulByDigit x l2)) @ (listZeros pow))) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2591, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let x = (h * i) mod 10 in\n      let k = (h * i) / 10 in\n      if k = 0 then k + (mulByDigit t) else [x] @ (k + (mulByDigit t));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2592, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let x = (h * i) mod 10 in\n      let k = (h * i) / 10 in\n      if k = 0 then k + (mulByDigit i t) else [x] @ (k + (mulByDigit i t));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2593, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in (total + (mulByDigit i)) - (1 l));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2594, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in bigAdd total ((mulByDigit i) - (1 l)));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then l\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2595, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then 0\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 2\n  then []\n  else (let total = bigAdd l l in bigAdd total (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2596, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd mulByDigit ((i - 1) l) l;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2597, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd (mulByDigit ((i - 1) l) l);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2598, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l mulByDigit ((i - 1) l);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2599, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then [] else bigAdd l mulByDigit (i - 1) l;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 < length2\n  then (((clone 0 (length2 - length1)) @ l1), l2)\n  else\n    if length2 < length1\n    then (l1, ((clone 0 (length1 - length2)) @ l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else [h] @ t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (carry,rest) = a in\n      ((((j + k) + carry) / 10), ([((j + k) + carry) mod 10] @ rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (car,res) = List.fold_left f base args in [car] @ res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw2", "index": 2600, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan (build1, build2)\n     | 6 -> buildStrange (build1, build2, build3));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet buildArctan e1 = Arctan e1;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildStrange (e1,e2,e3) = Strange (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 2) in\n    match result with | 0 -> buildX () | _ -> buildY ()\n  else\n    (let result = rand (0, 7) in\n     let build1 = build (rand, (depth - 1)) in\n     let build2 = build (rand, (depth - 1)) in\n     let build3 = build (rand, (depth - 1)) in\n     let build4 = build (rand, (depth - 1)) in\n     match result with\n     | 0 -> buildSine build1\n     | 1 -> buildCosine build1\n     | 2 -> buildAverage (build1, build2)\n     | 3 -> buildTimes (build1, build2)\n     | 4 -> buildThresh (build1, build2, build3, build4)\n     | 5 -> buildArctan build1\n     | 6 -> buildStrange (build1, build2, build3));;\n"}
{"hw": "hw2", "index": 2601, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> x;;\n"}
{"hw": "hw2", "index": 2602, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 * (atan eval (e1, x, y))) / pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) * (eval (e1, x, y))) +\n          ((eval (e2, x, y)) * (eval (e2, x, y))))\n         + ((eval (e3, x, y)) * (eval (e3, x, y))))\n        / 3;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2603, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 *. (atan eval (e1, x, y))) / pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2604, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2 *. (atan eval (e1, x, y))) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2605, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> (2. *. (atan eval (e1, x, y))) /. pi\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2606, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> 2. *. (atan eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2607, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan eval (e1, x, y)\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Arctan of expr\n  | Strange of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Arctan e1 -> atan (eval (e1, x, y))\n  | Strange (e1,e2,e3) ->\n      ((((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n          ((eval (e2, x, y)) *. (eval (e2, x, y))))\n         +. ((eval (e3, x, y)) *. (eval (e3, x, y))))\n        /. 3.;;\n"}
{"hw": "hw2", "index": 2608, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2609, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Sqrt e1 -> \"sqrt(\" ^ ((exprToString e1) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine rest -> \"sin(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Cosine rest -> \"cos(pi*\" ^ ((exprToString rest) ^ \")\")\n  | Average (expr1,expr2) ->\n      \"(\" ^ ((exprToString expr1) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr1,expr2) ->\n      (exprToString expr1) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2610, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = (f b) = b in wwhile (f', b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then (true, (f b)) else (false, (f b)) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 2611, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper f b = (((f b) = b), (f b)) in wwhile ((helper f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 2612, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = (((f b) = b), (f b)) in wwhile ((helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 2613, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile ((helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = let fb = f b in if fb = b then (true, fb) else (false, fb) in\n  wwhile (helper, b);;\n"}
{"hw": "hw1", "index": 2614, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 2615, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) == (listReverse explode w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) == (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 2616, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw3", "index": 2617, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n >= 0\n  then (l1, ((clone 0 n) @ l2))\n  else (((clone 0 (n * (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accum) = a in\n      let (x1,x2) = x in\n      let n = (carry + x1) + x2 in ((n / 10), ((n mod 10) :: accum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then l else bigAdd l ((mulByDigit i) - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n >= 0\n  then (l1, ((clone 0 n) @ l2))\n  else (((clone 0 (n * (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accum) = a in\n      let (x1,x2) = x in\n      let n = (carry + x1) + x2 in ((n / 10), ((n mod 10) :: accum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2618, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n >= 0\n  then (l1, ((clone 0 n) @ l2))\n  else (((clone 0 (n * (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accum) = a in\n      let (x1,x2) = x in\n      let n = (carry + x1) + x2 in ((n / 10), ((n mod 10) :: accum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 0 then 0 else bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let n = (List.length l1) - (List.length l2) in\n  if n >= 0\n  then (l1, ((clone 0 n) @ l2))\n  else (((clone 0 (n * (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,accum) = a in\n      let (x1,x2) = x in\n      let n = (carry + x1) + x2 in ((n / 10), ((n mod 10) :: accum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2619, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y c = a (x c) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2620, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2621, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y c = x (a c) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 2622, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 10) in\n  let d = depth - 1 in\n  if d > 0\n  then\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildCosine (build (rand, d))\n    | 3 -> buildCosine (build (rand, d))\n    | 4 -> ((buildAverage build (rand, d)), (build (rand, d)))\n    | 5 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 6 -> ((buildTimes build (rand, d)), (build (rand, d)))\n    | 7 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 8 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 9 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 10 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let rr = rand (1, 2) in match rr with | 1 -> buildX () | 2 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 10) in\n  let d = depth - 1 in\n  if d > 0\n  then\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildCosine (build (rand, d))\n    | 3 -> buildCosine (build (rand, d))\n    | 4 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 5 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 6 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 7 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 8 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 9 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 10 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let rr = rand (1, 2) in match rr with | 1 -> buildX () | 2 -> buildY ());;\n"}
{"hw": "hw2", "index": 2623, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildExponential (e1,e2) = Exponential (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (1, 7) in\n  let d = depth - 1 in\n  if d != 0\n  then\n    match r with\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildCosine (build (rand, d))\n    | 3 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 4 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 5 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 6 -> buildSquare ((build (rand, d)), (build (rand, d)))\n    | _ -> buildExponential ((build (rand, d)), (build (rand, d)))\n  else\n    (let rr = rand (1, 8) in\n     match rr with | 6 -> buildX () | 8 -> buildY () | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildExponential (e1,e2) = Exponential (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (1, 7) in\n  let d = depth - 1 in\n  if d != 0\n  then\n    match r with\n    | 1 -> buildSine (build (rand, d))\n    | 2 -> buildCosine (build (rand, d))\n    | 3 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 4 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 5 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n    | 6 -> buildSquare (build (rand, d))\n    | _ -> buildExponential ((build (rand, d)), (build (rand, d)))\n  else\n    (let rr = rand (1, 8) in\n     match rr with | 6 -> buildX () | 8 -> buildY () | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 2624, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      (eval (i1, x, y)) < ((eval (i2, x, y) ?eval (i3, x, y)) ::\n        (eval (i4, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2625, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2626, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> (eval (i1, x, y)) +. ((eval (i2, x, y)) / 2)\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2627, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2628, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) ** (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2629, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) ** (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2630, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) **. (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Square i -> (eval (i, x, y)) *. (eval (i, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) ** (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2631, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Cubic (i1,i2,i3) ->\n      ((eval (i1, x, y)) *. (eval (i2, x, y))) *. (eval (i3, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) ** (eval (i2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cubic of expr* expr* expr\n  | Exponential of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | Cubic (i1,i2,i3) ->\n      ((eval (i1, x, y)) *. (eval (i2, x, y))) *. (eval (i3, x, y))\n  | Exponential (i1,i2) -> (eval (i1, x, y)) ** (eval (i2, x, y));;\n"}
{"hw": "hw2", "index": 2632, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine i -> \"sin\" ^ i;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (exprToString i);;\n"}
{"hw": "hw2", "index": 2633, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (exprToString i)\n  | Cosine i -> \"cos\" ^ (exprToString i)\n  | Average (i1,i2) -> ((exprToString i1) + (exprToString i2)) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Cosine i -> \"cos\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\" * \" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\" : \" ^ ((exprToString i3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2634, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (exprToString i)\n  | Cosine i -> \"cos\" ^ (exprToString i)\n  | (Average i1,i2) -> ((exprToString i1) + (exprToString i2)) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Cosine i -> \"cos\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\" * \" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\" : \" ^ ((exprToString i3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2635, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Cosine i -> \"cos\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ (exprToString i2 \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\" * \" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\" : \" ^ ((exprToString i3) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Cosine i -> \"cos\" ^ (\"(pi*\" ^ ((exprToString i) ^ \")\"))\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\" * \" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\" : \" ^ ((exprToString i3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2636, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i1 -> exprToString i1 \"*\" exprToString i1\n  | Exponential (i1,i2) -> exprToString i1 \"*\" exprToString i2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i -> (exprToString i) ^ (\"*\" ^ (exprToString i))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2637, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i1 -> exprToString i1 \"*\" exprToString i1\n  | Exponential (i1,i2) -> exprToString i1 \"*\" exprToString i2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i -> (exprToString i) ^ (\"*\" ^ (exprToString i))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2638, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i -> exprToString i \"*\" exprToString i\n  | Exponential (i1,i2) -> exprToString i1 \"*\" exprToString i2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i -> (exprToString i) ^ (\"*\" ^ (exprToString i))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2639, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square (i1,i2) -> exprToString i1 \"*\" exprToString i2\n  | Exponential (i1,i2) -> exprToString i1 \"^\" exprToString i2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Square i -> (exprToString i) ^ (\"*\" ^ (exprToString i))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2640, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Cubic (i1,i2,i3) ->\n      (exprToString i1) ^\n        (\"*\" ^ ((exprToString i2) ^ (\"*\" ^ (exprToString i3))))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cubic of expr* expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Cubic (i1,i2,i3) ->\n      (exprToString i1) ^\n        (\"*\" ^ ((exprToString i2) ^ (\"*\" ^ (exprToString i3))))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2641, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Cubic (i1,i2,i3) ->\n      (exprToString i1) ^\n        (\"*\" ^ ((exprToString i2) ^ (\"*\" ^ (exprToString i3))))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cubic of expr* expr* expr\n  | Exponential of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine i -> \"sin(pi*\" ^ ((exprToString i) ^ \")\")\n  | Cosine i -> \"cos(pi*\" ^ ((exprToString i) ^ \")\")\n  | Average (i1,i2) ->\n      \"((\" ^ ((exprToString i1) ^ (\" + \" ^ ((exprToString i2) ^ \")/2)\")))\n  | Times (i1,i2) -> (exprToString i1) ^ (\"*\" ^ (exprToString i2))\n  | Thresh (i1,i2,i3,i4) ->\n      \"(\" ^\n        ((exprToString i1) ^\n           (\"<\" ^\n              ((exprToString i2) ^\n                 (\" ? \" ^\n                    ((exprToString i3) ^ (\":\" ^ ((exprToString i4) ^ \")\")))))))\n  | Cubic (i1,i2,i3) ->\n      (exprToString i1) ^\n        (\"*\" ^ ((exprToString i2) ^ (\"*\" ^ (exprToString i3))))\n  | Exponential (i1,i2) -> (exprToString i1) ^ (\"^\" ^ (exprToString i2));;\n"}
{"hw": "hw2", "index": 2642, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) =\n  let x = wwhile (f b) in if x = b then fixpoint (f, x) else x;;\n\nlet rec wwhile (f,b) =\n  let z = f b in\n  match z with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  let x = wwhile (f b) in if x = b then b else fixpoint (f, x);;\n\nlet fixpoint (f,b) =\n  let x = wwhile (f b) in match x with | b -> b | _ -> fixpoint (f, x);;\n\nlet rec wwhile (f,b) =\n  let z = f b in\n  match z with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  let x = wwhile (f, b) in if x = b then b else fixpoint (f, x);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let z = f b in\n  match z with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = let x b = ((f b), (b != (f b))) in wwhile (x, b);;\n"}
{"hw": "hw2", "index": 2643, "problem": "fixpoint", "bad": "\nlet notEqual x y = (x = y) = false;;\n\nlet fixpoint (f,b) =\n  let newFunc b = ((f b), (notEqual b f b)) in wwhile (newFunc, b);;\n", "fix": "\nlet notEqual x y = (x = y) = false;;\n\nlet rec wwhile (f,b) =\n  let z = f b in\n  match z with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  let newFunc b = ((f b), (notEqual b (f b))) in wwhile (newFunc, b);;\n"}
{"hw": "hw2", "index": 2644, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2645, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem seen h) then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2646, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem seen h) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2647, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = f b in match x with | h::t -> if t then wwhile (f, h) else h;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let x = f b in\n  match x with | (x,y) -> if y = false then x else wwhile (f, x);;\n"}
{"hw": "hw2", "index": 2648, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = f b in match x with | h::t -> if t = true then wwhile (f, h) else h;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let x = f b in\n  match x with | (x,y) -> if y = false then x else wwhile (f, x);;\n"}
{"hw": "hw2", "index": 2649, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let x = f b in\n  match x with | h::t -> if t = false then h else wwhile (f, h);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let x = f b in\n  match x with | (x,y) -> if y = false then x else wwhile (f, x);;\n"}
{"hw": "hw2", "index": 2650, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (a,b) = h in if a = k then b else assoc t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (a,b) = h in if a = k then b else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 2651, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (a,b) = h in if a = k then b else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (a,b) = h in if a = k then b else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 2652, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2653, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2654, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2655, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2656, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" exprToString a \")\"\n  | Cosine a -> \"cos(pi*\" exprToString a \")\"\n  | Average (a,b) -> \"((\" exprToString a \"+\" exprToString b \")/2)\"\n  | Times (a,b) -> exprToString a \"*\" exprToString b\n  | Thresh (a,b,c,d) ->\n      \"(\" exprToString a \"<\" exprToString b \"?\" exprToString c \":\"\n        exprToString d \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2657, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" exprToString a \")\"\n  | Average (a,b) -> \"((\" exprToString a \"+\" exprToString b \")/2)\"\n  | Times (a,b) -> exprToString a \"*\" exprToString b\n  | Thresh (a,b,c,d) ->\n      \"(\" exprToString a \"<\" exprToString b \"?\" exprToString c \":\"\n        exprToString d \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2658, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let g b = (f, ((f b) = b)) in g), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let calcfx = f x in (calcfx, (calcfx = x)) in (g, b));;\n"}
{"hw": "hw2", "index": 2659, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let calcfx = f x in (calcfx, (calcfx = x)) in ((g b), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let calcfx = f x in (calcfx, (calcfx = x)) in (g, b));;\n"}
{"hw": "hw2", "index": 2660, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g x = let calcfx = f x in (calcfx, (calcfx = x)) in (((g x), x), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let calcfx = f x in (calcfx, (calcfx = x)) in (g, b));;\n"}
{"hw": "hw2", "index": 2661, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun f  -> fun x  -> x = (f x)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> ((f b), (b = (f b)))), b);;\n"}
{"hw": "hw2", "index": 2662, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun f  -> b = (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> ((f b), (b = (f b)))), b);;\n"}
{"hw": "hw2", "index": 2663, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> b = (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (x,y) = f b in if y then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> ((f b), (b = (f b)))), b);;\n"}
{"hw": "hw2", "index": 2664, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2665, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen :: h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 2666, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec counter c =\n    if n < 10\n    then c\n    else counter (c + 1) additivePersistence (sumList (digits n)) in\n  counter 0 n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw3", "index": 2667, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2668, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x @ a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2669, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2670, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [x + a] in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2671, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [x] @ a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2672, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] | h::t -> [h + x] @ t in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2673, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] | h::t -> [h + x] @ t in\n    let base = () in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2674, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> if (h + x) > 10 then [h + (x mod 10)] @ a else [h + x] in\n    let base = ([], []) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2675, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> if (h + x) > 10 then [h + (x mod 10)] @ a else [h + x] @ a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2676, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> if (h + x) > 10 then [h + (x mod 10)] @ a else [h + x] @ a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2677, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t -> if (h + x) > 10 then [h + (x mod 10)] @ a else [h + x] @ a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2678, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x @ a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2679, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2680, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2681, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = (l1, l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = [] in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2682, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in let args = l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2683, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2684, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = 0 in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2685, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet rec addHelper (t,u) =\n  match List.rev t with\n  | [] -> []\n  | h::t ->\n      (match List.rev u with\n       | [] -> []\n       | h'::t' ->\n           if (h + h') > 10\n           then (addHelper (t, t')) @ [(1 + h') + h]\n           else (addHelper (t, t')) @ [h' + h]);;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = addHelper (a, x) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2686, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2687, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry y = y / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((remain car) + x1) + x2]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((carry h) + x1) + x2] @\n                           ([((remain h) + x1) + x2] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2688, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry x y = (x * y) / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [remain ((car + x1) + x2)]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([carry ((h + x1) + x2)] @\n                           ([remain ((h + x1) + x2)] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [remain ((car + x1) + x2)]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2689, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet carry x y = (x * y) / 10;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [remain ((car + x1) + x2)]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([carry ((h + x1) + x2)] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet remain x = x mod 10;;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [remain ((car + x1) + x2)]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2690, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> x | _ -> x :: (clone x (n - 1));;\n", "fix": "\nlet rec clone x n =\n  let x' = abs n in if x' > 0 then [x] @ (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 2691, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> x | _ -> (clone x (n - 1)) :: x;;\n", "fix": "\nlet rec clone x n =\n  let x' = abs n in if x' > 0 then [x] @ (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 2692, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone x (n - 1)) :: x;;\n", "fix": "\nlet rec clone x n =\n  let x' = abs n in if x' > 0 then [x] @ (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 2693, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then x else [clone x (n - 1)];;\n", "fix": "\nlet rec clone x n =\n  let x' = abs n in if x' > 0 then [x] @ (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 2694, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then x else x :: (clone x (n - 1));;\n", "fix": "\nlet rec clone x n =\n  let x' = abs n in if x' > 0 then [x] @ (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 2695, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [remainder i t] @ (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [remainder i h] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2696, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> [remainder h i] @ (((i * l) / 10) + (mulByDigit i t)));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> (remainder h i) :: (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 2697, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> [remainder h i] @ (((i * h) / 10) + (mulByDigit i t)));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> (remainder h i) :: (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 2698, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> i * h\n       | _ -> [remainder h i] @ (((i * h) / 10) + (mulByDigit i t)));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> (remainder h i) :: (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 2699, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> [remainder h i] @ ([(i * h) / 10] + (mulByDigit i t)));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match List.length t with\n       | 1 -> [i * h]\n       | _ -> (remainder h i) :: (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 2700, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet y = [1; 2; 3];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then h * i\n      else (remainder h y) @ (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else [remainder i h] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2701, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet y = [1; 2; 3];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then (h * i) @ (mulByDigit i t)\n      else (remainder h y) @ (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else [remainder i h] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2702, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet y = [1; 2; 3];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else (remainder h y) @ (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else [remainder i h] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2703, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else (remainder i h) @ (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else [remainder i h] @ (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2704, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else [remainder i h] :: (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else (remainder i h) :: (mulByDigit i t);;\n"}
{"hw": "hw3", "index": 2705, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match i with\n  | i -> []\n  | h::t ->\n      if (List.length t) = 0\n      then [h * i] @ (mulByDigit i t)\n      else (remainder i h) :: (mulByDigit i t);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  match i with\n  | i -> []\n  | _ ->\n      (match l with\n       | [] -> []\n       | h::t ->\n           if (List.length t) = 0\n           then [h * i] @ (mulByDigit i t)\n           else (remainder i h) :: (mulByDigit i t));;\n"}
{"hw": "hw3", "index": 2706, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t -> [(mulByDigit i t) + (carry h i)] @ [remainder i t]);;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [remainder i h]\n          | h'::t' -> [h' * i] @ (mulByDigit i t')));;\n"}
{"hw": "hw3", "index": 2707, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [remainder i h]\n          | h'::t' -> (h' * i) @ (mulByDigit i t')));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [remainder i h]\n          | h'::t' -> [h' * i] @ (mulByDigit i t')));;\n"}
{"hw": "hw3", "index": 2708, "problem": "mulByDigit", "bad": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [remainder i h]\n          | h'::t' -> [h' * i] @ [(remainder h) * i]));;\n", "fix": "\nlet remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> [remainder i h]\n          | h'::t' -> [h' * i] @ [remainder h i]));;\n"}
{"hw": "hw3", "index": 2709, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> if (i * h) > 10 then [carry i h] @ [remainder i h]\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(remainder h' i) + (carry h i)] @ [remainder h i])));;\n", "fix": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] ->\n              if (i * h) > 10\n              then [carry i h] @ [remainder i h]\n              else [remainder i h]\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(remainder h' i) + (carry h i)] @ [remainder h i])));;\n"}
{"hw": "hw3", "index": 2710, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] ->\n              if (i * h) > 10 then [carry i h] @ [remainder i h] else i * h\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(remainder h' i) + (carry h i)] @ [remainder h i])));;\n", "fix": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] ->\n              if (i * h) > 10 then [carry i h] @ [remainder i h] else [i * h]\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(remainder h' i) + (carry h i)] @ [remainder h i])));;\n"}
{"hw": "hw3", "index": 2711, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> if (i * h) > 10 then [carry i h] @ [remainder i h] else []\n          | h'::t' ->\n              let multNext x = match x with | [] -> 0 | h1::t1 -> h1 in\n              if (i * h) > 10\n              then\n                (mulByDigit i t') @\n                  ([(carry i h') + (remainder h' i)] @ [remainder h i])\n              else i * h));;\n", "fix": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> if (i * h) > 10 then [carry i h] @ [remainder i h] else []\n          | h'::t' ->\n              let multNext x = match x with | [] -> 0 | h1::t1 -> h1 in\n              if (i * h) > 10\n              then\n                (mulByDigit i t') @\n                  ([(carry i h') + (remainder h' i)] @ [remainder h i])\n              else [i * h]));;\n"}
{"hw": "hw3", "index": 2712, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> if (i * h) > 10 then [carry i h] @ [remainder i h] else []\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(carry i h) + (remainder h' i)] @\n                   [(remainder h i) + (carry i)])));;\n", "fix": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> if (i * h) > 10 then [carry i h] @ [remainder i h] else []\n          | h'::t' ->\n              (mulByDigit i t') @\n                ([(carry i h) + (remainder h' i)] @ [remainder h i])));;\n"}
{"hw": "hw3", "index": 2713, "problem": "mulByDigit", "bad": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> []\n          | h'::t' ->\n              if (List.length t') > 0\n              then mulByDigit @ [(carry h i) + (remainder h' i)]\n              else [remainder h i]));;\n", "fix": "\nlet carry x y = (x * y) / 10;;\n\nlet remainder x y = (x * y) mod 10;;\n\nlet rec mulByDigit i l =\n  if (i = 0) || (i > 9)\n  then []\n  else\n    (match List.rev l with\n     | [] -> []\n     | h::t ->\n         (match t with\n          | [] -> []\n          | h'::t' ->\n              if (List.length t') > 0\n              then (mulByDigit i t) @ [(carry h i) + (remainder h' i)]\n              else [remainder h i]));;\n"}
{"hw": "hw3", "index": 2714, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (((mulByDigit i) - (1 l)) l);;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 2715, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd ((mulByDigit (i - 1) l) l);;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 2716, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd ((mulByDigit ((i - 1) l)) l);;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (car,cur) ->\n               (match cur with\n                | [] ->\n                    if ((car + x1) + x2) > 10\n                    then\n                      ((car + 1), ([car + 1] @ [((car + x1) + x2) mod 10]))\n                    else (0, ([car] @ [(car + x1) + x2]))\n                | h::t ->\n                    if ((x1 + x2) + h) < 10\n                    then (0, ([0] @ ([(x1 + x2) + h] @ t)))\n                    else\n                      ((car + 1),\n                        ([((h + x1) + x2) / 10] @\n                           ([((h + x1) + x2) mod 10] @ t))))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 2717, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (clone 0 (len1 - l2)) @ l2\n  else (clone 0 (len2 - len1)) @ l1;;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2718, "problem": "padZero", "bad": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, (clone 0 (len1 - len2))) @ l2\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n > 0 then [x] @ (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2719, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x :: a in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2720, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2721, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2722, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2723, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2724, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2725, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2726, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2727, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2728, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2729, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2730, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2731, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2732, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2733, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2734, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2735, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2736, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2737, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2738, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2739, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2740, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2741, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2742, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2743, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2744, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2745, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2746, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (fun x  -> x) in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2747, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2748, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2749, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2750, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2751, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2752, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2753, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2754, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2755, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2756, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2757, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2758, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2759, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2760, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2761, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (fun x  -> x) in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2762, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base f = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2763, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2764, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2765, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2766, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2767, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x = x a in let base f = f fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2768, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2769, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2770, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2771, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base f = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2772, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base f a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x t u = u in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2773, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = t :: h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = h :: t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2774, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 2775, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 2776, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 2777, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 2778, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" List.map l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 2779, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \" \" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2780, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \" \";;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2781, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2782, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2783, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = f (sepConcat (List.map l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2784, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2785, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2786, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (\"[\" sepConcat \"\" (List.map f l)) ^ \"]\";;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \" \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2787, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = a in\n      let (o,p) = x in\n      let z = (o + p) + m in\n      if z > 9 then (1, ((z - 10) :: n)) else (0, (z :: n)) in\n    let base = (0, []) in\n    let args =\n      let rec helper curList lt1 lt2 =\n        match lt1 with\n        | [] -> curList\n        | h::t -> helper ((h, (List.hd lt2)) :: curList) t (List.tl lt2) in\n      helper [] l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2788, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = a in\n      let (o,p) = x in\n      let z = (o + p) + m in\n      if z > 9 then (1, ((z - 10) :: n)) else (0, (z :: n)) in\n    let base = (0, []) in\n    let args =\n      let rec helper curList lt1 lt2 =\n        match lt1 with\n        | [] -> curList\n        | h::t -> helper ((h, (List.hd lt2)) :: curList) t (List.tl lt2) in\n      helper [] l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2789, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet rec helper curList lt1 lt2 =\n  match lt1 with\n  | [] -> curList\n  | h::t -> helper ((h, (List.hd lt2)) :: curList) t (List.tl lt2);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (m,n) = a in let (o,p) = x in ((m + o), (n + p)) in\n    let base = (0, 0) in\n    let args = helper [] l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::y -> if x = 0 then removeZero y else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (m,n) = a in\n      let (o,p) = x in\n      let z = (o + p) + m in\n      if z > 9 then (1, ((z - 10) :: n)) else (0, (z :: n)) in\n    let base = (0, []) in\n    let args =\n      let rec helper curList lt1 lt2 =\n        match lt1 with\n        | [] -> curList\n        | h::t -> helper ((h, (List.hd lt2)) :: curList) t (List.tl lt2) in\n      helper [] l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2790, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y then ((clone 0 (y - x)), y) else (x, (clone 0 (x - y)));;\n", "fix": "\nlet rec clone x n =\n  if n <= 0 then [] else (let y = clone x (n - 1) in x :: y);;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x < y\n  then (((clone 0 (y - x)) @ l1), l2)\n  else (l1, ((clone 0 (x - y)) @ l2));;\n"}
{"hw": "hw3", "index": 2791, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2792, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2793, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match fs with | x::y -> x in\n  let base = [fs] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2794, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match fs with | x::y -> x in\n  let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2795, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match fs with | x::y -> x in\n  let base = f [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2796, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match fs with | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2797, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2798, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2799, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x a in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2800, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2801, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2802, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2803, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2804, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let x = x in x a in let base y = y in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x (pipe fs) in let base y = y in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x (pipe List.hd fs) in\n  let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2805, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2806, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2807, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_right f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2808, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2809, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2810, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = match h with | h::[] -> h in\n      let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2811, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw1", "index": 2812, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n = (if n > 0 then 0 : int);;\n", "fix": "\nlet rec additivePersistence n = (if n > 0 then 0 else 0 : int);;\n"}
{"hw": "hw1", "index": 2813, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n xs =\n  (match n with | 0 -> xs | h::t -> xs :: ((n % (10 digitsOfInt n)) / 10) : \n  int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2814, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then n else (n % 10) :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2815, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [n % 10] :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2816, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else [n % 10] :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2817, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else [n mod 10] :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2818, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : int list);;\n"}
{"hw": "hw1", "index": 2819, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (digitsOfInt (n / 10)) :: (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2820, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else [digitsOfInt (n / 10)] :: (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2821, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (digitsOfInt (n / 10)) @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2822, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then n else (n % 10) :: ((digitsOfInt n) / 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2823, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10)] @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2824, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2825, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10); n mod 10] : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2826, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10)] @ [n mod 10] : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2827, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10)] @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2828, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2829, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then n else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2830, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10)] @ [n mod 10] : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else digitsOfInt (n / 10) : int list);;\n"}
{"hw": "hw1", "index": 2831, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else [digitsOfInt (n / 10)] @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else digitsOfInt (n / 10) : int list);;\n"}
{"hw": "hw1", "index": 2832, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ (n mod 10) : int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n > 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10] : int list);;\n"}
{"hw": "hw1", "index": 2833, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 0\n   then []\n   else if n < 10 then [n] else (digitsOfInt (n / 10)) @ (n mod 10) : \n  int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 0\n   then []\n   else if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10)) : \n  int list);;\n"}
{"hw": "hw1", "index": 2834, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  (if n < 0\n   then []\n   else if n < 10 then [n] else (n mod 10) @ (digitsOfInt (n / 10)) : \n  int list);;\n", "fix": "\nlet rec digitsOfInt n =\n  (if n < 10 then [n] else digitsOfInt (n / 10) : int list);;\n"}
{"hw": "hw1", "index": 2835, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  (match l with | [] -> [] | h::t -> (listReverse t) @ h : list);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2836, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  (match l with | [] -> [] | h::t -> (listReverse t) :: h : int list);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2837, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  (match l with | [] -> [] | h::t -> [listReverse t] @ h : int list);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2838, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  (match xs with | [] -> 0 | h::t -> xs + (sumList n) : int);;\n", "fix": "\nlet rec sumList xs =\n  (match xs with | [] -> 0 | h::t -> h + (sumList t) : int);;\n"}
{"hw": "hw2", "index": 2839, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine q -> sin (pi *. q)\n  | buildCosine -> cos (pi *. e)\n  | buildAverage -> (e1 +. e2) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2840, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e -> sin (pi *. e)\n  | buildCosine -> cos (pi *. e)\n  | buildAverage -> (e1 +. e2) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2841, "problem": "eval", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | buildSine -> sin (pi *. (eval e))\n  | buildCosine -> cos (pi *. e)\n  | buildAverage -> (e1 +. e2) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2842, "problem": "eval", "bad": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | buildSine -> sin (pi *. (eval e x y))\n  | buildCosine -> cos (pi *. e)\n  | buildAverage -> (e1 +. e2) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2843, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> (e1 +. e2) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2844, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | buildTimes -> e1 *. e2\n  | buildThresh -> if a < b then a_less else b_less;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2845, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Abs v -> abs (eval (v, x, y))\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval ((c * (-1)), x, y)\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mid of expr* expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Mid (p,q) ->\n      let diff =\n        if ((eval (p, x, y)) -. (eval (q, x, y))) < 0.0\n        then (eval (p, x, y)) -. ((eval (q, x, y)) *. (-1.0))\n        else (eval (p, x, y)) -. (eval (q, x, y)) in\n      diff /. 2.0\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then (eval (c, x, y)) *. (-1.0)\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 2846, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Abs v ->\n      if (eval (v, x, y)) < 0\n      then (eval (v, x, y)) *. (-1)\n      else eval (v, x, y)\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval ((c *. (-1)), x, y)\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mid of expr* expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Mid (p,q) ->\n      let diff =\n        if ((eval (p, x, y)) -. (eval (q, x, y))) < 0.0\n        then (eval (p, x, y)) -. ((eval (q, x, y)) *. (-1.0))\n        else (eval (p, x, y)) -. (eval (q, x, y)) in\n      diff /. 2.0\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then (eval (c, x, y)) *. (-1.0)\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 2847, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Abs v ->\n      if (eval (v, x, y)) < 0.0\n      then (eval (v, x, y)) *. (-1)\n      else eval (v, x, y)\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval ((c *. (-1)), x, y)\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mid of expr* expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Mid (p,q) ->\n      let diff =\n        if ((eval (p, x, y)) -. (eval (q, x, y))) < 0.0\n        then (eval (p, x, y)) -. ((eval (q, x, y)) *. (-1.0))\n        else (eval (p, x, y)) -. (eval (q, x, y)) in\n      diff /. 2.0\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then (eval (c, x, y)) *. (-1.0)\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 2848, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Abs v ->\n      if (eval (v, x, y)) < 0.0\n      then (eval (v, x, y)) *. (-1.0)\n      else eval (v, x, y)\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval ((c *. (-1)), x, y)\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mid of expr* expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Mid (p,q) ->\n      let diff =\n        if ((eval (p, x, y)) -. (eval (q, x, y))) < 0.0\n        then (eval (p, x, y)) -. ((eval (q, x, y)) *. (-1.0))\n        else (eval (p, x, y)) -. (eval (q, x, y)) in\n      diff /. 2.0\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then (eval (c, x, y)) *. (-1.0)\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 2849, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Abs v ->\n      if (eval (v, x, y)) < 0.0\n      then (eval (v, x, y)) *. (-1.0)\n      else eval (v, x, y)\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval ((c *. (-1.0)), x, y)\n      else eval (c, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Mid of expr* expr\n  | Flip of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine q -> sin (pi *. (eval (q, x, y)))\n  | Cosine q -> cos (pi *. (eval (q, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Mid (p,q) ->\n      let diff =\n        if ((eval (p, x, y)) -. (eval (q, x, y))) < 0.0\n        then (eval (p, x, y)) -. ((eval (q, x, y)) *. (-1.0))\n        else (eval (p, x, y)) -. (eval (q, x, y)) in\n      diff /. 2.0\n  | Flip (a,b,c) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then (eval (c, x, y)) *. (-1.0)\n      else eval (c, x, y);;\n"}
{"hw": "hw2", "index": 2850, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine  -> \"Sine(\" ^ ((exprToString e) ^ \")\")\n  | Cosine  -> \"Cosine(\" ^ ((exprToString e) ^ \")\")\n  | Average  -> \"Average(\" ^ ((exprToString e) ^ \")\")\n  | Times  -> \"Times(\" ^ ((exprToString e) ^ \")\")\n  | Thresh (a,b,c,d) ->\n      \"Thresh(\" ^\n        ((exprToString a) ^\n           (\",\" ^\n              ((exprToString b) ^\n                 (\",\" ^ ((exprToString c) ^ (\",\" ^ ((exprToString d) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine m -> \"Sine(\" ^ ((exprToString m) ^ \")\")\n  | Cosine n -> \"Cosine(\" ^ ((exprToString n) ^ \")\")\n  | Average (h,k) ->\n      \"Average(\" ^ ((exprToString h) ^ (\",\" ^ ((exprToString k) ^ \")\")))\n  | Times (x,y) ->\n      \"Times(\" ^ ((exprToString x) ^ (\",\" ^ ((exprToString y) ^ \")\")))\n  | Thresh (a,b,c,d) ->\n      \"Thresh(\" ^\n        ((exprToString a) ^\n           (\",\" ^\n              ((exprToString b) ^\n                 (\",\" ^ ((exprToString c) ^ (\",\" ^ ((exprToString d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2851, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, (b != (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2852, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2853, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, (f == b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2854, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2855, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (true, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2856, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, true, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw2", "index": 2857, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, (b, (b != (f b))));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let pair = f b in\n  let (b',c') = pair in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (x != (f x)))), b);;\n"}
{"hw": "hw3", "index": 2858, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = List.rev l1 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2859, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [((List.hd l1) + (List.hd l2)) mod 10] in\n    let base = List.rev l1 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2860, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2861, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = 0 in\n    let args = ((List.tl l1), (List.tl l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2862, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = 0 in\n    let args = (List.hd l1) + (List.hd l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2863, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = 0 in\n    let args = ((List.hd l1) + (List.hd l2)) / 10 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2864, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2865, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((List.hd l1) + (List.hd l2)) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2866, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | (r,s) -> (((List.hd r) + (List.hd s)) mod 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2867, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | (r,s) -> [r] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2868, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> h in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2869, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (1,2) -> 3 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2870, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (1,2) -> [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2871, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (1,2) -> [1] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2872, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 2::[] -> [1] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2873, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h::t)::[] -> h in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2874, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (first,second) -> 1 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2875, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (first,second) -> [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2876, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (first,second) -> ([], []) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2877, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (first,second) -> ([2], [1]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2878, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (fst x) + (snd x) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2879, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let b = (fst x) + (snd x) in [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2880, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2881, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = match x with | _ -> (-1) | (first,second) -> first + second in\n      (sum / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2882, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = match x with | _ -> (-1) | (first,second) -> first + second in\n      match a with | h::t -> [(h + sum) / 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2883, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let b = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n      | _ -> [b / 10; b mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2884, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x a in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x a in\n  let base = [] in\n  let args = List.rev l1 in\n  let (_,res) = (0, (List.fold_left f base args)) in res;;\n"}
{"hw": "hw3", "index": 2885, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x a in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x a in\n  let base = [] in\n  let args = List.rev l1 in\n  let (_,res) = (0, (List.fold_left f base args)) in res;;\n"}
{"hw": "hw3", "index": 2886, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (mulByDigit x a)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (0,res) = a in (0, (mulByDigit x res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2887, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = mulByDigit x a in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (0,res) = a in (0, (mulByDigit x res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2888, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (mulByDigit a x)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (0,res) = a in (0, (mulByDigit x res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2889, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (0,res) = a in (0, (mulByDigit x a)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (0,res) = a in (0, (mulByDigit x res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2890, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (res + (mulByDigit x l2)))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (mulByDigit x res))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2891, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (res + (mulByDigit l2 a)))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (mulByDigit x res))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2892, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (res + (mulByDigit x res)))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,res) = a in\n    if place <= 0\n    then ((place + 1), (mulByDigit x res))\n    else ((place + 1), (mulByDigit ((x * 10) * place) res)) in\n  let base = (0, []) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2893, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [x] else List.append [x] ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n = 1 then [x] else List.append [x] (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2894, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [0] else bigAdd l ((mulByDigit i) - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2895, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then l else bigAdd l ((mulByDigit i) - (1 l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else List.append [x] (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x = List.length l1 in\n  let y = List.length l2 in\n  if x > y\n  then (l1, (List.append (clone 0 (x - y)) l2))\n  else if x < y then ((List.append (clone 0 (y - x)) l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (lh1,lh2) = x in\n      let (carry,res) = a in\n      let num = (lh1 + lh2) + carry in ((num / 10), ((num mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then l else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2896, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | h::t -> h in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2897, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun x  -> a) | h::t -> h in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2898, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun d  -> a) | h::t -> h in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2899, "problem": "pipe", "bad": "\nlet pipe fs num =\n  let f a x = match x with | [] -> (fun d  -> a) | h::t -> h in\n  let base = num in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2900, "problem": "pipe", "bad": "\nlet pipe fs = let f a x d = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2901, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base i = i in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2902, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = h ^ (sepConcat sep t) in\n      let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a in\n      let base = if (List.length t) <> 0 then \"\" else sep in\n      let l = if (List.length t) <> 0 then t else [] in\n      List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2903, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = if (List.length t) <> 0 then t else [] in\n      let l = if (List.length t) <> 0 then \"\" else sep in\n      List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = if (List.length t) <> 0 then \"\" else sep in\n      let l = if (List.length t) <> 0 then t else [] in\n      List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2904, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = if (List.length t) <> 0 then \"\" else sep in\n      let l = if (List.length t) <> 0 then t else h in\n      List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = if (List.length t) <> 0 then \"\" else sep in\n      let l = if (List.length t) <> 0 then t else [h] in\n      List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2905, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> a | hd::tl -> a ^ (sep ^ hd) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2906, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> x | hd::tl -> a ^ (sep ^ hd) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2907, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> \"none\" | hea::tail -> a ^ (sep ^ hea) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> \"none\" | hea::tail -> a ^ (sep ^ hea) in\n      let base = h in let l = [t] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2908, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> x | hea::tail -> a ^ (sep ^ hea) in\n      let base = h in let l = [t] in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match x with | [] -> \"\" | hea::tail -> a ^ (sep ^ hea) in\n      let base = h in let l = [t] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2909, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = [t] in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2910, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in ((f base l foo), bar, baz);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2911, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in ((List.fold_left f base l foo), bar, baz);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2912, "problem": "stringOfList", "bad": "\nlet stringOfList f l = let base = f in List.fold_left f base l;;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2913, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let fx a b = List.append a [f b] in\n  let base = [] in\n  List.fold_left f base l f (f (f (f (f (f (f base 1) 2) 3) 4) 5) 6);;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2914, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let fx a b = List.append b [f a] in\n  let base = [] in\n  List.fold_left f base l f (f (f (f (f (f (f base 1) 2) 3) 4) 5) 6);;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2915, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let fx a b = match b with | [] -> [] | h::t -> List.append a (f b) in\n  let base = \"\" in List.fold_left fx base l;;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2916, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let fx a b = match b with | [] -> \"\" | h::t -> List.append a (f b) in\n  let base = [\"\"] in List.fold_left fx base l;;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2917, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let fx a b = match b with | [] -> \"\" | h::t -> List.append a b in\n  let base = \"\" in List.fold_left fx base l;;\n", "fix": "\nlet stringOfList f l =\n  let fx a b = a ^ b in let base = \"\" in List.fold_left fx base l;;\n"}
{"hw": "hw3", "index": 2918, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \";\" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2919, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \";\" l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2920, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2921, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else [0] :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = ((hd (List.rev l1)), (hd (List.rev l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2922, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2923, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2924, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2925, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2926, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let (j,k) = x in\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2927, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      match a with\n      | [] -> []\n      | h::t ->\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2928, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          (match x with\n           | (j,k) ->\n               if (j + k) > 9\n               then 1 :: (((h + j) + k) - 10) :: t\n               else 0 :: ((h + j) + k) :: t) in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2929, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> []\n      | h::t ->\n          let z = [] in\n          let (j,k) = x in\n          if (j + k) > 9\n          then z @ (1 :: (((h + j) + k) - 10) :: t)\n          else z @ (0 :: ((h + j) + k) :: t) in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2930, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] | h::t -> let (j,k) = x in [0] in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2931, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      match a with\n      | [] -> []\n      | h::t ->\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base [(1, 2); (2, 2)] in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2932, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      match a with\n      | [] -> []\n      | h::t ->\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2933, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      match a with\n      | [] -> []\n      | h::t ->\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2934, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let j = 1 in\n      let k = 2 in\n      match a with\n      | [] -> []\n      | h::t ->\n          if (j + k) > 9\n          then 1 :: (((h + j) + k) - 10) :: t\n          else 0 :: ((h + j) + k) :: t in\n    let base = [0] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2935, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, (((j + k) + l) - 10))\n      else (0, ((j + k) + l)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2936, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if x = ()\n      then (0, (l :: m))\n      else\n        if ((j + k) + l) > 9\n        then (1, ((((j + k) + l) - 10) :: m))\n        else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if x = (0, 0)\n      then (0, (l :: m))\n      else\n        if ((j + k) + l) > 9\n        then (1, ((((j + k) + l) - 10) :: m))\n        else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2937, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if x = []\n      then (0, (l :: m))\n      else\n        if ((j + k) + l) > 9\n        then (1, ((((j + k) + l) - 10) :: m))\n        else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if x = (0, 0)\n      then (0, (l :: m))\n      else\n        if ((j + k) + l) > 9\n        then (1, ((((j + k) + l) - 10) :: m))\n        else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2938, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then x else (let c = x :: x in clone x (n - 1));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2939, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [] @ x else (clone x) :: ((x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2940, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [] @ x else (clone x) :: (([x] n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2941, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [] @ x else (clone [x]) @ ((x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2942, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [] @ x else (clone x) @ ((x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2943, "problem": "clone", "bad": "\nlet rec clone x n = if n = 1 then [] @ x else (clone [x]) :: ((x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2944, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2945, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> 0 | 1 -> l | x -> (mulByDigit i) - (1 (bigAdd l l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (j,k) = x in\n      let (l,m) = a in\n      if ((j + k) + l) > 9\n      then (1, ((((j + k) + l) - 10) :: m))\n      else (0, (((j + k) + l) :: m)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | x -> mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 2946, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (clone 0 (0 - d)) @ (l1 * l2) else (l1 * (clone 0 d)) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n"}
{"hw": "hw3", "index": 2947, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then ((clone 0 (0 - d)) @ l1) * l2 else (l1 * (clone 0 d)) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n"}
{"hw": "hw3", "index": 2948, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1 * (clone 0 d)) @ l2;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let d = (List.length l1) - (List.length l2) in\n  if d < 0 then (((clone 0 (0 - d)) @ l1), l2) else (l1, ((clone 0 d) @ l2));;\n"}
{"hw": "hw3", "index": 2949, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2950, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2951, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2952, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base c = c in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base c = c in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2953, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2954, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (num1,num2) = x in ((a * 10) + num1) + num2 in\n    let base = failwith \"to be implemented\" in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2955, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (num1,num2) = x in ((a * 10) + num1) + num2 in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2956, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (num1,num2) = x in ((a * 10) + num1) + num2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2957, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (num1,num2) = x in (0, (((a * 10) + num1) + num2)) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2958, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in let (p,q) = a in (0, (((a * 10) + num1) + num2)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2959, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (p,q) = a in (((num1 + num2) / 10), ((num1 + num2) mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2960, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in (((num1 + num2) / 10), ((num1 + num2) mod 10))\n        :: a in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2961, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in (((num1 + num2) / 10), ((num1 + num2) mod 10))\n        :: a in\n    let base = [(0, 0)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2962, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      [(((num1 + num2) / 10), ((num1 + num2) mod 10)); a] in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2963, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ([((num1 + num2) + carry) mod 10] ::\n        sum)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2964, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      if ((num1 + num2) + carry) >= 10\n      then 1\n      else (0, ((((num1 + num2) + carry) mod 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2965, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (bigAdd a) :: (0 (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2966, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a :: 0] (mulByDigit x l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2967, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a :: 0] (mulByDigit x l1) in\n  let base = 0 in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2968, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (bigAdd a) :: (0 (mulByDigit x l1)) in\n  let base = 0 in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2969, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a :: 0] [mulByDigit x l1] in\n  let base = 0 in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2970, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a :: 0] [mulByDigit x l1] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2971, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (bigAdd a) :: (0 (mulByDigit x l1)) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2972, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = (bigAdd a) :: ([0] (mulByDigit x l1)) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2973, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (a :: 0) (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2974, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2975, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit [x] l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2976, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = 0 in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2977, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] mulByDigit x l1 in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2978, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = ((bigAdd [a; 0]), (mulByDigit x l1)) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2979, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = 0 in let args = l2 in List.fold_left f 0 args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2980, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = 0 in let args = l2 in List.fold_left f [] args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2981, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = [bigAdd [a; 0] (mulByDigit x l1)] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2982, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = [] in let args = l2 in [List.fold_left f base args];;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2983, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left [f] base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2984, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let afactor = a :: 0 in bigAdd afactor (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2985, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let afactor = [a; 0] in bigAdd afactor (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2986, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = [[bigAdd [a; 0] (mulByDigit x l1)]] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2987, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [[a]; 0] (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2988, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd ([a] ^ [0]) (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2989, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a; 0] (mulByDigit x l1) in\n  let base = [] in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2990, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (num1,num2) = x in\n      let (carry,sum) = a in\n      ((((num1 + num2) + carry) / 10), ((((num1 + num2) + carry) mod 10) ::\n        sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (c,res) = List.fold_left f base args in c :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then [] else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd [a] (mulByDigit x l1) in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2991, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = [a; 0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2992, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = [[a]; 0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2993, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = [a] :: 0 in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2994, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = a :: 0 in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2995, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = a @ 0 in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = a @ [0] in\n  let base = [] in let args = l2 in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2996, "problem": "clone", "bad": "\nlet rec clone x n = if n = 0 then [] else [x] :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2997, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2998, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2999, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3000, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3001, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3002, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3003, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a = x x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a = x (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3004, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a + x) ^ 2 in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3005, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw1", "index": 3006, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then ((digitsOfInt n) mod 10) :: numL else numL;;\n", "fix": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then (n mod 10) :: numL else numL;;\n"}
{"hw": "hw1", "index": 3007, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then ((digitsOfInt n) mod 10) :: numL else numL;;\n", "fix": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then (n mod 10) :: (digitsOfInt n) else numL;;\n"}
{"hw": "hw1", "index": 3008, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;\n", "fix": "\nlet rec digitsOfInt n =\n  let numL = [] in if n > 0 then (n mod 10) :: (digitsOfInt n) else numL;;\n"}
{"hw": "hw1", "index": 3009, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let numL = [] in\n  if (n / 10) > 0\n  then ((n mod 10) :: numL) && ((digitsOfInt n) / 10)\n  else numL;;\n", "fix": "\nlet rec digitsOfIntHelper (num,numList) =\n  if num < 10\n  then num :: numList\n  else digitsOfIntHelper ((num / 10), ((num mod 10) :: numList));;\n\nlet rec digitsOfInt n = if n < 10 then [n] else digitsOfIntHelper (n, []);;\n"}
{"hw": "hw1", "index": 3010, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let sumL = [] in if (n / 10) > 0 then (n mod 10) :: sumL;;\n", "fix": "\nlet rec digitsOfIntHelper (num,numList) =\n  if num < 10\n  then num :: numList\n  else digitsOfIntHelper ((num / 10), ((num mod 10) :: numList));;\n\nlet rec digitsOfInt n = if n < 10 then [n] else digitsOfIntHelper (n, []);;\n"}
{"hw": "hw1", "index": 3011, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let rec listReverseHelper l =\n    match l with | [] -> l | h::t -> listReverseHelper (h :: l) t in\n  listReverseHelper [] l;;\n", "fix": "\nlet rec listReverse l =\n  let rec listReverseHelper l =\n    function | [] -> l | h::t -> listReverseHelper (h :: l) t in\n  listReverseHelper [] l;;\n"}
{"hw": "hw2", "index": 3012, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = if depth > 0 then rand (2, 6) else rand (0, 1) in\n  match r with\n  | 0 -> buildX\n  | 1 -> buildY\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = if depth > 0 then rand (2, 6) else rand (0, 1) in\n  match r with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3013, "problem": "build", "bad": "\nlet rec build (rand,depth) =\n  let r = if depth > 0 then rand (2, 11) else rand (0, 2) in\n  match r with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2..4 -> buildSine (build (rand, (depth - 1)))\n  | 5..7 -> buildCosine (build (rand, (depth - 1)))\n  | 8 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 9 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 10 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = if depth > 0 then rand (2, 14) else rand (0, 2) in\n  match r with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildSine (build (rand, (depth - 1)))\n  | 4 -> buildSine (build (rand, (depth - 1)))\n  | 5 -> buildCosine (build (rand, (depth - 1)))\n  | 6 -> buildCosine (build (rand, (depth - 1)))\n  | 7 -> buildCosine (build (rand, (depth - 1)))\n  | 8 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 9 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 10 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 11 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 12 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 13 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3014, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX _ -> x\n  | VarY _ -> y\n  | Sine x1 -> eval ((buildSine x1), x, y)\n  | Cosine x2 -> eval ((buildCosine x2), x, y)\n  | Average (x3,x4) -> eval ((buildAverage (x3, x4)), x, y)\n  | Times (x5,x6) -> eval ((buildTimes (x5, x6)), x, y)\n  | Thresh (x7,x8,x9,x0) -> eval (buildThresh (x7, x8, x9, x0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX _ -> x\n  | VarY _ -> y\n  | Sine x1 -> eval ((buildSine x1), x, y)\n  | Cosine x2 -> eval ((buildCosine x2), x, y)\n  | Average (x3,x4) -> eval ((buildAverage (x3, x4)), x, y)\n  | Times (x5,x6) -> eval ((buildTimes (x5, x6)), x, y)\n  | Thresh (x7,x8,x9,x0) -> eval ((buildThresh (x7, x8, x9, x0)), x, y);;\n"}
{"hw": "hw2", "index": 3015, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Root of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Pivot of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x2 -> cos (pi *. (eval (x2, x, y)))\n  | Root x3 -> sqrt (eval (x3, x, y))\n  | Average (x4,x5) -> ((eval (x4, x, y)) +. (eval (x5, x, y))) /. 2.\n  | Times (x6,x7) -> (eval (x6, x, y)) *. (eval (x7, x, y))\n  | Thresh (x8,x9,x10,x11) ->\n      if (eval (x8, x, y)) < (eval (x9, x, y))\n      then eval (x10, x, y)\n      else eval (x11, x, y)\n  | Pivot (x12,x13,x14) ->\n      if (eval (x12, x, y)) < 0 then eval (x13, x, y) else eval (x14, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Root of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Pivot of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x2 -> cos (pi *. (eval (x2, x, y)))\n  | Root x3 -> sqrt (eval (x3, x, y))\n  | Average (x4,x5) -> ((eval (x4, x, y)) +. (eval (x5, x, y))) /. 2.\n  | Times (x6,x7) -> (eval (x6, x, y)) *. (eval (x7, x, y))\n  | Thresh (x8,x9,x10,x11) ->\n      if (eval (x8, x, y)) < (eval (x9, x, y))\n      then eval (x10, x, y)\n      else eval (x11, x, y)\n  | Pivot (x12,x13,x14) ->\n      if (eval (x12, x, y)) < 0. then eval (x13, x, y) else eval (x14, x, y);;\n"}
{"hw": "hw2", "index": 3016, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Root of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Pivot of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Flip of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Pivot of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x1 -> \"sin(pi*\" ^ ((exprToString x1) ^ \")\")\n  | Cosine x2 -> \"cos(pi*\" ^ ((exprToString x2) ^ \")\")\n  | Root x3 -> \"sqrt(\" ^ ((exprToString x3) ^ \")\")\n  | Average (x4,x5) ->\n      \"((\" ^ ((exprToString x4) ^ (\"+\" ^ ((exprToString x5) ^ \")/2)\")))\n  | Times (x6,x7) -> (exprToString x6) ^ (\"*\" ^ (exprToString x7))\n  | Thresh (x8,x9,x10,x11) ->\n      \"(\" ^\n        ((exprToString x8) ^\n           (\"<\" ^\n              ((exprToString x9) ^\n                 (\"?\" ^\n                    ((exprToString x10) ^ (\":\" ^ ((exprToString x11) ^ \")\")))))))\n  | Pivot (x12,x13,x14) ->\n      \"(\" ^\n        ((exprToString x12) ^\n           (\"<0?\" ^ ((exprToString x13) ^ (\":\" ^ ((exprToString x14) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Flip of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Pivot of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x1 -> \"sin(pi*\" ^ ((exprToString x1) ^ \")\")\n  | Cosine x2 -> \"cos(pi*\" ^ ((exprToString x2) ^ \")\")\n  | Flip x3 -> \"(\" ^ ((exprToString x3) ^ \"*-1)\")\n  | Average (x4,x5) ->\n      \"((\" ^ ((exprToString x4) ^ (\"+\" ^ ((exprToString x5) ^ \")/2)\")))\n  | Times (x6,x7) -> (exprToString x6) ^ (\"*\" ^ (exprToString x7))\n  | Thresh (x8,x9,x10,x11) ->\n      \"(\" ^\n        ((exprToString x8) ^\n           (\"<\" ^\n              ((exprToString x9) ^\n                 (\"?\" ^\n                    ((exprToString x10) ^ (\":\" ^ ((exprToString x11) ^ \")\")))))))\n  | Pivot (x12,x13,x14) ->\n      \"(\" ^\n        ((exprToString x12) ^\n           (\"<0?\" ^ ((exprToString x13) ^ (\":\" ^ ((exprToString x14) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3017, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun f'  -> fun x  -> (f, ((f x) = x))), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = ((f x), ((f x) = x)) in f'), b);;\n"}
{"hw": "hw2", "index": 3018, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = (f, ((f x) = x)) in f'), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = ((f x), ((f x) = x)) in f'), b);;\n"}
{"hw": "hw2", "index": 3019, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = ((f x), ((f x not) = x)) in f'), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' x = ((f x), (not ((f x) = x))) in f'), b);;\n"}
{"hw": "hw2", "index": 3020, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = ((f x), ((not f x) = x)) in f'), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' x = ((f x), (not ((f x) = x))) in f'), b);;\n"}
{"hw": "hw2", "index": 3021, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (1, 2) in (if x = 1 then buildX () else buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then let x = rand (1, 2) in (if x = 1 then buildX () else buildY ())\n  else\n    (let subtreeSize1 = if depth = 1 then 0 else rand (1, (depth - 1)) in\n     let subtreeSize2 = if depth = 1 then 0 else rand (1, (depth - 1)) in\n     let subtreeSize3 = if depth = 1 then 0 else rand (1, (depth - 1)) in\n     let subtreeeSize4 = if depth = 1 then 0 else rand (1, (depth - 1)) in\n     let x = rand (1, 5) in\n     match x with | _ -> buildSine (build (rand, subtreeSize1)));;\n"}
{"hw": "hw2", "index": 3022, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi * (eval (expr, x, y)))\n  | Cosine expr -> cos (pi * (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) + (eval (expr2, x, y))) / 2\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) * (eval (expr2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y));;\n"}
{"hw": "hw2", "index": 3023, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) + (eval (expr2, x, y))) /. 2\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y));;\n"}
{"hw": "hw2", "index": 3024, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y));;\n"}
{"hw": "hw2", "index": 3025, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr -> ((eval expr) *. ((eval expr) +. 1.0)) / 2\n  | Power (expr1,expr2,expr3) ->\n      (eval expr1) ** (abs ((eval expr1) +. (eval expr2)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs_float ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n"}
{"hw": "hw2", "index": 3026, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr -> ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) / 2\n  | Power (expr1,expr2,expr3) ->\n      (eval expr1) ** (abs ((eval (expr1, x, y)) +. (eval (expr2, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs_float ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n"}
{"hw": "hw2", "index": 3027, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2\n  | Power (expr1,expr2,expr3) ->\n      (eval expr1) ** (abs ((eval (expr1, x, y)) +. (eval (expr2, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs_float ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n"}
{"hw": "hw2", "index": 3028, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval expr1) ** (abs ((eval (expr1, x, y)) +. (eval (expr2, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs_float ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n"}
{"hw": "hw2", "index": 3029, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr1,expr2) ->\n      ((eval (expr1, x, y)) +. (eval (expr2, x, y))) /. 2.0\n  | Times (expr1,expr2) -> (eval (expr1, x, y)) *. (eval (expr2, x, y))\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      if (eval (expr1, x, y)) < (eval (expr2, x, y))\n      then eval (expr3, x, y)\n      else eval (expr4, x, y)\n  | SumInts expr ->\n      ((eval (expr, x, y)) *. ((eval (expr, x, y)) +. 1.0)) /. 2.0\n  | Power (expr1,expr2,expr3) ->\n      (eval (expr1, x, y)) **\n        (abs_float ((eval (expr2, x, y)) +. (eval (expr3, x, y))));;\n"}
{"hw": "hw2", "index": 3030, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin %s\" exprToString expr\n  | Cosine expr -> Printf.sprintf \"cos %s\" exprToString expr\n  | Average (expr1,expr2) ->\n      Printf.sprintf \"%s + %s/2\" exprToString expr1 exprToString expr2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> Printf.sprintf \"x\" | VarY  -> Printf.sprintf \"y\";;\n"}
{"hw": "hw2", "index": 3031, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin %s\" exprToString expr\n  | Cosine expr -> Printf.sprintf \"cos %s\" exprToString expr;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> Printf.sprintf \"x\" | VarY  -> Printf.sprintf \"y\";;\n"}
{"hw": "hw2", "index": 3032, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin(pi*%s)\" (exprToString expr)\n  | Cosine expr -> Printf.sprintf \"cos(pi*%s)\" (exprToString expr)\n  | Average (expr1,expr2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString expr1) (exprToString expr2)\n  | Times (expr1,expr2) ->\n      Printf.sprintf \"%s*%s\" (exprToString expr1) (exprToString expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString expr1)\n        (exprToString expr2) (exprToString expr3) (exprToString expr4)\n  | SumInts (expr1,expr2) ->\n      Printf.sprintf \"(%s*(%s+1)/2)\" (exprToString expr1)\n  | Power (expr1,expr2,expr3) ->\n      Printf.sprintf \"(%s^|%s+%s|)\" (exprToString expr1) (exprToString expr2)\n        (exprToString expr3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin(pi*%s)\" (exprToString expr)\n  | Cosine expr -> Printf.sprintf \"cos(pi*%s)\" (exprToString expr)\n  | Average (expr1,expr2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString expr1) (exprToString expr2)\n  | Times (expr1,expr2) ->\n      Printf.sprintf \"%s*%s\" (exprToString expr1) (exprToString expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString expr1)\n        (exprToString expr2) (exprToString expr3) (exprToString expr4)\n  | SumInts expr1 ->\n      Printf.sprintf \"(%s*(%s+1)/2)\" (exprToString expr1)\n        (exprToString expr1)\n  | Power (expr1,expr2,expr3) ->\n      Printf.sprintf \"(%s^|%s+%s|)\" (exprToString expr1) (exprToString expr2)\n        (exprToString expr3);;\n"}
{"hw": "hw2", "index": 3033, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin(pi*%s)\" (exprToString expr)\n  | Cosine expr -> Printf.sprintf \"cos(pi*%s)\" (exprToString expr)\n  | Average (expr1,expr2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString expr1) (exprToString expr2)\n  | Times (expr1,expr2) ->\n      Printf.sprintf \"%s*%s\" (exprToString expr1) (exprToString expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString expr1)\n        (exprToString expr2) (exprToString expr3) (exprToString expr4)\n  | SumInts expr1 -> Printf.sprintf \"(%s*(%s+1)/2)\" (exprToString expr1)\n  | Power (expr1,expr2,expr3) ->\n      Printf.sprintf \"(%s^|%s+%s|)\" (exprToString expr1) (exprToString expr2)\n        (exprToString expr3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SumInts of expr\n  | Power of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine expr -> Printf.sprintf \"sin(pi*%s)\" (exprToString expr)\n  | Cosine expr -> Printf.sprintf \"cos(pi*%s)\" (exprToString expr)\n  | Average (expr1,expr2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString expr1) (exprToString expr2)\n  | Times (expr1,expr2) ->\n      Printf.sprintf \"%s*%s\" (exprToString expr1) (exprToString expr2)\n  | Thresh (expr1,expr2,expr3,expr4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString expr1)\n        (exprToString expr2) (exprToString expr3) (exprToString expr4)\n  | SumInts expr1 ->\n      Printf.sprintf \"(%s*(%s+1)/2)\" (exprToString expr1)\n        (exprToString expr1)\n  | Power (expr1,expr2,expr3) ->\n      Printf.sprintf \"(%s^|%s+%s|)\" (exprToString expr1) (exprToString expr2)\n        (exprToString expr3);;\n"}
{"hw": "hw2", "index": 3034, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not f), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then (b, false) else ((f b), true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 3035, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then false else true in wwhile (helper, b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let helper b = if (f b) = b then (b, false) else ((f b), true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 3036, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3037, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3038, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem (h, seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3039, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem (h, seen)) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3040, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile b' c' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 3041, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw1", "index": 3042, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n = if n < 10 then n else ();;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt ((n - (n mod 10)) / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 3043, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt ((n - (n mod 10)) / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else additivePersistence sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt ((n - (n mod 10)) / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 3044, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt ((n - (n mod 10)) / 10); n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt ((n - (n mod 10)) / 10)) @ [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 3045, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::l' -> listReverse @ a;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::l' -> (listReverse l') @ [a];;\n"}
{"hw": "hw1", "index": 3046, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::l' -> listReverse @ [a];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::l' -> (listReverse l') @ [a];;\n"}
{"hw": "hw2", "index": 3047, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (e1,e2,e3) = Op2 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 11) in\n     let d = depth - 1 in\n     match r with\n     | 0 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildSine (build (rand, d))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildOp2\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 6 -> buildSine (build (rand, d))\n     | 7 -> buildCosine (build (rand, d))\n     | 8 -> buildOp1 (build (rand, d))\n     | 9 -> buildSine (build (rand, d))\n     | 10 -> buildCosine (build (rand, d)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (e1,e2,e3) = Op2 (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 11) in\n     let d = depth - 1 in\n     match r with\n     | 0 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildSine (build (rand, d))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildOp2 ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildSine (build (rand, d))\n     | 7 -> buildCosine (build (rand, d))\n     | 8 -> buildOp1 (build (rand, d))\n     | 9 -> buildSine (build (rand, d))\n     | 10 -> buildCosine (build (rand, d)));;\n"}
{"hw": "hw2", "index": 3048, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 11) in\n     let d = depth - 1 in\n     match r with\n     | 0 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildSine (build (rand, d))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 6 -> buildSine (build (rand, d))\n     | 7 -> buildCosine (build (rand, d))\n     | 8 -> buildX (build (rand, d))\n     | 9 -> buildSine (build (rand, d))\n     | 10 -> buildCosine (build (rand, d)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 11) in\n     let d = depth - 1 in\n     match r with\n     | 0 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildSine (build (rand, d))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 6 -> buildSine (build (rand, d))\n     | 7 -> buildCosine (build (rand, d))\n     | 8 -> buildX ()\n     | 9 -> buildSine (build (rand, d))\n     | 10 -> buildCosine (build (rand, d)));;\n"}
{"hw": "hw2", "index": 3049, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 3050, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e1 -> (eval (e1, x, y)) / ((eval (e1, x, y)) *. (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e1 -> (eval (e1, x, y)) /. ((eval (e1, x, y)) *. (eval (e1, x, y)));;\n"}
{"hw": "hw2", "index": 3051, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e1 -> (eval (e1, x, y)) /. ((eval (e1, x, y)) *. (eval (e1, x, y)))\n  | Op2 (e1,e2,e3) -> 1.0 /. (((eval e1) +. (eval e2)) +. (eval e3));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e1 -> (eval (e1, x, y)) /. ((eval (e1, x, y)) *. (eval (e1, x, y)))\n  | Op2 (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 3052, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr) ->\n      \"((\" ^ ((exprToString expr) ^ (\" + \" ^ ((exprToString expr) ^ \")/2)\")))\n  | Times (expr,expr) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr))\n  | Thresh (expr,expr,expr,expr) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr) ^\n                 (\" ? \" ^\n                    ((exprToString expr) ^\n                       (\" : \" ^ ((exprToString expr) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3053, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun input  -> let b = f input in ((b, (b != input)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((fun input  -> let b = f input in (b, (b != input))), b);;\n"}
{"hw": "hw2", "index": 3054, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3055, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3056, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 3057, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e -> if (eval (e, x, y)) > 1 then 1 / (eval (e, x, y)) else 1 / 3\n  | OneOverAvg (e1,e2,e3) ->\n      if (((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y))) > 1\n      then 1 / (((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y)))\n      else (-1) / 3;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 /. 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) /. 3.0;;\n"}
{"hw": "hw2", "index": 3058, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 / (eval (e, x, y)) else 1 / 3\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) / 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 /. 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) /. 3.0;;\n"}
{"hw": "hw2", "index": 3059, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 / 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) / 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 /. 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) /. 3.0;;\n"}
{"hw": "hw2", "index": 3060, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 /. 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) / 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | OneOver of expr\n  | OneOverAvg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | OneOver e ->\n      if (eval (e, x, y)) > 1.0 then 1.0 /. (eval (e, x, y)) else 1.0 /. 3.0\n  | OneOverAvg (e1,e2,e3) ->\n      if\n        (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) > 1.0\n      then\n        1.0 /.\n          (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y)))\n      else (-1.0) /. 3.0;;\n"}
{"hw": "hw2", "index": 3061, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ (exprToString e2 \")/2)\")))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2 \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3062, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2 \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi *\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3063, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f b in ((b, (b != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 3064, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b = f b in ((b, (b != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 3065, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 3066, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 3067, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let b = f b in (b, (b != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c) -> if c = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((fun fixb  -> let b = f b in (b, (fixb != b))), b);;\n"}
{"hw": "hw2", "index": 3068, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3069, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = true then seen else seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 3070, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let c y = let (b,d) = y in [b + d] in (c x) @ a in\n    let base = ([], []) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3071, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in ((b + c), (b + c)) @ a in\n    let base = ([], []) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3072, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in [((b + c), (b + c))] @ a in\n    let base = ([], []) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3073, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in [((b + c), (b + c))] @ a in\n    let base = [(0, 0)] in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3074, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in [((b + c), (b + c))] @ a in\n    let base = [(0, 0)] in\n    let args = [padZero l1 l2] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3075, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in [((b + c), (b + c))] @ a in\n    let base = (0, 0) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3076, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (b::b',c::c') = x in [((b + c), (b + c))] @ a in\n    let base = [] in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3077, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = [] in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3078, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = [] in\n    let args = [padZero l1 l2] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3079, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = ([], []) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3080, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z)::[] = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = ([], []) in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3081, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in\n      let b::b' = y in let c::c' = z in ([b + c], ([b + c] @ a)) in\n    let base = [] in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3082, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3083, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3084, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3085, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3086, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = ([], []) in\n    let args = ([l1], [l2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3087, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (y,z) = x in let b::b' = y in let c::c' = z in [b + c] @ a in\n    let base = [] in\n    let args = ([l1], [l2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3088, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l2 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3089, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1::x3,x2::x4) = x in [x1 + x2] :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3090, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3091, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in a @ [x1 + x2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3092, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in let (a1,a2) = a in ((a1 @ [x1 + x2]), (a2 @ [x1])) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3093, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in let (a1,a2) = a in ((a1 @ [x1 + x2]), (a2 @ [x1])) in\n    let base = [([], [])] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3094, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (x1, x2) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3095, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in [(x1, x2)] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3096, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (x1, x2) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3097, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ((x1 + x2), x2) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([x1 + x2], [x2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3098, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,ax) = a in ((((x1 + x2) + c) mod 10), [((x1 + x2) + c) / 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) mod 10], [(x1 + x2) / 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3099, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (((x1 + x2) mod 10), [(x1 + x2) / 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) mod 10], [(x1 + x2) / 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3100, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in (((x1 + x2) mod 10), [(x1 + x2) / 10]) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) mod 10], [(x1 + x2) / 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3101, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let a1::a2 = a in\n      let (c,ax) = a1 in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3102, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let a1::a2 = a in\n      let (c,ax) = a1 in ([((x1 + x2) + c) / 10], [((x1 + x2) + c) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3103, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([((x1 + x2) + a1) / 10], (a @ [((x1 + x2) + a1) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3104, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([((x1 + x2) + a1) / 10], [a :: (((x1 + x2) + a1) mod 10)]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3105, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([((x1 + x2) + a1) / 10], [a2 :: (((x1 + x2) + a1) mod 10)]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3106, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ax::a' = a in\n      let (a1,a2) = ax in\n      ([((x1 + x2) + a1) / 10], [a2 :: (((x1 + x2) + a1) mod 10)]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3107, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ax::a' = a in\n      let (a1,a2) = ax in\n      ([((x1 + x2) + a1) / 10], [[a2]; ((x1 + x2) + a1) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3108, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ax::a' = a in\n      let (a1,a2) = ax in\n      ([((x1 + x2) + a1) / 10], [((x1 + x2) + a1) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (x1,x2) = x in ([(x1 + x2) / 10], [(x1 + x2) mod 10]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3109, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      ((a1 @ [((x1 + x2) + c') / 10]), (a2 @ [((x1 + x2) + c') mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      match c with\n      | 0 -> ((a1 @ [(x1 + x2) / 10]), (a2 @ [(x1 + x2) mod 10]))\n      | _ -> ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3110, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      match c with\n      | [] -> ((a1 @ [(x1 + x2) / 10]), (a2 @ [(x1 + x2) mod 10]))\n      | _ -> ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      match c with\n      | 0 -> ((a1 @ [(x1 + x2) / 10]), (a2 @ [(x1 + x2) mod 10]))\n      | _ -> ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3111, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | [] -> ((a2 @ [(x1 + x2) mod 10]), (a1 @ [(x1 + x2) / 10]))\n      | _ -> ((a1 @ 3), (a2 @ 5)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | [] -> ((a2 @ [(x1 + x2) mod 10]), (a1 @ [(x1 + x2) / 10]))\n      | _ -> ((a1 @ [3]), (a2 @ [5])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3112, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | [] -> ((a2 @ [(x1 + x2) mod 10]), (a1 @ [(x1 + x2) / 10]))\n      | _ -> ((a1 :: 3), (a2 :: 5)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      match a1 with\n      | [] -> ((a2 @ [(x1 + x2) mod 10]), (a1 @ [(x1 + x2) / 10]))\n      | _ -> ((a1 @ [3]), (a2 @ [5])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3113, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      ([((x1 + x2) + a1) / 10], (a2 @ [((x1 + x2) + a1) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      ([((x1 + x2) + c) / 10; 0], (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3114, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ((((x1 + x2) / 10) @ [0]), ((x1 + x2) mod 10))\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (((x1 + x2) + c) mod 10))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], [(x1 + x2) mod 10])\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3115, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ((((x1 + x2) / 10) :: 0), ((x1 + x2) mod 10))\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ (((x1 + x2) + c) mod 10)))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], [(x1 + x2) mod 10])\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3116, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], ((x1 + x2) mod 10))\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ (((x1 + x2) + c) mod 10)))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], [(x1 + x2) mod 10])\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3117, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], ((x1 + x2) mod 10))\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      if (List.length a1) = 0\n      then ([(x1 + x2) / 10; 0], [(x1 + x2) mod 10])\n      else\n        (let c::c' = a1 in\n         ((a1 @ [((x1 + x2) + c) / 10]), (a2 @ [((x1 + x2) + c) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3118, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let s::s' = a2 in\n      ((((x1 + x2) + a1) / 10), ([s + c] @ (s' @ [((x1 + x2) + c) mod 10]))) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a2) = a in\n      let s::s' = a2 in\n      ((((x1 + x2) + c) / 10), ([s + c] @ (s' @ [((x1 + x2) + c) mod 10]))) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3119, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a2) = a in\n      let s::s' = a2 in\n      (([s + c] @ (s' @ [((x1 + x2) + c) mod 10])), [((x1 + x2) + c) / 10]) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a2) = a in\n      let s::s' = a2 in\n      ((((x1 + x2) + c) / 10), ([s + c] @ (s' @ [((x1 + x2) + c) mod 10]))) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3120, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a2 in\n      ([((x1 + x2) + c) / 10], (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a2 in\n      ((((x1 + x2) + c) / 10), (a2 @ [((x1 + x2) + c) mod 10])) in\n    let base = (0, [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3121, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a2) = a in let v = (x1 + x2) + c in ((c + 1), (a2 @ [c + 1])) in\n    let base = (0, [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3122, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in let v = x1 + x2 in ((a1 @ [c + 1]), (a2 @ [c + 1])) in\n    let base = ([0], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3123, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      let v = (x1 + x2) + c in ((a1 @ [c + 1]), (a2 @ [c + 1])) in\n    let base = ([9], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3124, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      let v = (x1 + x2) + c' in (([c + 1] @ [v / 10]), [v mod 10]) in\n    let base = ([0], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3125, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c'::c'' = a1 in\n      let s::s' = a2 in\n      let v = (x1 + x2) + c' in (([c + 1] @ [v / 10]), (s @ [v mod 10])) in\n    let base = ([0; 0], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3126, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c' = a1 in\n      let s::s' = a2 in\n      let v = (x1 + x2) + c' in\n      ([v / 10], ([v / 10] @ (a2 @ [(v mod 10) + s]))) in\n    let base = ([0], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3127, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3128, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (bigAdd ((mulByDigit x l2) a))) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3129, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = (0, (bigAdd (mulByDigit x l2) a)) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3130, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (mulByDigit x l2) a in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3131, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (mulByDigit x l2) a in\n  let base = [0] in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3132, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (c,a1::a2) = a in\n    let v = (x1 * x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n  let base = (0, [0]) in\n  let args =\n    let (ar1,ar2) = padZero (l1 l2) in List.rev (List.combine ar1 ar2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3133, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (c,a1::a2) = a in\n    let v = (x1 * x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n  let base = (0, [0]) in\n  let args =\n    let (ar1::[],ar2::[]) = padZero (l1 l2) in\n    List.rev (List.combine ar1 ar2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3134, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (x1,x2) = x in\n    let (c,a1::a2) = a in\n    let v = (x1 * x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n  let base = (0, [0]) in\n  let args =\n    let y = padZero (l1 l2) in\n    let (ar1,ar2) = y in List.rev (List.combine ar1 ar2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3135, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd (m a') in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else\n    (match i with\n     | 1 -> l\n     | 10 -> l @ [0]\n     | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (c,a') = a in\n    let m = mulByDigit x l2 in let s = bigAdd m a' in ((c + 1), s) in\n  let base = (0, [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3136, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let h::t = l in\n     if h = []\n     then []\n     else\n       (match t with\n        | [] -> h @ []\n        | _ ->\n            [(h * i) / 10] @\n              (mulByDigit i ([t.hd + ((i * t.hd) mod 10)] @ t.tl))));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3137, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let h::t = l in\n     if h = [] then [] else (match t with | [] -> h | _ -> [(h * i) / 10]));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3138, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else (let h::t = l in match t with | [] -> h | _ -> [(h * i) / 10]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3139, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else (let (h::[])::t = l in match t with | [] -> h | _ -> [(h * i) / 10]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3140, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let (h::[])::t = l in\n     match t with\n     | [] -> [h]\n     | _ ->\n         [(h * i) / 10] @\n           (mulByDigit i\n              [(let (h2::[])::t2 = t in [h2 + ((h * i) mod 10)] @ t2)]));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3141, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let (h::[])::t = l in\n     match t with\n     | [] -> [h]\n     | _ ->\n         [(h * i) / 10] @\n           (mulByDigit i\n              [(let (h2::[])::t2 = t in [h2 + ((h * i) mod 10)] @ [t2])]));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3142, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let (h::[])::t = l in\n     let (h2::[])::t2 = t in\n     match t with\n     | [] -> [h]\n     | _ -> [(h * i) / 10] @ [(mulByDigit i [h2 + (h mod 10)]) @ t2]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3143, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let (h::[])::t = l in\n     let (h2::[])::t2 = t in\n     match t with\n     | [] -> [h]\n     | _ -> [(h * i) / 10] @ [mulByDigit i ([h2 + (h mod 10)] @ t2)]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3144, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let h::t = l in\n     let h2::t2 = t in\n     match t with\n     | [] -> [h]\n     | _ -> [(h * i) / 10] @ [mulByDigit i ([h2 + (h mod 10)] @ t2)]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3145, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if l = []\n  then []\n  else\n    (let h::t = l in\n     let h2::t2 = t in\n     match t with\n     | [] -> h\n     | _ -> [(h * i) / 10] @ [mulByDigit i ([h2 + (h mod 10)] @ t2)]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3146, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x' -> [[(x * i) / 10]; ((x * i) mod 10) + (mulByDigit i x')];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3147, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x' -> [[(x * i) / 10]; ((x * i) mod 10) + [mulByDigit i x']];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3148, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> 0\n  | x::x' -> [[(x * i) / 10]; ((x * i) mod 10) + (mulByDigit i x')];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3149, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> [0]\n  | x::x' -> [[(x * i) / 10]; ((x * i) mod 10) + (mulByDigit i x')];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3150, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> [0]\n  | x::x' -> [(x * i) / 10] @ [((x * i) mod 10) + (mulByDigit i x')];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3151, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x' -> [(x * i) / 10] @ [((x * i) mod 10) + (mulByDigit i x')];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3152, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @ ([((x * i) mod 10) + x'] @ ((mulByDigit i x') :: x''));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3153, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @ ([((x * i) mod 10) + x'] @ (mulByDigit i [x' :: x'']));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3154, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ [x'']));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3155, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @ ([((x * i) mod 10) + x'] @ ((mulByDigit i x') @ x''));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x'::x'' ->\n      [(x * i) / 10] @\n        ([((x * i) mod 10) + x'] @ ((mulByDigit i [x']) @ x''));;\n"}
{"hw": "hw3", "index": 3156, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x' ->\n      if (x * i) < 9\n      then [(x * i) / 10] @ (mulByDigit i x')\n      else [(x * i) / 10] @ ([(x * i) mod 10] + (mulByDigit i x'));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | x::x' -> [(x * i) / 10; (x * i) mod 10] @ (mulByDigit i x');;\n"}
{"hw": "hw3", "index": 3157, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | z::x::x' -> [(x * i) / 10] @ (mulByDigit i [((x * i) mod 10) + z; x']);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | z::x::x' -> [(z * i) / 10] @ ((mulByDigit i [((z * i) mod 10) + x]) @ x');;\n"}
{"hw": "hw3", "index": 3158, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  if (List.length l) = 1\n  then [l * i]\n  else\n    (match l with\n     | [] -> []\n     | z::x::x' ->\n         [(z * i) / 10] @ ((mulByDigit i [((z * i) mod 10) + x]) @ x'));;\n", "fix": "\nlet rec mulByDigit i l =\n  if (List.length l) = 1\n  then let x::x' = l in [x * i]\n  else\n    (match l with\n     | [] -> []\n     | z::x::x' ->\n         [(z * i) / 10] @ ((mulByDigit i [((z * i) mod 10) + x]) @ x'));;\n"}
{"hw": "hw3", "index": 3159, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet c y = y;;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let c::c'::c'' = a1 in\n      let s::s' = a2 in\n      let v = (x1 + x2) + c' in\n      (([c + 1] @ [v / 10]), (s' @ ([s + c'] @ [v mod 10]))) in\n    let base = ([0; 0], [5]) in\n    let args = List.combine l1 l2 in\n    let (duh,res) = List.fold_left f base args in (duh, res) in\n  add (padZero l1 l2);;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> x :: (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2\n    then (l1, ((clone 0 (s1 - s2)) @ l2))\n    else (((clone 0 (s2 - s1)) @ l1), l2);;\n\nlet rec removeZero l =\n  if l = []\n  then []\n  else (let h::t = l in match h with | 0 -> removeZero t | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (c,a1::a2) = a in\n      let v = (x1 + x2) + c in ((v / 10), ([v / 10] @ ([v mod 10] @ a2))) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i < 1\n  then []\n  else (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 3160, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else if s1 > s2 then (l1, (clone 0 (s1 - s2))) else clone 0 (s2 - s1);;\n", "fix": "\nlet rec clone x n =\n  if n < 1 then [] else (match n with | _ -> [x] @ (clone x (n - 1)));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 = s2\n  then (l1, l2)\n  else\n    if s1 > s2 then (l1, (clone 0 (s1 - s2))) else ((clone 0 (s2 - s1)), l2);;\n"}
{"hw": "hw3", "index": 3161, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let rec a c y = a a x in (a :: x) = fs in\n  let base = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let c y = 2 in c in\n  let base = let g y = y in g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3162, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let rec a c y = c a x in (a :: x) = fs in\n  let base = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let c y = 2 in c in\n  let base = let g y = y in g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3163, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x h x = x a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x = a x in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3164, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c x = a x in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3165, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c x = a a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3166, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c x = x a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3167, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g x = x a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3168, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y x = x a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3169, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y c = (x a) = x in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3170, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y c = a in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base g x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3171, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3172, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let c y = x (a y) in c in\n  let base = let g y = y in g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3173, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let c y = x (a y) in c in\n  let base = let g y = y in g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3174, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = let a::x = xs in a * a in\n  let base = 0 in\n  List.fold_left f base xs UNCOMMENT AFTER IMPLEMENTING THE ABOVE;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3175, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = 0 in\n  List.fold_left f base xs UNCOMMENT AFTER IMPLEMENTING THE ABOVE;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3176, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = let a::xs = xs in a * a in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum x) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum x) in\n  let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = let a::xs = xs in a * a in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum x) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum [x]) in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3177, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = let a::xs = xs in a * a in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum x) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum [x]) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in [a * a] + (sqsum [x]) in\n  let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = let a::xs = xs in a * a in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum x) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = x in (a * a) + (sqsum [x]) in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = let a::x = xs in (a * a) + (sqsum [x]) in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3178, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (sepConcat \"; \" l) l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 3179, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  \"[\" ^ ((List.map (fun t  -> sepConcat \"; \" l) l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 3180, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
