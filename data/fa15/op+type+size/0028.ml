
let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  if ((sumList (digits n)) / 10) <> 0
  then (additivePersistence (sumList digits n)) + 1
  else 1;;


(* fix

let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec additivePersistence n =
  if ((sumList (digits n)) / 10) <> 0
  then (additivePersistence (sumList (digits n))) + 1
  else 1;;

*)

(* changed spans
(14,28)-(14,46)
(14,37)-(14,43)
*)

(* type error slice
(5,7)-(5,62)
(5,8)-(5,28)
(10,55)-(10,70)
(10,59)-(10,70)
(10,60)-(10,67)
(14,28)-(14,46)
(14,29)-(14,36)
*)

(* all spans
(2,20)-(6,13)
(3,2)-(6,13)
(3,15)-(3,25)
(3,16)-(3,24)
(3,16)-(3,17)
(3,22)-(3,24)
(4,2)-(6,13)
(4,5)-(4,18)
(4,5)-(4,13)
(4,6)-(4,7)
(4,10)-(4,12)
(4,17)-(4,18)
(5,7)-(5,62)
(5,8)-(5,28)
(5,8)-(5,18)
(5,9)-(5,10)
(5,15)-(5,17)
(5,22)-(5,28)
(5,30)-(5,61)
(5,53)-(5,54)
(5,30)-(5,52)
(5,31)-(5,42)
(5,43)-(5,51)
(5,44)-(5,45)
(5,48)-(5,50)
(5,55)-(5,61)
(6,7)-(6,13)
(8,11)-(8,34)
(8,15)-(8,34)
(8,15)-(8,26)
(8,27)-(8,34)
(8,28)-(8,31)
(8,32)-(8,33)
(10,16)-(10,70)
(10,21)-(10,70)
(10,27)-(10,29)
(10,43)-(10,44)
(10,55)-(10,70)
(10,55)-(10,56)
(10,59)-(10,70)
(10,60)-(10,67)
(10,68)-(10,69)
(12,28)-(15,8)
(13,2)-(15,8)
(13,5)-(13,37)
(13,5)-(13,32)
(13,6)-(13,26)
(13,7)-(13,14)
(13,15)-(13,25)
(13,16)-(13,22)
(13,23)-(13,24)
(13,29)-(13,31)
(13,36)-(13,37)
(14,7)-(14,51)
(14,7)-(14,47)
(14,8)-(14,27)
(14,28)-(14,46)
(14,29)-(14,36)
(14,37)-(14,43)
(14,44)-(14,45)
(14,50)-(14,51)
(15,7)-(15,8)
*)
