{"hw": "hw3", "index": 0, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 4, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (a + x)) in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 5, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 6, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 7, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 8, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 9, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = [1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 10, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + at) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 11, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + xh) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 12, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 13, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 14, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 15, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 16, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 17, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 18, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 19, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 20, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> (0, [])\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 21, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (carry,result) -> (0, (carry :: result)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 22, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 23, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 24, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,h2::t2) -> (match x with | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 25, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h2]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 26, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h1]) | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 27, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 28, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = 0; [0; 0; 0; 0] in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = (0, [0; 0; 0; 0]) in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 29, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, [0; 0; 0; 0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 30, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, [0; 0; 0; 0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 31, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 32, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 33, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | [] -> (l1, [0; 0; 0; 0]) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,_) -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 34, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,_) -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 35, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (match x with | h2::t2 -> (t1, (((h1 + rh) mod 10) :: rt))) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, ((((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 36, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else [(h1 + x) mod 10]\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (((h1 + x) + rh) mod 10) :: rt in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else (t1, [(h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (t1, ((((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 37, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          (((List.tl List.rev h1) :: t1), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (((List.tl List.rev h1) :: t1), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.tl (List.rev (h1 :: t1))), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 38, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10)\n            :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev (List.tl (List.rev (h1 :: t1)))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev (List.tl (List.rev (h1 :: t1)))),\n            ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 39, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 40, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (((mulByDigit h1 rh) :: rt) :: rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit h1 (rh :: rt)) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 41, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd ((mulByDigit h1 rh) :: rt) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit h1 (rh :: rt)) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 42, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rh) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 (List.append r [0])) r)) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 43, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rt) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 (List.append r [0])) r)) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 44, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd ((mulByDigit x h1) :: t1) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd (mulByDigit x (h1 :: t1)) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 45, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes), l2);;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n"}
{"hw": "hw3", "index": 46, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in List.append ((zeroes l1), l2);;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n"}
{"hw": "hw3", "index": 47, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append (zeroes l1)), l2);;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n"}
{"hw": "hw3", "index": 48, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 49, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> x a in\n  let base = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g b y n = match n with | [] -> n | _ -> y b in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 50, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g b y n = match n with | [] -> n | _ -> y b in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 51, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 52, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 53, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 54, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 55, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g b y z = match y with | [] -> z | _ -> b a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 56, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x =\n    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 57, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 58, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 59, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let piper fn n =\n    let f a x = x a in let base = n in List.fold_left f base fs in\n  piper fs;;\n"}
{"hw": "hw3", "index": 60, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 61, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 62, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 63, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 64, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y = y a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 65, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 66, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 67, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 68, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let an = a in x in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 69, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = let an = a in x in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 70, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 71, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 72, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 73, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 74, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 75, "problem": "pipe", "bad": "\nlet pipe fs = let f a x c = c x in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 76, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 77, "problem": "pipe", "bad": "\nlet pipe fs = let f a x c = a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 78, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 79, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 80, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 81, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 82, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 83, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = (match l1 with | h -> h) + (match l2 with | h -> h) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 84, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 85, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 86, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 87, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 88, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) | h::t -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 89, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 90, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 91, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 92, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 93, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 94, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 95, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 96, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base x = x in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 97, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,h::t) -> [] in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] ->\n          (((fst x) + (snd x)),\n            [((fst x) + (snd x)) / 10; ((fst x) + (snd x)) mod 10])\n      | h::t -> (0, []) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 98, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: (clone x (n - 1));;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 99, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulByDigit i l);;\n"}
{"hw": "hw3", "index": 100, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then ((clone 0 l1), l2)\n  else if s2 < s1 then (l1, (clone 0 l2)) else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 101, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, (((clone 0 s1) - s2) @ l2)) else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 102, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 103, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 104, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 105, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = (fun a  -> x) x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 106, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 107, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ sep) x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 108, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x (a ^ sep) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 109, "problem": "stringOfList", "bad": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n\nlet stringOfList f l = f (pipe List.map l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 110, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat f (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 111, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat l (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[]\" (List.map f l);;\n"}
{"hw": "hw3", "index": 112, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[]\" (List.map f l);;\n"}
{"hw": "hw3", "index": 113, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw2", "index": 114, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expwn of expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildExpwn e = Expwn e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildTan (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 115, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Expwn e -> phi ** (eval (e, x, y))\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expwn of expr\n  | Tan of expr;;\n\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Expwn e -> phi ** (eval (e, x, y))\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n"}
{"hw": "hw2", "index": 116, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ (\"2\" ^ \")\"))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Expwn e -> \"phi^\" ^ (exprToString e)\n  | Tan e -> \"tan(pi*\" ^ ((exprToString e) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Expwn of expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ (\"2\" ^ \")\"))))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Expwn e -> \"phi^\" ^ (exprToString e)\n  | Tan e -> \"tan(pi*\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 117, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g =\n       let self = f b in\n       match self with | b -> (self, true) | _ -> (self, false) in\n     (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let self = f b in\n       match b with | self -> (self, false) | _ -> (self, true) in\n     (g, b));;\n"}
{"hw": "hw2", "index": 118, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\n     (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | f -> if f = b then (f, false) else (f, true) in\n     (g, b));;\n"}
{"hw": "hw2", "index": 119, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | b -> if f = b then (f, false) else (f, true) in\n     (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | f -> if f = b then (f, false) else (f, true) in\n     (g, b));;\n"}
{"hw": "hw2", "index": 120, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let c' = f b in let b' = b in if c' = b then c' else wwhile (c', b');;\n", "fix": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\n"}
{"hw": "hw3", "index": 121, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), 1) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 122, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 123, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 124, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 125, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 126, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 127, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 128, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 129, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 130, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 131, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 132, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 133, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 134, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | [] -> (0, (if carry > 0 then carry :: num else num))\n      | h::t ->\n          let (l1',l2') = h in\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 135, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f x a =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 136, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + (carry print_int l1') in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 137, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = x in\n      let (l1',l2') = a in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 138, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,num) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 139, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,num) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 140, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l1 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,num) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 141, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 142, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 143, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine [0; l1] [0; l2] in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 144, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith Printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 145, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 146, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 147, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.kprintf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 148, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf (\"hi %d\" carry))\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 149, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %s\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\\n\" addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 150, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\" in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%d\";\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 151, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\" addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%d\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 152, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\", addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%d\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 153, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 154, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf;\n      Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 155, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 156, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 157, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s \" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\";\n      Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 158, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\";\n      Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 159, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf \"%d\\n\" addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 160, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf \"%d\\n\" addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 161, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf string_of_int addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 162, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 163, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 164, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit (x * place) l1 in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 165, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit ((x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 166, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a (mulByDigit (x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 167, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 168, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 169, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), (((clone 0) - diff) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n"}
{"hw": "hw3", "index": 170, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet id y = y;;\n\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (fun x  -> h (acc x)) tl in\n  iter id fs;;\n"}
{"hw": "hw3", "index": 171, "problem": "pipe", "bad": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n", "fix": "\nlet id y = y;;\n\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (fun x  -> h (acc x)) tl in\n  iter id fs;;\n"}
{"hw": "hw3", "index": 172, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a + x) ^ 2 in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 173, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 174, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 175, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet stringOfList f l = \"[\" ^ ((List.fold_left (^) \"\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 176, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  (\"[\" (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) List.fold_left (^) \"\"\n     (List.map f l))\n    ^ \"]\";;\n", "fix": "\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_left (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) \"\"\n        (List.map f l))\n       ^ \"]\");;\n"}
{"hw": "hw3", "index": 177, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_right (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) \"\"\n        (List.map f l))\n       ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_right (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) (List.map f l)\n        \"\")\n       ^ \"]\");;\n"}
{"hw": "hw2", "index": 178, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 179, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           ((\"<\" exprToString y) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw3", "index": 180, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else bigAdd (mulByDigit (i - 2) l) ((mulByDigit i) - (2 l));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1 then l else bigAdd (mulByDigit (i - 2) l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 181, "problem": "padZero", "bad": "\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n"}
{"hw": "hw1", "index": 182, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n = additivePersistence (n, 0);;\n", "fix": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n"}
{"hw": "hw1", "index": 183, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 184, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 185, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n"}
{"hw": "hw1", "index": 186, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n"}
{"hw": "hw1", "index": 187, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 188, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 189, "problem": "listReverse", "bad": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l);;\n"}
{"hw": "hw1", "index": 190, "problem": "listReverse", "bad": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l);;\n"}
{"hw": "hw1", "index": 191, "problem": "listReverse", "bad": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l);;\n"}
{"hw": "hw1", "index": 192, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l);;\n"}
{"hw": "hw1", "index": 193, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tl -> listReverse (hd :: l);;\n"}
{"hw": "hw1", "index": 194, "problem": "listReverse", "bad": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n"}
{"hw": "hw1", "index": 195, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n"}
{"hw": "hw1", "index": 196, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n"}
{"hw": "hw1", "index": 197, "problem": "listReverse", "bad": "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "fix": "\nlet join x l = l :: x;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n"}
{"hw": "hw1", "index": 198, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n"}
{"hw": "hw1", "index": 199, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n"}
{"hw": "hw1", "index": 200, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> 0 | hd::tl -> (listReverse tl) :: hd;;\n", "fix": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in let y = removeLast l in x :: (listReverse y);;\n"}
{"hw": "hw1", "index": 201, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | h1::h2::t -> h1 + (h2 sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 202, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (1 sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 203, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 204, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw1", "index": 205, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> 1 sumList xs';;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n"}
{"hw": "hw2", "index": 206, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildX ();;\n"}
{"hw": "hw2", "index": 207, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildX ();;\n"}
{"hw": "hw2", "index": 208, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildX ();;\n"}
{"hw": "hw2", "index": 209, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let temp = (rand (0, 1)) = 0 in if temp then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> buildX ();;\n"}
{"hw": "hw2", "index": 210, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in build (rand, (y - 1));;\n"}
{"hw": "hw2", "index": 211, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 212, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 213, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y == 2 then buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 214, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then 5;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 215, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 216, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 217, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 218, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 219, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 220, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in y = 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 221, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let y = rand (2, 6) in\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else if y = 2 then y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 222, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 223, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 224, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in buildX ());;\n"}
{"hw": "hw2", "index": 225, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n"}
{"hw": "hw2", "index": 226, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Div7 of expr\n  | MultDivPi of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | MultDivPi (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))) /. pi\n  | Div7 e1 -> (eval (e1, x, y)) /. 7.0\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n"}
{"hw": "hw2", "index": 227, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = if b = (f b) then b else fixpoint (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = ((f b), (b != (f b))) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 228, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = ((f b), (b != (f b))) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 229, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | aPrime -> if b = aPrime then b else fixpoint (f, aPrime);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' b = ((f b), (b != (f b))) in wwhile (f', b);;\n"}
{"hw": "hw2", "index": 230, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then b' else f b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 231, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let result = rand 0 1 in (if result = 0 then buildX () else buildY ())\n  else\n    (let result = rand 0 6 in\n     match result with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let result = rand (0, 1) in (if result = 0 then buildX () else buildY ())\n  else\n    (let result = rand (0, 6) in\n     match result with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 232, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 233, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 234, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval a in if result = 0. then 0 else 1 /. result\n  | Max (a,b) ->\n      let aResult = eval a in\n      let bResult = eval b in if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval a in\n      let bResult = eval b in\n      let cResult = eval c in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0. else 1. /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n"}
{"hw": "hw2", "index": 235, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0 else 1 /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0. else 1. /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n"}
{"hw": "hw2", "index": 236, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0. else 1 /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0. else 1. /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n"}
{"hw": "hw2", "index": 237, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Inverse a -> \"1/\" ^ (exprToString a)\n  | Max (a,b) ->\n      \"max(\" ^ ((exprToString a) ^ (\",\" ^ ((exprToString b) ^ \")\")))\n  | Range (a,b,c) ->\n      \"range(\" ^\n        ((exprToString a) ^\n           ((\",\" exprToString b) ^ (\",\" ^ ((exprToString c) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Inverse a -> \"1/\" ^ (exprToString a)\n  | Max (a,b) ->\n      \"max(\" ^ ((exprToString a) ^ (\",\" ^ ((exprToString b) ^ \")\")))\n  | Range (a,b,c) ->\n      \"range(\" ^\n        ((exprToString a) ^\n           (\",\" ^ ((exprToString b) ^ (\",\" ^ ((exprToString c) ^ \")\")))));;\n"}
{"hw": "hw1", "index": 238, "problem": "additivePersistence", "bad": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let x = 0 in if n < 10 then x else additivePersistence (digits n);;\n", "fix": "\nlet rec additivePersistence n =\n  let x = 0 in if n < 10 then x else additivePersistence (n - 50);;\n"}
{"hw": "hw1", "index": 239, "problem": "additivePersistence", "bad": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "fix": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 240, "problem": "additivePersistence", "bad": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits n\n  else additivePersistence sumList n;;\n", "fix": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 241, "problem": "additivePersistence", "bad": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence sumList n;;\n", "fix": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 242, "problem": "additivePersistence", "bad": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList n);;\n", "fix": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 243, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | [] -> [] | n -> if n > 0 then 0;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n"}
{"hw": "hw1", "index": 244, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n"}
{"hw": "hw1", "index": 245, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then true;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n"}
{"hw": "hw1", "index": 246, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (n + (digitsOfInt n)) - 1;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if x < 10 then [x] else x :: (digitsOfInt y));;\n"}
{"hw": "hw1", "index": 247, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else x @ (digitsOfInt y));;\n", "fix": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n"}
{"hw": "hw1", "index": 248, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 249, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 1;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n"}
{"hw": "hw1", "index": 250, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 2;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n"}
{"hw": "hw1", "index": 251, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if (sumList (digitsOfInt n)) > 9 then 20;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n"}
{"hw": "hw1", "index": 252, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then sumList (digitsOfInt n);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n"}
{"hw": "hw1", "index": 253, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then sumList [1; 2];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9 then 0 else 1;;\n"}
{"hw": "hw1", "index": 254, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (sumList (digitsOfInt (digitsOfInt n)))\n  else 1;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 1;;\n"}
{"hw": "hw1", "index": 255, "problem": "additivePersistence", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence sumList (digitsOfInt n)) + 1 else 0;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n > 9 then (additivePersistence (sumList (digitsOfInt n))) + 1 else 0;;\n"}
{"hw": "hw1", "index": 256, "problem": "digitalRoot", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then sumList (digitsOfInt (sumList (digitsOfInt n)))\n  else 0;;\n"}
{"hw": "hw1", "index": 257, "problem": "digitalRoot", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = if n > 9 then digitalRoot (sumList n) else n;;\n", "fix": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n > 9 then digitalRoot (sumList (digitsOfInt n)) else n;;\n"}
{"hw": "hw1", "index": 258, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = match n with | _ when n < 0 -> [];;\n"}
{"hw": "hw1", "index": 259, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | [] -> [] | h::t -> if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = match n with | _ when n < 0 -> [];;\n"}
{"hw": "hw1", "index": 260, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | [] -> [] | _ -> if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = match n with | _ when n < 0 -> [];;\n"}
{"hw": "hw1", "index": 261, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | _ -> if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = match n with | _ when n < 0 -> [];;\n"}
{"hw": "hw1", "index": 262, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 263, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 264, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 265, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10); []];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 266, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 267, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [(digitsOfInt n) mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 268, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else [digitsOfInt (n mod 10); digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 269, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 270, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 271, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; [digitsOfInt (n / 10)]];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 272, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 273, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [((digitsOfInt (n / 10)), (n mod 10))];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 274, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10];;\n"}
{"hw": "hw1", "index": 275, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> ([n mod 10], (digitsOfInt (n / 10)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 276, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [n mod 10; digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 277, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 278, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else ((listReverse n) mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 279, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse digitsOfInt (n / 10));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 280, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else if n > 9 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 281, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse digitsOfInt (n / 10));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (listReverse (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 282, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> listReverse (h :: l) t;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n"}
{"hw": "hw1", "index": 283, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 284, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: l;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 285, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: l;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 286, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 287, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (l listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 288, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: l;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [];;\n"}
{"hw": "hw1", "index": 289, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (l listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [];;\n"}
{"hw": "hw1", "index": 290, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n"}
{"hw": "hw1", "index": 291, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> listReverse (h :: l) t;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse (h :: l);;\n"}
{"hw": "hw1", "index": 292, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; listReverse t];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 293, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (listReverse t) | [] -> [];;\n"}
{"hw": "hw1", "index": 294, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [l] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (listReverse t) | [] -> [];;\n"}
{"hw": "hw1", "index": 295, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [l] | h::t -> h :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (listReverse t) | [] -> [];;\n"}
{"hw": "hw1", "index": 296, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (l listReverse t) | [] -> [];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 297, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | h::t -> h :: (l listReverse t) | [] -> l;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 298, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 299, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> l | h::t -> h;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | h::t -> [h];;\n"}
{"hw": "hw1", "index": 300, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 301, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse (listReverse h));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse (listReverse l));;\n"}
{"hw": "hw1", "index": 302, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 303, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t [h]);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 304, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append ((listReverse t), [h]);;\n", "fix": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append [h] [h];;\n"}
{"hw": "hw1", "index": 305, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t [h]);;\n", "fix": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append [h] [h];;\n"}
{"hw": "hw1", "index": 306, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t; [h]);;\n", "fix": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append [h] [h];;\n"}
{"hw": "hw1", "index": 307, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "fix": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append [h] [h];;\n"}
{"hw": "hw1", "index": 308, "problem": "listReverse", "bad": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 309, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 310, "problem": "sumList", "bad": "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw2", "index": 311, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 312, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 313, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 314, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 315, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 316, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | buildX -> x\n  | buildY -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e1, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 317, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 318, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 319, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 320, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 321, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 322, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) / (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) * (eval (e2, x, y))) / (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 323, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) / (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) /. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 324, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Tan e1 -> tan (pi *. (eval (e1, x, y)))\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      - (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Tan e1 -> tan (pi *. (eval (e1, x, y)))\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 325, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 326, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ (exprToString e);;\n"}
{"hw": "hw2", "index": 327, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 328, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else (((f b), true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 329, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else ((b, true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 330, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else (b, true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 331, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile ((helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 332, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if x = (f x) then (x, false) else ((f x), true) in\n  wwhile (helper, b);;\n"}
{"hw": "hw2", "index": 333, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = (f x) then (x, false) else (((f x), true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = (f x) then (x, false) else ((f x), true)), b);;\n"}
{"hw": "hw2", "index": 334, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 335, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 336, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos ((pi *. (eval e)), x, y)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 337, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 338, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 339, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) -> ((sqrt e1) *. (sqrt e2)) *. e3\n  | MyExpr2 e -> e *. 0.5;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, y))) *. (sqrt (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> (eval (e, x, y)) *. 0.5;;\n"}
{"hw": "hw2", "index": 340, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((Cosine (eval (e1, x, y))) *. (Sine (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> sin ((pi *. (eval (e, x, y))) *. 0.5);;\n"}
{"hw": "hw2", "index": 341, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> sin ((pi *. (eval (e, x, y))) *. 0.5);;\n"}
{"hw": "hw2", "index": 342, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\" ^ (ex ^ \"\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 343, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^ ((exprToString e2) ^ ((\")*\" exprToString e3) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 344, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ (exprToString ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 345, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = f b in ((xx, (xx = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 346, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 347, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 348, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (((b * b) * b) < 100)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 349, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (b < 100)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 350, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), false), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 351, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n"}
{"hw": "hw2", "index": 352, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f x in (d, (x = d)) in g b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n"}
{"hw": "hw2", "index": 353, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (func, boo) else value;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n"}
{"hw": "hw2", "index": 354, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile func else value;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n"}
{"hw": "hw2", "index": 355, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let func = f b in let (value,boo) = func in if boo then wwhile f else value;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n"}
{"hw": "hw3", "index": 356, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 357, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 358, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 359, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> (sum / 10) :: (sum mod 10)) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 360, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 361, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 362, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 363, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 364, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 365, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a = x a in let base x1 = x1 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 366, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 367, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 368, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map (f l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n"}
{"hw": "hw3", "index": 369, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 370, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 371, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then\n        (if rem = 1\n         then (0, (1 :: acc))\n         else\n           (let (el1,el2) = x in\n            let new_sum = (rem + el1) + el2 in\n            let new_rem = if new_sum > 9 then 1 else 0 in\n            let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n            (new_rem, (norm_sum :: acc)))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = (List.length l1)) ||\n          ((List.length acc) = (List.length l2))\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 372, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = (List.length l1)) ||\n          ((List.length acc) = (List.length l2))\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 373, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 374, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (List.length acc) = ((List.length List.combine (padZero l1 l2)) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = (List.length larger)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 375, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        (List.length acc) =\n          ((List.length (List.combine (padZero l1 l2))) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = (List.length larger)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 376, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum @ acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 377, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone n) - 1);;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 378, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone ((x n) - 1));;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 379, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 380, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 381, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 382, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, (((clone 0 lenl1) - lenl2) @ l2))\n  else ((((clone 0 lenl2) - lenl1) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 383, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "fix": "\nlet y x = x + 1;;\n\nlet q x = y x;;\n\nlet pipe fs =\n  let f a x el = x (a q) in let base g q = q in List.fold_left f base fs;;\n"}
{"hw": "hw1", "index": 384, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = [(digitsOfInt n) / 10] @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 385, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n = (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 386, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n = (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 387, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n"}
{"hw": "hw1", "index": 388, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n"}
{"hw": "hw1", "index": 389, "problem": "palindrome", "bad": "\nlet rec concat w = match w with | [] -> \"\" | h::t -> h ^ (concat t);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (concat (listReverse (explode w))) == w;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n"}
{"hw": "hw2", "index": 390, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rand (2, 7) with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 391, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) /. 2) + ((eval (e2, x, y)) /. 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 392, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) + ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 393, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Chunky of expr* expr* expr\n  | Monkey of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Chunky (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Monkey (e1,e2) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then (-1) else 1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Chunky of expr* expr* expr\n  | Monkey of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Chunky (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Monkey (e1,e2) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then (-1.0) else 1.0;;\n"}
{"hw": "hw2", "index": 394, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" exprToString expr2)\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 395, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^\n                       (\":\" ^ ((exprToString expr4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 396, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 397, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 398, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 399, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let b' = f b in if b' = b then f b else ((f b'), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 400, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 401, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile ((f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 402, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 403, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 404, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 405, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 406, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 407, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1 /. (1 - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 408, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 409, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 410, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp (- a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 411, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp (- (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. -. (exp ((-1.) *. (eval (a, x, y)))))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 412, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let fb = f b in ((fb, (fb = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n"}
{"hw": "hw2", "index": 413, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let fb = f b in (fb, (fb = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n"}
{"hw": "hw2", "index": 414, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let w b = let fb = f b in (fb, (fb = b)) in f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n"}
{"hw": "hw2", "index": 415, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n"}
{"hw": "hw2", "index": 416, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build (rand * 3)), (depth - 1)),\n          (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 417, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 418, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 419, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 420, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 421, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 422, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.sprintf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 423, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> if rand > 1 then buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 424, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 425, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"}
{"hw": "hw2", "index": 426, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"}
{"hw": "hw2", "index": 427, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildCosine (rand, (depth - 1)))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildSine (build (rand, (depth - 1))))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"}
{"hw": "hw2", "index": 428, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (buildCosine (rand, (depth - 1)))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildSine (build (rand, (depth - 1))))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"}
{"hw": "hw2", "index": 429, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildSine (build (rand, (depth - 1))))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"}
{"hw": "hw2", "index": 430, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth num));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth - num));;\n"}
{"hw": "hw2", "index": 431, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (1, 10) in\n    (if (num mod 2) = 0 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with | _ -> build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 432, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then buildPercent (rand, (depth - 1))\n         else\n           if (num mod 3) = 0\n           then buildNegate (rand, (depth - 1))\n           else\n             buildSumSquared\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildNegate e = Negate e;;\n\nlet buildPercent e = Percent e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSumSquared (e1,e2,e3) = SumSquared (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (1, 10) in (if num > 4 then buildX () else buildY ())\n  else\n    (let num = rand (1, 10) in\n     match num with\n     | 1|2 -> buildSine (build (rand, (depth - 1)))\n     | 3|4 -> buildCosine (build (rand, (depth - 1)))\n     | 5|6 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7|8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if (num mod 2) = 0\n         then buildPercent (build (rand, (depth - 1)))\n         else\n           if (num mod 3) = 0\n           then buildNegate (build (rand, (depth - 1)))\n           else\n             buildSumSquared\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 433, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 434, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x *. 1.0\n  | VarY  -> y *. 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 435, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 436, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (2 * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 437, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 438, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n"}
{"hw": "hw2", "index": 439, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 440, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %d \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 441, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 442, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %lf \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 443, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 444, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.printf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 445, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 446, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 447, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 448, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 449, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      if 1 then (sin (pi *. (eval (e1, x, y))); Printf.printf \"sine is \")\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"}
{"hw": "hw2", "index": 450, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) * (-1)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) * (eval (e1, x, y))) +\n         ((eval (e2, x, y)) * (eval (e2, x, y))))\n        + ((eval (e3, x, y)) * (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n         ((eval (e2, x, y)) *. (eval (e2, x, y))))\n        +. ((eval (e3, x, y)) *. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 451, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) * (eval (e1, x, y))) +\n         ((eval (e2, x, y)) * (eval (e2, x, y))))\n        + ((eval (e3, x, y)) * (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) *. (eval (e1, x, y))) +.\n         ((eval (e2, x, y)) *. (eval (e2, x, y))))\n        +. ((eval (e3, x, y)) *. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 452, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | SumPercent (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y))) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumPercent of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | SumPercent (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y))) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n"}
{"hw": "hw2", "index": 453, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> []\n  | VarY  -> []\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3) ->\n      (exprToString e1) ^ ((exprToString e2) ^ (exprToString e3));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n"}
{"hw": "hw2", "index": 454, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3) ->\n      (exprToString e1) ^ ((exprToString e2) ^ (exprToString e3));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n"}
{"hw": "hw2", "index": 455, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\"\n  | VarY  -> \"\"\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n"}
{"hw": "hw2", "index": 456, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != b)) in (g, b));;\n"}
{"hw": "hw2", "index": 457, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != b)) in (g, b));;\n"}
{"hw": "hw2", "index": 458, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != b)) in (g, b));;\n"}
{"hw": "hw2", "index": 459, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else c';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else c';;\n"}
{"hw": "hw1", "index": 460, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n"}
{"hw": "hw1", "index": 461, "problem": "palindrome", "bad": "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse w) then true else false;;\n", "fix": "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n"}
{"hw": "hw3", "index": 462, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 463, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 464, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 465, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 466, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 467, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr\n  | Foo of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Negate e -> (eval (e, x, y)) *. (-1)\n  | Foo (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. ((eval (e2, x, y)) *. (eval (e3, x, y)))) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr\n  | Foo of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Negate e -> (eval (e, x, y)) *. (-1.0)\n  | Foo (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. ((eval (e2, x, y)) *. (eval (e3, x, y)))) /. 2.0;;\n"}
{"hw": "hw2", "index": 468, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"x\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n"}
{"hw": "hw2", "index": 469, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"%s\" x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n"}
{"hw": "hw2", "index": 470, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine ex -> sin exprToString ex;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin\" ^ (exprToString ex);;\n"}
{"hw": "hw2", "index": 471, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> sin (exprToString ex);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin\" ^ (exprToString ex);;\n"}
{"hw": "hw2", "index": 472, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (((f b), (b = (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let bb = f b in (bb, (bb = b)) in (g, b));;\n"}
{"hw": "hw2", "index": 473, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let bb = f b in (bb, (bb = b)) in (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let bb = f b in (bb, (bb = b)) in (g, b));;\n"}
{"hw": "hw2", "index": 474, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g = let bb = f b in (bb, (bb = b)) in (g, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let bb = f x in (bb, (bb = x)) in (g, b));;\n"}
{"hw": "hw3", "index": 475, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 476, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 477, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 478, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 479, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::(x3,x4)::t -> (x1 + (x2 mod 10)) :: a\n      | (x1,x2)::[] -> (x1 + (x2 / 10)) :: (x1 + (x2 mod 10)) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 480, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 481, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 482, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 483, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 484, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::ht = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 485, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 486, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 487, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 488, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = h in\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 489, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> a | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 490, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> a | [] -> a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 491, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 492, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 493, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 494, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let h::_ = a1 in\n      let tens = (x1 + x2) + (h / 10) in\n      let ones = (x1 + x2) + (h mod 10) in ((tens :: a1), (ones :: a2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 495, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((carry :: a1), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((tens :: carry), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 496, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x2 with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 497, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 498, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = x in\n          let (carry,res) = a in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in\n          if t = []\n          then (0, (tens :: ones :: res))\n          else ((tens :: carry), (ones :: res))\n      | [] -> a in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 499, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 500, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 501, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 502, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in\n      ([tens], (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 503, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let tens = ((x1 + x2) + carry) / 10 in\n        let ones = ((x1 + x2) + carry) mod 10 in\n        ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let ch::_ = carry in\n        let tens = ((x1 + x2) + ch) / 10 in\n        let ones = ((x1 + x2) + ch) mod 10 in ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 504, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else n :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 505, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <> 0 then mulByDigit (i - 1) (bigAdd l l) else l;;\n"}
{"hw": "hw3", "index": 506, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper 0 i l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper [0] i l;;\n"}
{"hw": "hw3", "index": 507, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then x1 @ (clone 0 (x2 - x1)) else x2 @ (clone 0 (x1 - x2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then ((l1 @ (clone 0 (x2 - x1))), l2)\n  else (l1, (l2 @ (clone 0 (x1 - x2))));;\n"}
{"hw": "hw3", "index": 508, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x q = x (a q) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 509, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x q = x (a q) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 510, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+) x in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 511, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+) x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 512, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 513, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 514, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (int_of_float ((float_of_int x) ** 2.0)) in\n  let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 515, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n"}
{"hw": "hw3", "index": 516, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\" List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n"}
{"hw": "hw3", "index": 517, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n"}
{"hw": "hw3", "index": 518, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map (f l) in sepConcat \";\" x;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n"}
{"hw": "hw3", "index": 519, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map f l in sepConcat \";\" x;;\n"}
{"hw": "hw2", "index": 520, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 -> buildAverage (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n"}
{"hw": "hw2", "index": 521, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> VarX\n  | 7 -> VarY;;\n"}
{"hw": "hw2", "index": 522, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (7, 9) else (1, 7)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 -> buildECosSin (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 7 -> VarX\n  | 8 -> VarY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (7, 9) else (1, 7)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 -> VarX\n  | 8 -> VarY;;\n"}
{"hw": "hw2", "index": 523, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildECosSin (a,b) = ECosSin (a, b);;\n\nlet buildSinLog (a,b,c) = SinLog (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (8, 10) else (1, 8)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildECosSin ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildSinLog\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))))\n  | 8 -> VarX\n  | 9 -> VarY;;\n"}
{"hw": "hw2", "index": 524, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi * (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 525, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 526, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 527, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 528, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        - 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0;;\n"}
{"hw": "hw2", "index": 529, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100.0)) **\n           (sin ((eval (b, x, y)) *. 100.0)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100.0)) **\n              (sin ((eval (a, x, y)) *. 100.0)))\n             -. 1.0);;\n"}
{"hw": "hw2", "index": 530, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0.0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100.0)) **\n           (sin ((eval (b, x, y)) *. 100.0)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100.0)) **\n              (sin ((eval (a, x, y)) *. 100.0)))\n             -. 1.0);;\n"}
{"hw": "hw2", "index": 531, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100)) **\n              (sin ((eval (a, x, y)) *. 100)))\n             -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100.0)) **\n           (sin ((eval (b, x, y)) *. 100.0)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100.0)) **\n              (sin ((eval (a, x, y)) *. 100.0)))\n             -. 1.0);;\n"}
{"hw": "hw2", "index": 532, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs (eval (a', x, y)) in\n      let b = abs (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n"}
{"hw": "hw2", "index": 533, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"}
{"hw": "hw2", "index": 534, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"}
{"hw": "hw2", "index": 535, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"}
{"hw": "hw2", "index": 536, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"}
{"hw": "hw2", "index": 537, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"}
{"hw": "hw2", "index": 538, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"}
{"hw": "hw2", "index": 539, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"}
{"hw": "hw2", "index": 540, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 - 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"}
{"hw": "hw2", "index": 541, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 -. 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let max' a b = if a < b then b else a in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max' 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"}
{"hw": "hw2", "index": 542, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 543, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 544, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 545, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), true), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 546, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), (failwith \"asd\")), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 547, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), undefined), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 548, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else (((f b), true), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 549, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else ((failwith \"asd\"), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 550, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), false) else failwith \"asd\"), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 551, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then ((failwith \"asd\"), true) else failwith \"asd\"), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 552, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then (true, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 553, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 554, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then ((failwith \"Asd\"), (failwith \"asd\"))\n      else failwith \"asd\"), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then fun b''  -> ((f b), false)\n      else (fun b''  -> ((f b), true))), b);;\n"}
{"hw": "hw2", "index": 555, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval (e, x, y)))\n  | Cosine e -> cos (pi * (eval (e, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)));;\n"}
{"hw": "hw2", "index": 556, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 557, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 558, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 559, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      (float_of_int ((eval (e1, x, y)) + (eval (e2, x, y)))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 560, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 561, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 562, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString d) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sine(pi*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 563, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString e) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sine(pi*\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 564, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ ((\"+\" exprToString e4) ^ \")/2)\"));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")));;\n"}
{"hw": "hw2", "index": 565, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"**\" ^ ((exprToString e2) ^ \")\")))\n  | AddThree (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ ((\"+\" exprToString e3) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"**\" ^ ((exprToString e2) ^ \")\")))\n  | AddThree (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 566, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (blah, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 567, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> fun b  -> if (f b) = b then (b, true) else ((y b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 568, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 569, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun b  -> ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 570, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 571, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 572, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 573, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 574, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 575, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> let x = f b in if x = b then ((x, true), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 576, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun b  -> let x = f b in if x = b then (x, true) else ((y x), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 577, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun x  -> let z = f x in if z = b then (x, true) else ((y z), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 578, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 579, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun x  -> (((f x), ((f x) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 580, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun x  -> ((f x), ((f x) != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw2", "index": 581, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet x = 1.0;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in ((y x), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (let y x = let xx = f x in (xx, (xx != x)) in (y, b));;\n"}
{"hw": "hw3", "index": 582, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 583, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 584, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 585, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 586, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [0] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 587, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 588, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 589, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [((), ())] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 590, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 591, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 592, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 593, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = [((List.rev (List.hd l1)), (List.rev (List.hd l2)))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 594, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 595, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 596, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 597, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 598, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = 0 [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 599, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 600, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 601, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 602, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (x :: (sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 603, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 604, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 605, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) :: (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 606, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 607, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10) :: (sum mod 10) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 608, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 609, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split (((sum / 10), (sum mod 10)) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 610, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 611, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 612, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 613, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 614, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 615, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 616, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 617, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 618, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 619, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 620, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length s)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 621, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 622, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = [((), ())]\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 623, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 624, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 625, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 626, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 627, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 628, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 629, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 630, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> ((c + x') + x'') :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 631, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (((c + x') + x'') + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 632, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 633, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 634, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 635, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length s)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 636, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length s)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 637, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length s)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 638, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length l1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 639, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 640, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 641, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l'), l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 642, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 643, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> (t, (bigAdd ((mulByDigit h l') l'))) in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 644, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit h a) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 645, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 646, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 647, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h a')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 648, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 649, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h, l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 650, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 651, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 652, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 653, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 654, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 655, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 656, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 657, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 658, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 659, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 660, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit h l1' a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 661, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, 0) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 662, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev List.hd l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (l1',a') -> (l1', (bigAdd (mulByDigit x l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 663, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd [0];;\n", "fix": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n"}
{"hw": "hw3", "index": 664, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 665, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 666, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 667, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe fs y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 668, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 669, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 670, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 671, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 672, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 673, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 674, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 675, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 676, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 677, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 678, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 679, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 680, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 681, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 682, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 683, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 684, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 685, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a a = a a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 686, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a a = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 687, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 688, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 689, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 690, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 691, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 692, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 693, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 694, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 695, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 696, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 697, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 698, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 699, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 700, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 701, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 702, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \";;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 703, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat (\"; \" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 704, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 705, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \") l l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 706, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 707, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l)) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 708, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 709, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 710, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 711, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 712, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList digits n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList (digits n));;\n"}
{"hw": "hw1", "index": 713, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10 then input else [loop (input / 10); input mod 10] in\n    loop n\n  else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10\n      then [input]\n      else (let y::[] = loop (input / 10) in [y; input mod 10]) in\n    loop n\n  else [];;\n"}
{"hw": "hw1", "index": 714, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"hw": "hw1", "index": 715, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"hw": "hw1", "index": 716, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = lst\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"hw": "hw1", "index": 717, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "fix": "\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n"}
{"hw": "hw2", "index": 718, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine ((build rand), nd));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine (build (rand, nd)));;\n"}
{"hw": "hw2", "index": 719, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval expr x y))\n  | Cosine expr -> cos (pi *. (eval expr x y))\n  | Average (expr,expr1) -> ((eval expr x y) +. (eval expr1 x y)) /. 2\n  | Times (expr,expr1) -> (eval expr x y) *. (eval expr1 x y)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval expr x y) < (eval expr1 x y)\n      then eval expr2 x y\n      else eval expr3 x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 720, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> ((eval (expr x y)) +. (eval (expr1 x y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 721, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> (eval (expr, x, y)) +. (eval (expr1, x, y))\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 722, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 723, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> ((eval (expr, x, y)) +. (eval (expr1, x, y))) / 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 724, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        ((((abs_float r1) +. (abs_float r2)) +. (abs_float r3)) +. 1.)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"}
{"hw": "hw2", "index": 725, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       ((\")\" / \"(abs(\") ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n"}
{"hw": "hw2", "index": 726, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ (\")+\" 1 \")\")))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n"}
{"hw": "hw2", "index": 727, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 728, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g y x =\n       let sec s fi m = if s = fi then (s, (s = (m s))) else (s, false) in\n       sec (y x) x in\n     ((g f b), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 729, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = ((y x), false) in ((g f b), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 730, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g f b), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 731, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g (f b)), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 732, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in (((g (f b)), false), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 733, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x y = ((x y), false) in ((g f b), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 734, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x y = ((y x), false) in ((g b f), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 735, "problem": "fixpoint", "bad": "\nlet g x y = ((y x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 736, "problem": "fixpoint", "bad": "\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 737, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 738, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((b, false), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 739, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g z = (z, false) in ((g b), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 740, "problem": "fixpoint", "bad": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 741, "problem": "fixpoint", "bad": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 742, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), false) in ((h b f), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 743, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), (x = x)) in ((h b f), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 744, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), (x < 100)) in ((h b f), b));;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 745, "problem": "fixpoint", "bad": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 746, "problem": "fixpoint", "bad": "\nlet h x b = ((b x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 747, "problem": "fixpoint", "bad": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "fix": "\nlet h x = ((x * x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 748, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in ((h, false), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), false) in (h, b));;\n"}
{"hw": "hw2", "index": 749, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let h a = ((f a), false) in h b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = ((f x), false) in (h, b));;\n"}
{"hw": "hw2", "index": 750, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 751, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev helper ([], l);;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 752, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f b with | (a,c) -> if not c then a else f a;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n"}
{"hw": "hw2", "index": 753, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile f a;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n"}
{"hw": "hw2", "index": 754, "problem": "assoc", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) ^ \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ (\"*\" ^ ((exprToString tm3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 755, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"X\"\n  | VarY  -> \"Y\"\n  | Sine sin -> \"sin\"\n  | Cosine cos -> \"cos\"\n  | Average (n1,n2) -> \"(\" ^ (n1 ^ (n2 ^ \"/ 2 )\"))\n  | Times (t1,t2) -> \"(t1 * t2)\"\n  | Thresh (th1,th2,th3,th4) -> \"thresh\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"X\"\n  | VarY  -> \"Y\"\n  | Sine sin -> \"sin\"\n  | Cosine cos -> \"cos\"\n  | Average (n1,n2) -> \"(n1 + n2 / 2 )\"\n  | Times (t1,t2) -> \"(t1 * t2)\"\n  | Thresh (th1,th2,th3,th4) -> \"thresh\";;\n"}
{"hw": "hw2", "index": 756, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"(sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"(cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"( \" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2\")))\n  | Times (t1,t2) ->\n      \"(\" ^ ((exprToString t1) ^ ((\"*\" (exprToString t2)) ^ \")\"))\n  | Thresh (th1,th2,th3,th4) -> \"bullshit\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"(sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"(cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"( \" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2\")))\n  | Times (t1,t2) ->\n      \"(\" ^ ((exprToString t1) ^ (\"*\" ^ ((exprToString t2) ^ \")\")))\n  | Thresh (th1,th2,th3,th4) -> \"bullshit\";;\n"}
{"hw": "hw2", "index": 757, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,tf) -> if tf = true then wwhile (f, num) else num;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let func b =\n        let ans = f b in if b = ans then (ans, false) else (ans, true) in\n      func), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n"}
{"hw": "hw2", "index": 758, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h l\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        if List.mem h seen'\n        then h :: seen\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 759, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h seen\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = l in\n        if List.mem h l\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 760, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 761, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then f param else 0\n  | _ -> b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 762, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f e;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 763, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile e b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 764, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 765, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 766, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match b with | (e,boo) -> if boo = true then e b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 767, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with\n  | (express,boo) -> if boo = true then wwhile (f, express) else express;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,boo) -> if boo = true then wwhile (f, num) else num;;\n"}
{"hw": "hw2", "index": 768, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildY ()) else buildCosine buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildX ()) else buildCosine (buildY ());;\n"}
{"hw": "hw2", "index": 769, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 (buildX ()))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 (buildX ()));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 770, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 ((buildX ()), (buildY ()), (buildX ())))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 ((buildY ()), (buildX ()), (buildY ())));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 771, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 772, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (build (rand, (depth - 1))))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 773, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 774, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 775, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 776, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX rand\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 777, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildCosine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 778, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX ()))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 779, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX rand))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 780, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 781, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | _ -> failwith \"didnt work\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then buildSine (buildX ()) else buildX ();;\n"}
{"hw": "hw2", "index": 782, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (buildX ())\n     | (2,2) -> buildCosine (buildX ())\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n"}
{"hw": "hw2", "index": 783, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))));;\n"}
{"hw": "hw2", "index": 784, "problem": "eval", "bad": "\nlet rec eval (e,x,y) = assert (((-1.0) <= eval) && (eval <= 1.0)); eval;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n"}
{"hw": "hw2", "index": 785, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = string_of_float (exprToString eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n"}
{"hw": "hw2", "index": 786, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString eval);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n"}
{"hw": "hw2", "index": 787, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (((exprToString e) * x) * y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString e);;\n"}
{"hw": "hw2", "index": 788, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 789, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 790, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 791, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) /. 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 792, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Op1 e ->\n      \"((tan(pi*\" ^\n        ((exprToString e) ^ (\"))-(tan(pi*\" ^ ((exprToString e) ^ \"))/2)\")))\n  | Op2 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^\n                       (\":(\" ^\n                          ((exprToString e1) ^\n                             (\"-\" ^ ((exprToString e2) ^ \"))\")))))))));;\n"}
{"hw": "hw2", "index": 793, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun x  -> let xi = f x in (xi, (((f xi) != xi) || (f (f xi))))), b);;\n"}
{"hw": "hw2", "index": 794, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = if (f, b) > 100 then (f, b) else f (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n"}
{"hw": "hw2", "index": 795, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage next next\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}
{"hw": "hw2", "index": 796, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}
{"hw": "hw2", "index": 797, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}
{"hw": "hw2", "index": 798, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}
{"hw": "hw2", "index": 799, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"}
{"hw": "hw2", "index": 800, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> abs next);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAbs e = Abs e;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildAbs next);;\n"}
{"hw": "hw2", "index": 801, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 802, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 803, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 804, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 805, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval e))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 806, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 807, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 808, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 809, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e1, x, y)) * (eval (e2, x, y))))\n        +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 810, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf \"Expression %s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 811, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 812, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((2.0 *. exp) -\n         ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n            (eval (e3, x, y))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 813, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 814, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (((- ((eval (e1, x, y)) -. (eval (e2, x, y)))) ** 2.0) /.\n              (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (-.\n              ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                 (eval (e3, x, y)))));;\n"}
{"hw": "hw2", "index": 815, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 816, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 817, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e \"\" exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 818, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 819, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 820, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 821, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\" exprToString VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\";;\n"}
{"hw": "hw2", "index": 822, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n"}
{"hw": "hw2", "index": 823, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine\\\\(%s\\\\)\" exprToString x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n"}
{"hw": "hw2", "index": 824, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n"}
{"hw": "hw2", "index": 825, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x ->\n      Printf.sprintf \"Sine(%s)\" (exprToString x) exprToString Sine VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n"}
{"hw": "hw2", "index": 826, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times ()|_ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n"}
{"hw": "hw2", "index": 827, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) -> Printf.sprintf \"%s*%s\" exprToString e1 exprToString e2\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n"}
{"hw": "hw2", "index": 828, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(|%s|)^0.5\" (exprToString Abs e)\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n"}
{"hw": "hw2", "index": 829, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Quad (e1,e2,e2) ->\n      Printf.springf \"(%s + %s)^2 + %s\" (exprToString e1) (exprToString e2)\n        (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n"}
{"hw": "hw2", "index": 830, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\" (exprToString e1)\n        (exprToString e2) (exprToString Abs e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s*%s)) - 1)\" (exprToString e1)\n        (exprToString e2) (exprToString e3);;\n"}
{"hw": "hw2", "index": 831, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n"}
{"hw": "hw2", "index": 832, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = ((wwhile (fun xx  -> (xx, ((f xx) = xx)))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n"}
{"hw": "hw2", "index": 833, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' | b' -> b' in\n  acc b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n"}
{"hw": "hw1", "index": 834, "problem": "additivePersistence", "bad": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "fix": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 835, "problem": "additivePersistence", "bad": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "fix": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec addHelp (count,n) =\n  if n < 10 then count + 1 else addHelp ((count + 1), (addNum n));;\n\nlet rec additivePersistence n = addHelp (0, n);;\n"}
{"hw": "hw1", "index": 836, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1 then count else incr count;;\n", "fix": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec addHelp (count,n) =\n  if n < 10 then count + 1 else addHelp ((count + 1), (addNum n));;\n\nlet rec additivePersistence n = addHelp (0, n);;\n"}
{"hw": "hw1", "index": 837, "problem": "additivePersistence", "bad": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else count = (count + (1 additivePersistence (addList (digitsOfInt n))));;\n", "fix": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum n = if n < 10 then n else addList (digitsOfInt n);;\n\nlet rec addHelp (count,n) =\n  if n < 10 then count + 1 else addHelp ((count + 1), (addNum n));;\n\nlet rec additivePersistence n = addHelp (0, n);;\n"}
{"hw": "hw1", "index": 838, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 839, "problem": "digitalRoot", "bad": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot sumDigits n else n;;\n", "fix": "\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot (sumDigits n) else n;;\n"}
{"hw": "hw1", "index": 840, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 841, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 842, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n", "fix": "\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then listReverse ((n mod 10) :: (digitsOfInt (n / 10))) else [];;\n"}
{"hw": "hw1", "index": 843, "problem": "listReverse", "bad": "\nlet rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l);;\n", "fix": "\nlet rec listReverse l = match l with | [] -> l | (_::tail::[])::[] -> l;;\n"}
{"hw": "hw1", "index": 844, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "fix": "\nlet rec listReverse l =\n  let rec listReverseHelper l ans =\n    match ans with | [] -> [] | h::t -> listReverseHelper t (h :: ans) in\n  listReverseHelper l [];;\n"}
{"hw": "hw1", "index": 845, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 846, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 847, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 848, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 849, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | n -> 5 | 0 -> [];;\n", "fix": "\nlet rec digitsOfInt n = match n with | n -> [n];;\n"}
{"hw": "hw1", "index": 850, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (List.hd (n mod 10)) :: ns;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | n -> digitsOfInt (n - (List.hd ((n mod 10) :: ns)));;\n"}
{"hw": "hw1", "index": 851, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (((n mod 10) :: ns) digitsOfInt n) / 10;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 852, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 853, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 854, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 855, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 856, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 857, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [(n mod 10) :: (digitsOfInt (n / 10))];;\n", "fix": "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 858, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | _ -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 859, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"}
{"hw": "hw1", "index": 860, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "fix": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"}
{"hw": "hw1", "index": 861, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "fix": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx n =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"}
{"hw": "hw1", "index": 862, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (listReverse (List.tl l)) :: (List.hd l);;\n", "fix": "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n"}
{"hw": "hw1", "index": 863, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 864, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | _ -> (List.hd xs) + (sumList List.tl) | [] -> [];;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 865, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 866, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 867, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | _ -> (List.hd xs) + 2 | [] -> [];;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 868, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 869, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 870, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw1", "index": 871, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw3", "index": 872, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = (List.combine 0) :: ((List.rev l1) 0) :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (0 :: (List.rev l1)) (0 :: (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 873, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) (0 :: (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 874, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac a in ((ac * 10), (bigAdd mul shift)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac mul in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 875, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit mul ac in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac mul in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 876, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ len2), len1);;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (((clone 0 (len1 - len2)) @ l2), l1)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 877, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (((clone 0 (len1 - len2)) @ l2), l1)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 878, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then clone 0 (len1 - len2)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n", "fix": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (((clone 0 (len1 - len2)) @ l2), l1)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 879, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = f in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 880, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | v -> x (a v) in\n  let base = function | y -> y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 881, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | f' -> f' x a in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | v -> x (a v) in\n  let base = function | y -> y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 882, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | f' -> x (f' a) in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | v -> x (a v) in\n  let base = function | y -> y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 883, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 884, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ^ 2) :: x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 885, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ^ 2.) :: x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 886, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) :: x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 887, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 888, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 889, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 890, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 891, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 892, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 893, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [([], [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 894, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 895, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 896, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, x) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 897, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 898, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 899, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 900, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 901, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([a], a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 902, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a [0] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 903, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 904, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 905, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = 5 in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 906, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 907, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 908, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 909, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match fst a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 910, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 911, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 912, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 913, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 914, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 915, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 916, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 917, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = List.combine l1 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 918, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 919, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 920, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 921, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 922, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t -> ((((fst h) + (snd h)) / 10), (((fst h) + (snd h)) mod 10)) ::\n          t in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 923, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 924, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 925, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 926, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> x | h::t -> x in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 927, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 928, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 929, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 930, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 931, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (_,_) -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 932, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | () -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (_,_) -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 933, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 5 -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (_,_) -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 934, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 'a' -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (_,_) -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 935, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      ((((fst x) + (snd x)) / 10), (((fst a) + (((fst x) + (snd x)) mod 10))\n        :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      ((((fst x) + (snd x)) / 10), (((fst a) + (((fst x) + (snd x)) mod 10))\n        :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 936, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 937, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 938, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit x l1 in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 939, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit x l1 in (0, ((bigAdd x value) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 940, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 941, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f ((0, 0) :: l) base in result;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in result;;\n"}
{"hw": "hw3", "index": 942, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  ((((clone 0 leng1) - leng2) @ l1), (((clone 0 leng2) - leng1) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng1 - leng2)) @ l1), ((clone 0 (leng2 - leng1)) @ l2));;\n"}
{"hw": "hw3", "index": 943, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 944, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 945, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 946, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 947, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 948, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 949, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 950, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x c = x (a c) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 951, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x c = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = [] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 952, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = [] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 953, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x sum x = sum + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw1", "index": 954, "problem": "additivePersistence", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList n));;\n", "fix": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 955, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 956, "problem": "digitsOfInt", "bad": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else n - ((n / 10) * (10 append digitsOfInt (n / 10)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 957, "problem": "digitsOfInt", "bad": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append digitsOfInt (n / 10) (n - ((n / 10) * 10));;\n", "fix": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n - ((n / 10) * 10));;\n"}
{"hw": "hw1", "index": 958, "problem": "palindrome", "bad": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse w))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "fix": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palHelper tlr else false) in\n  palHelper (explode w);;\n"}
{"hw": "hw1", "index": 959, "problem": "palindrome", "bad": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse [w]))\n      then palindrome (List.tl (listReverse [tail]))\n      else false;;\n", "fix": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palHelper tlr else false) in\n  palHelper (explode w);;\n"}
{"hw": "hw1", "index": 960, "problem": "palindrome", "bad": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n", "fix": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palHelper tlr else false) in\n  palHelper (explode w);;\n"}
{"hw": "hw1", "index": 961, "problem": "palindrome", "bad": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "fix": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palHelper tlr else false) in\n  palHelper (explode w);;\n"}
{"hw": "hw1", "index": 962, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n"}
{"hw": "hw3", "index": 963, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append (result / 10) List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append [result / 10] (List.append [result mod 10] l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 964, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append [result / 10] List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append [result / 10] (List.append [result mod 10] l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 965, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with | [] -> [] | h::t -> (cout, (List.append [r] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [r] []))\n      | h::t -> (cout, (List.append [r] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 966, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match a with\n      | [] -> (cout, (List.append [r] l))\n      | h::t -> (cout, (List.append [r] t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [r] l))\n      | h::t -> (cout, (List.append [r] t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 967, "problem": "clone", "bad": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n"}
{"hw": "hw3", "index": 968, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (l2 - l1)) l1), l2)\n  else (l1, (List.append (clone 0 (l1 - l2) l2)));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n"}
{"hw": "hw3", "index": 969, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2) l2)));;\n", "fix": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n"}
{"hw": "hw3", "index": 970, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x i = x (a i) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 971, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x i = x (a i) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 972, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> t in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x i = x (a i) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 973, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x i = x (a i) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 974, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | _ -> x a | [] -> x in\n  let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x i = x (a i) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 975, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h \"to be implemented\" in\n      let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 976, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a ** x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + (x * x) in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw1", "index": 977, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}
{"hw": "hw1", "index": 978, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}
{"hw": "hw1", "index": 979, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n"}
{"hw": "hw1", "index": 980, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> l | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw3", "index": 981, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ initsum)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 982, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  List.rev (removeZero (add (padZero l1 l2)));;\n"}
{"hw": "hw3", "index": 983, "problem": "bigMul", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (List.rev (add (padZero l1 l2)));;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> [carry] @ accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) / 10 in\n        let v = List.rev t in (helpy p v carrying [intKeep]) @ accList in\n  removeZero (helpy i l 0 []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bottom_mult,total) = a in\n    match bottom_mult with\n    | [] -> total\n    | h::t ->\n        let newTotal = mulByDigit h x in\n        let updateTotal = bigAdd newTotal total in (t, updateTotal) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (List.rev (add (padZero l1 l2)));;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> [carry] @ accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) / 10 in\n        let v = List.rev t in (helpy p v carrying [intKeep]) @ accList in\n  removeZero (helpy i l 0 []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (upper_mult,total) = a in\n    let newTotal = mulByDigit x upper_mult in\n    let updateTotal = bigAdd newTotal total in\n    ((upper_mult @ [0]), updateTotal) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 984, "problem": "clone", "bad": "\nlet rec clone x n = if n > 0 then x @ ((clone x n) - 1) else [];;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 985, "problem": "clone", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 986, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 987, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 988, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 989, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 990, "problem": "pipe", "bad": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 991, "problem": "pipe", "bad": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 992, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 993, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 994, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x = a in let base = pipe [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 995, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 996, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 997, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 998, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 999, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x a = x in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1000, "problem": "pipe", "bad": "\nlet pipe fs = let f a x d x = a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1001, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1002, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1003, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1004, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1005, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1006, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1007, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a x = a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1008, "problem": "pipe", "bad": "\nlet pipe fs = let f a x d = a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1009, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1010, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x d x = a x in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1011, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1012, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1013, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base d = d in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1014, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1015, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1016, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1017, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"hw": "hw3", "index": 1018, "problem": "pipe", "bad": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "fix": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"hw": "hw3", "index": 1019, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;\n", "fix": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"hw": "hw3", "index": 1020, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x d = a x d in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "fix": "\nlet pipe fs =\n  let f a x d = d in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"hw": "hw3", "index": 1021, "problem": "pipe", "bad": "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n", "fix": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"hw": "hw3", "index": 1022, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1023, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1024, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1025, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x l = x (a l) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1026, "problem": "pipe", "bad": "\nlet pipe fs = let f a x l x = a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x l = x (a l) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1027, "problem": "pipe", "bad": "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x l = x (a l) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1028, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x l x = x a in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x l = x (a l) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1029, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x l = x (a l) in let base p = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1030, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1031, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1032, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append h sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1033, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1034, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1035, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1036, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = t in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1037, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+.) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1038, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+.) in let base = 0. in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1039, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1040, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1041, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat \"; \" l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 1042, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc d k t;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1043, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc (d k t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1044, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d k t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1045, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1046, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d k t);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1047, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1 then expChooser rand (0, 2) else expChooser rand (2, 7);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1048, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then expChooser rand (0, 2) depth\n  else expChooser rand (2, 7) depth;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1049, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1050, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1051, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1052, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1053, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1054, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((-1) * (eval (e1, x, y))) * (eval (e2, x, y))) * (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1055, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((-1) * (eval (e1, x, y))) * (eval (e2, x, y))) * (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1056, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      float_of_int -\n        (((1 *. (eval (e1, x, y))) *. (eval (e2, x, y))) *. (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1057, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1058, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1059, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((((f b) = b), b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1060, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (true, b) else (false, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1061, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((((f b) = b), (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1062, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), ((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1063, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), true) else (((f b), false), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1064, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), true) else ((f b), false)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1065, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx = ((f b), ((f b) = b)) in wwhile (fx, b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b = ((f b), ((f b) = b)) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1066, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b = ((f b), (not ((f b) = b))) in wwhile (fx, b);;\n"}
{"hw": "hw2", "index": 1067, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x), (not ((f x) = x)), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n"}
{"hw": "hw2", "index": 1068, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x), (not ((f x) = x))), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n"}
{"hw": "hw2", "index": 1069, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x not ((f x) = x)), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n"}
{"hw": "hw2", "index": 1070, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> f x not ((f x) = x)), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n"}
{"hw": "hw2", "index": 1071, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  if snd (f b) then wwhile (f, (fst (f b))) else fst (f b);;\n"}
{"hw": "hw2", "index": 1072, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw3", "index": 1073, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (((fst x) + (snd x)) mod 10) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in [res] in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1074, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in [res] in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1075, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1076, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine List.reverse l1 List.reverse l2 in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n"}
{"hw": "hw3", "index": 1077, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n"}
{"hw": "hw3", "index": 1078, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1079, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1080, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1081, "problem": "clone", "bad": "\nlet rec clone x n = if n < 0 then [] else (clone x n) - 1;;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1082, "problem": "clone", "bad": "\nlet rec clone x n = if n < 0 then [] else clone (x, (n - 1));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1083, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"}
{"hw": "hw3", "index": 1084, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1085, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)) l1)\n  else if diff > 0 then List.append ((clone 0 diff) l2);;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1086, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)), l1)\n  else if diff > 0 then List.append ((clone 0 diff), l2);;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1087, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.append ((clone 0 diff), l2)));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1088, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.combine ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.combine ((clone 0 diff), l2)));;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1089, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1;;\n", "fix": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 1090, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1091, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1092, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> x a) in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1093, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1094, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1095, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a = (fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1096, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1097, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\" l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1098, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 1099, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1100, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1101, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = x ** 2 in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1102, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = x ** 2.0 in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1103, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \";\" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw1", "index": 1104, "problem": "additivePersistence", "bad": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet rec arrayLen l = match l with | [] -> 0 | h::t -> 1 + (arrayLen t);;\n\nlet rec digitSum dl = match dl with | [] -> 0 | h::t -> h + (digitSum t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match (arrayLen (digits n)) = 1 with\n  | true  -> 0\n  | false  -> 1 + (additivePersistence digitSum (digits n));;\n", "fix": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet rec arrayLen l = match l with | [] -> 0 | h::t -> 1 + (arrayLen t);;\n\nlet rec digitSum dl = match dl with | [] -> 0 | h::t -> h + (digitSum t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match (arrayLen (digits n)) = 1 with\n  | true  -> 0\n  | false  -> 1 + (additivePersistence (digitSum (digits n)));;\n"}
{"hw": "hw1", "index": 1105, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> 1;;\n", "fix": "\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> [];;\n"}
{"hw": "hw1", "index": 1106, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1107, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10]\n  | true  -> [];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1108, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> [(digitsOfInt n) / 10; n % 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1109, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10] @ [n % 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1110, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt n div 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1111, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1112, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1113, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) - 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1114, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | h::[] -> h | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 1115, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> [h; listReverse t];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::h::[] -> h :: (listReverse []);;\n"}
{"hw": "hw1", "index": 1116, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::h::[] -> h :: (listReverse []);;\n"}
{"hw": "hw1", "index": 1117, "problem": "palindrome", "bad": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse explode w) then true else false;;\n", "fix": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw2", "index": 1118, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1119, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x') + (eval y')) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1120, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x' y) + (eval x y')) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1121, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval VarX x' y) + (eval VarY x y')) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1122, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval (VarX, x', y)) + (eval (VarY, x, y'))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1123, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1124, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2.0;;\n"}
{"hw": "hw2", "index": 1125, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n"}
{"hw": "hw2", "index": 1126, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n"}
{"hw": "hw2", "index": 1127, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n"}
{"hw": "hw2", "index": 1128, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n"}
{"hw": "hw2", "index": 1129, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (ee3, y, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n"}
{"hw": "hw2", "index": 1130, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (e3, y, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\n        (sqrt (eval (e3, y, y)));;\n"}
{"hw": "hw2", "index": 1131, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 1132, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\n"}
{"hw": "hw2", "index": 1133, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\n           (1.0 /. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1134, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\n           (1.0 /. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1135, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (1 /. (eval (e', x, y)))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (1.0 /. (eval (e', x, y)))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\n           (1.0 /. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1136, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (abs (eval (e', x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (cos (pi *. (eval (e', x, y))));;\n"}
{"hw": "hw2", "index": 1137, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n"}
{"hw": "hw2", "index": 1138, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float\n           (sin\n              (((cos (pi *. (eval (e1, x, y)))) *.\n                  (cos (pi *. (eval (e2, x, y)))))\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\n"}
{"hw": "hw2", "index": 1139, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1140, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1141, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyCube (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyRoot (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n"}
{"hw": "hw1", "index": 1142, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList digitsOfInt n in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n"}
{"hw": "hw1", "index": 1143, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) :: (n % 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1144, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1145, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) @ [n % 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1146, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n == 0\n    then [0]\n    else\n      if (n / 10) == 0 then n mod 10 else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n == 0\n    then [0]\n    else\n      if (n / 10) == 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1147, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n / 10) > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1148, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1149, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1150, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else (let a = n mod 10 in let b = n / 10 in if b = 0 then [n] else [a]);;\n"}
{"hw": "hw1", "index": 1151, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else (let a = n mod 10 in let b = n / 10 in if b = 0 then [n] else [a]);;\n"}
{"hw": "hw1", "index": 1152, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else (let a = n mod 10 in let b = n / 10 in if b = 0 then [n] else [a]);;\n"}
{"hw": "hw1", "index": 1153, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in (digitsOfInt a) :: b);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in let c = [a; b] in c);;\n"}
{"hw": "hw1", "index": 1154, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in let c = [a; b] in if a > 9 then (digitsOfInt a) :: c);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in if a < 10 then c else digitsOfInt (a / 10));;\n"}
{"hw": "hw1", "index": 1155, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> [digitsOfInt x; xs]);;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n"}
{"hw": "hw1", "index": 1156, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> (digitsOfInt x) :: xs);;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n"}
{"hw": "hw1", "index": 1157, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [n.[0]];;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n"}
{"hw": "hw1", "index": 1158, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [n [0]];;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n"}
{"hw": "hw1", "index": 1159, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs ((a mod 10) :: b) in\n  integers n [];;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n"}
{"hw": "hw1", "index": 1160, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (let rec integers a b =\n       if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n     integers n []);;\n"}
{"hw": "hw1", "index": 1161, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n"}
{"hw": "hw1", "index": 1162, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n"}
{"hw": "hw1", "index": 1163, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) :: a;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n"}
{"hw": "hw1", "index": 1164, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n"}
{"hw": "hw1", "index": 1165, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::[] -> [a] | a::b::[] -> b :: (listReverse a);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n"}
{"hw": "hw1", "index": 1166, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> [listReverse b; a];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | b::[] -> [b];;\n"}
{"hw": "hw1", "index": 1167, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> [listReverse b; [a]];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | b::[] -> [b];;\n"}
{"hw": "hw1", "index": 1168, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> 0;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> [a];;\n"}
{"hw": "hw1", "index": 1169, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a] b;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a];;\n"}
{"hw": "hw1", "index": 1170, "problem": "listReverse", "bad": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "fix": "\nlet rec listReverse l =\n  let rec getList a b = match a with | [] -> [] in getList [] l;;\n"}
{"hw": "hw1", "index": 1171, "problem": "listReverse", "bad": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "fix": "\nlet rec listReverse l =\n  let rec getList a b = match a with | [] -> [] in getList [] l;;\n"}
{"hw": "hw1", "index": 1172, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let a = [] in\n  let rec get a = match a with | [] -> [] | x::xs -> [get xs; x] in get l;;\n", "fix": "\nlet rec listReverse l =\n  let rec getList a b = match a with | [] -> [] in getList [] l;;\n"}
{"hw": "hw1", "index": 1173, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in if true then wList;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in\n  if wList = wReverse then true else false;;\n"}
{"hw": "hw1", "index": 1174, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::[] -> x | (x::y)::[] -> x + (sumList y);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw1", "index": 1175, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | (x::y)::[] -> x + (sumList y);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n"}
{"hw": "hw3", "index": 1176, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> [carry2; dig] | h::t -> carry2 :: dig :: t in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1177, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1178, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in match a with | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1179, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, (carry2 :: dig)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, [carry2; dig]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1180, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n"}
{"hw": "hw3", "index": 1181, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n"}
{"hw": "hw3", "index": 1182, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone 0 (length2 - length1)\n  else if length2 < length1 then clone 0 (length1 - length2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n"}
{"hw": "hw3", "index": 1183, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1184, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a t)) in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1185, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1186, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1187, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat \" \" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1188, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1189, "problem": "stringOfList", "bad": "\nlet stringOfList f l = let mid = List.map f l in \"[\" ^ (mid \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 1190, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw1", "index": 1191, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper sumList (digits n) (i + 1) in\n  n;;\n", "fix": "\nlet digitsOfInt n =\n  let rec loop n tlist =\n    if n = 0 then tlist else loop (n / 10) ((n mod 10) :: tlist) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec aPHelper n i =\n    if n < 10 then i else aPHelper (sumList (digits n)) (i + 1) in\n  n;;\n"}
{"hw": "hw1", "index": 1192, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n"}
{"hw": "hw3", "index": 1193, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair (t1, t2))\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1194, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1195, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1196, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1197, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1198, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> (0, 0) in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [(0, 0)] in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1199, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (pair (h1, h2)) :: (acc t1 t2)\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair ((h1, h2) :: acc) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1200, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1201, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> List.append acc (0, 0) in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1202, "problem": "bigMul", "bad": "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          (digitProducts a) :: (acc (place + 1) t l2) in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1203, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1204, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, 0) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1205, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = (0, []) in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1206, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1207, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 1208, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Divide of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello1 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Hello2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Hello1 (e1,e2,e3) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e1, x, y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Hello2 (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e4, x, y)\n      else eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello1 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Hello2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Hello1 (e1,e2,e3) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e1, x, y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Hello2 (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e4, x, y)\n      else eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 1209, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 1210, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match b with | (f',b') -> if b' then wwhile (f, f') else f';;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (f',x') -> if x' then wwhile (f, f') else f';;\n"}
{"hw": "hw2", "index": 1211, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1212, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1213, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1214, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> \"x\" | VarY y -> \"y\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n"}
{"hw": "hw2", "index": 1215, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*%s)\" x\n  | Cosine x -> \"cos(pi*%s)\" x\n  | Average (x,y) -> \"((%s+%s)/2)\" x y\n  | Times (x,y) -> \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,a) ->\n      (exprToString x) ^\n        (\"<\" ^\n           ((exprToString y) ^\n              (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString a))))));;\n"}
{"hw": "hw2", "index": 1216, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n  | Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,a) ->\n      (exprToString x) ^\n        (\"<\" ^\n           ((exprToString y) ^\n              (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString a))))));;\n"}
{"hw": "hw2", "index": 1217, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = wwhile (f, x) in f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, (x = b))), b);;\n"}
{"hw": "hw2", "index": 1218, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1219, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw3", "index": 1220, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1221, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1222, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1223, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1224, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1225, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1226, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1227, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1228, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add l1 l2 =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1229, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: a :: ((w + y) mod 10)\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1230, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = (0, (List.rev (List.combine l1 l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1231, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1232, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1233, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1234, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1235, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1236, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1237, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> (((w + z) + y) / 10) :: (((w + y) + z) mod 10) :: t\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1238, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match x with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1239, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1240, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1241, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1242, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> (z / 10) :: (z mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1243, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> ((z / 10), [z mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1244, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> [z / 10; z mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1245, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1246, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1247, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1248, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> ((z / 10), [z mod 10]) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1249, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"}
{"hw": "hw3", "index": 1250, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"}
{"hw": "hw3", "index": 1251, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: ([0], [0])) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"}
{"hw": "hw3", "index": 1252, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, [z / 10; z mod 10])\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"}
{"hw": "hw3", "index": 1253, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, ((z / 10) :: (z mod 10)))\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, [z / 10; z mod 10])\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"}
{"hw": "hw3", "index": 1254, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd y (mulByDigit (x * (10 ** (List.length y))) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet rec mulByTen n =\n  match n with | 0 -> 0 | 1 -> 10 | _ -> 10 * (mulByTen (n - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) ->\n        (w, (bigAdd y (mulByDigit (x * (mulByTen (List.length y))) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1255, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [] i l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> [0] | 1 -> l | _ -> helper (i - 1) l (bigAdd acc l) in\n  helper i l [0];;\n"}
{"hw": "hw3", "index": 1256, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> [0] | 1 -> l | _ -> helper (i - 1) l (bigAdd acc l) in\n  helper i l [0];;\n"}
{"hw": "hw3", "index": 1257, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> bigAdd lis acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> [0] | 1 -> l | _ -> helper (i - 1) l (bigAdd acc l) in\n  helper i l [0];;\n"}
{"hw": "hw3", "index": 1258, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec adder n li acc =\n    match n with | 1 -> bigAdd li acc | _ -> adder (n - 1) li (bigAdd acc li) in\n  mulByDigit i l [0];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec adder n li acc =\n    match n with | 1 -> bigAdd li acc | _ -> adder (n - 1) li (bigAdd acc li) in\n  adder i l [0];;\n"}
{"hw": "hw3", "index": 1259, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: (h + (c mod 10)) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1260, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1261, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1262, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (x + x) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (b + c) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1263, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, (nextCarry @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, (nextCarry @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1264, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}
{"hw": "hw3", "index": 1265, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"}
{"hw": "hw3", "index": 1266, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 1267, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (\"[\" ^ (sepConcat \"; \" (List.map f l))) & \"]\";;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 1268, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1269, "problem": "listReverse", "bad": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> append_new listReverse tail [head];;\n", "fix": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::tail -> append_new (listReverse tail) [head];;\n"}
{"hw": "hw1", "index": 1270, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 1271, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> [] | head::tail -> head + (sumList tail);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n"}
{"hw": "hw1", "index": 1272, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n count =\n  match n with | [] -> count | _ -> sumList (digitsOfInt n) (count + 1);;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1273, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence (sumList (digitsOfInt n) (count + 1));;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1274, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1275, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n count =\n  match n with\n  | 0 -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1276, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1277, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 1278, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList digitsOfInt n) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n) 0) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n"}
{"hw": "hw1", "index": 1279, "problem": "additivePersistence", "bad": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n)) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "fix": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n) 0) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n"}
{"hw": "hw1", "index": 1280, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | hd::tl -> hd :: (digitsOfInt tl));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1281, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1282, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1283, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [digitsOfInt (n mod 10)]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1284, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1285, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt n]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n"}
{"hw": "hw1", "index": 1286, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n"}
{"hw": "hw2", "index": 1287, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1288, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine buildX\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1289, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1290, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine buildX\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1291, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1292, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1293, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval a))\n  | Cosine a -> cos (pi *. (eval a))\n  | Average (a,b) -> ((eval a) +. (eval b)) / 2\n  | Times (a,b) -> (eval a) *. (eval b)\n  | Thresh (a,b,c,d) -> if (eval a) < (eval b) then eval c else eval d;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1294, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1295, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1296, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | NewA (a,b) ->\n      (sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (b, x, y))))\n  | NewB (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) exp 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | NewA (a,b) ->\n      (sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (b, x, y))))\n  | NewB (a,b,c) ->\n      (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y))) -.\n        (((eval (a, x, y)) +. (eval (b, x, y))) +. (eval (c, x, y)));;\n"}
{"hw": "hw2", "index": 1297, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))))\n  | NewA (a,b) ->\n      s ^\n        (\"sin(pi*\" ^\n           ((exprToString a) ^ (\")*cos(pi*\" ^ ((exprToString b) ^ \")\"))))\n  | NewB (a,b,c) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"+\" ^ ((exprToString b) ^ ((\"+\" + (exprToString c)) ^ \")^0\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewA of expr* expr\n  | NewB of expr* expr* expr;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))))\n  | NewA (a,b) ->\n      s ^\n        (\"sin(pi*\" ^\n           ((exprToString a) ^ (\")*cos(pi*\" ^ ((exprToString b) ^ \")\"))))\n  | NewB (a,b,c) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")^0\"))))));;\n"}
{"hw": "hw2", "index": 1298, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1299, "problem": "removeDuplicates", "bad": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen then seen else List.rev (h :: (List.rev seen)) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1300, "problem": "removeDuplicates", "bad": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if List.mem (h, seen)\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen then seen else List.rev (h :: (List.rev seen)) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1301, "problem": "removeDuplicates", "bad": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen then seen else List.rev (h :: (List.rev seen)) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1302, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen then seen else List.rev (h :: (List.rev seen)) in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 1303, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1304, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1305, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) ->\n          ([], (((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a))\n      | _ -> ([], a) in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1306, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1307, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1308, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1309, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1310, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero [(h1 + h2) / 10; (h1 + h2) mod 10]) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1311, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in\n             ((h1 + 1), ((mul / 10) :: (mul mod 10) :: t2))\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1312, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with\n    | [] -> []\n    | h::t -> ((pos + 1), (bigAdd (mulByDigit ((10 ** pos) * h) l2) total)) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in (pos, l2) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1313, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in (pos, l2) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1314, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in ((pos + 1), (mulByDigit (10 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (int_of_float (10.0 ** (float_of_int pos))) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1315, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in ((pos + 1), (mulByDigit (10.0 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (int_of_float (10.0 ** (float_of_int pos))) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1316, "problem": "bigMul", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (10.0 ** (float_of_int pos)) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (int_of_float (10.0 ** (float_of_int pos))) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1317, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (bigAdd l l) + (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1318, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1319, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ((bigAdd (l l)), (mulByDigit (i - 1) l));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1320, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (bigAdd (l l)) (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 1321, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1322, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1323, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1324, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1325, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1326, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1327, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1328, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1329, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1330, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1331, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1332, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1333, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1334, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1335, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1336, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1337, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1338, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1339, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = y in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1340, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1341, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1342, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1343, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1344, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1345, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1346, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1347, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1348, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1349, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1350, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1351, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith in\n    let base = failwith in\n    let args = failwith in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1352, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1353, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1354, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1355, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1356, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | _ -> [a mod 10] | h::t -> ((a + h) mod 10) :: t in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1357, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> [a mod 10] | h::t -> [(a + h) mod 10] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1358, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1359, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1360, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1361, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1362, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (add1,add2) ->\n          let new_carry = ((carry + add1) + add2) / 10 in\n          let digit = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1363, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1364, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1365, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1366, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1367, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> [((add1 + add2) + a) mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1368, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) mod 10), (((add1 + add2) + a) / 10)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1369, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1370, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) / 10), (((add1 + add2) + a) / 10)) in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1371, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + a) / 10), ((((add1 + add2) + a) mod 10) ::\n                 reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1372, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))\n           | () -> ((carry / 10), ((carry mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))\n           | (_,_) -> ((carry / 10), ((carry mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1373, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | () -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1374, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (_,_) -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1375, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = ()\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1376, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = []\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1377, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length x) = (List.length l1)) or\n                   ((List.length x) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then (0, (carry :: rest))\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1378, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then (0, (carry :: rest))\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1379, "problem": "clone", "bad": "\nlet rec clone x n = if x <= 0 then [] else [clone x];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 1380, "problem": "clone", "bad": "\nlet rec clone x n = if x <= 0 then [] else clone [x] (n - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 1381, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else clone [x] (n - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 1382, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then x else clone [x] (n - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 1383, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1384, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1385, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1386, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in let (_,res) = List.fold_right f base l in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n"}
{"hw": "hw3", "index": 1387, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_right f base (List.rev l) in res;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n"}
{"hw": "hw3", "index": 1388, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0 then (((clone (-1)) * (l l2)), l2) else (l1, (clone l l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) @ l2));;\n"}
{"hw": "hw3", "index": 1389, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) @ l2));;\n"}
{"hw": "hw3", "index": 1390, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1391, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1392, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = x (a z) in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1393, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = x (a z) in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1394, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1395, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x in let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1396, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h ^ sep in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1397, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1398, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = sep in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1399, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ a in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1400, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = sep in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1401, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1402, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.map \"[\") ^ ((sepConcat l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1403, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\" l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1404, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1405, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 1406, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw1", "index": 1407, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList digitsOfInt n) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 1408, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 1409, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 1410, "problem": "digitalRoot", "bad": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot | _ -> r_digitalRoot n (n mod 10));;\n", "fix": "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n 0);;\n"}
{"hw": "hw1", "index": 1411, "problem": "digitalRoot", "bad": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> (r_digitalRoot n) - 1);;\n", "fix": "\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> r_digitalRoot n (-1));;\n"}
{"hw": "hw1", "index": 1412, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1413, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1414, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 1415, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ((n mod 10) []);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n x = if n = 0 then x else loop (n / 10) ((n mod 10) :: x) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n"}
{"hw": "hw1", "index": 1416, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | h::t -> [] @ (h @ (digitsOfInt t)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1417, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0 then [0] else if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1418, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1419, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1420, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | 0 -> [0]\n  | _ -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1421, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1422, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1423, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1424, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10] else []);;\n"}
{"hw": "hw1", "index": 1425, "problem": "digitsOfInt", "bad": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "fix": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (h :: acc) in\n  helper x l [];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 1426, "problem": "digitsOfInt", "bad": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "fix": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (h :: acc) in\n  helper x l [];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 1427, "problem": "digitsOfInt", "bad": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "fix": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (h :: acc) in\n  helper x l [];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 1428, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 1429, "problem": "listReverse", "bad": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "fix": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n"}
{"hw": "hw1", "index": 1430, "problem": "palindrome", "bad": "\nlet palindrome w = if w = [] then true;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 1431, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + t;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n"}
{"hw": "hw1", "index": 1432, "problem": "sumList", "bad": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n"}
{"hw": "hw1", "index": 1433, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::xs -> (List.fold_left x) + xs;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0;;\n"}
{"hw": "hw2", "index": 1434, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ();;\n"}
{"hw": "hw2", "index": 1435, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ();;\n"}
{"hw": "hw2", "index": 1436, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 2) in if r = 0 then buildX else if r = 1 then buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ();;\n"}
{"hw": "hw2", "index": 1437, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 1438, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (pi * x)\n  | Cosine x -> cos (pi * x)\n  | Average (x,y) -> avg ((x + y) / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1439, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (pi *. x)\n  | Cosine x -> cos (pi *. x)\n  | Average (x,y) -> avg ((x + y) / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1440, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a)\n  | Average (a,b) -> avg ((a + b) / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1441, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. VarY);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1442, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1443, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1444, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * a)\n  | Cosine a -> cos (pi *. a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1445, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (Times (pi, a))\n  | Cosine a -> cos (pi *. a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1446, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1447, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (e, x, a))\n  | Cosine a -> cos (pi *. y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (pi *. y);;\n"}
{"hw": "hw2", "index": 1448, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)), (eval (b, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1449, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 1450, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1451, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1452, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Timestwo of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y))\n  | Third a -> 0.33 *. (eal (a, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y))\n  | Third a -> 0.33 *. (eval (a, x, y));;\n"}
{"hw": "hw2", "index": 1453, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"Sine\" ^ (exprToString e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"Sine\" ^ (exprToString e);;\n"}
{"hw": "hw2", "index": 1454, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ ((\"+\" exprToString y) ^ \")/2)\"))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\" ? \" ^\n                    ((exprToString y) ^ (\" : \" ^ ((exprToString z) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\" ? \" ^\n                    ((exprToString y) ^ (\" : \" ^ ((exprToString z) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1455, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x);;\n"}
{"hw": "hw2", "index": 1456, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Timestwo of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x)\n  | Third x -> \"0.33*\" ^ (exprToString x);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x)\n  | Third x -> \"0.33*\" ^ (exprToString x);;\n"}
{"hw": "hw2", "index": 1457, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in h), b);;\n"}
{"hw": "hw2", "index": 1458, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n"}
{"hw": "hw2", "index": 1459, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n"}
{"hw": "hw3", "index": 1460, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1461, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1462, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1463, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [0] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1464, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 9 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1465, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1466, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1467, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1468, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([], []) in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1469, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1470, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1471, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, [new_carry; digit])\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1472, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec argmaker x y =\n      match y with | [] -> [] | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1473, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1474, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1475, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1476, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1477, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1478, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1479, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1480, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1481, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a :: 0) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1482, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd [a; 0] multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1483, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1484, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1485, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = ([0], []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1486, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1487, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1488, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1489, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> x;;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1490, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> [x];;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1491, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> x @ [];;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1492, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> [];;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1493, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1494, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1495, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 1496, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with | true  -> [] | false  -> tx :: (clone tx (tn - 1)) in\n  clonehelper x abs n;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n"}
{"hw": "hw3", "index": 1497, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x abs n;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n"}
{"hw": "hw3", "index": 1498, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1499, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> 0\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1500, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (((hd * i) mod 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1501, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let comb a (hd::tl) = a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1502, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> a | hd::tl -> a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1503, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] :: tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1504, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [[a + hd]; tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1505, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ [tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "fix": "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"}
{"hw": "hw3", "index": 1506, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1507, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1508, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1509, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1510, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1511, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 @ [(clone 0 ((List.length l1) - (List.length l2))) @ [l2]]\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1512, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  | false  -> ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1513, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n"}
{"hw": "hw3", "index": 1514, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1,\n        (List.append ((clone 0 ((List.length l1) - (List.length l2))) l2)))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "fix": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n"}
{"hw": "hw3", "index": 1515, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1516, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1517, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1518, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1519, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = y a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1520, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = a x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1521, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x k = a k x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x k = x (a k) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1522, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x k = a x k in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x k = x (a k) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1523, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x k = x (a k) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1524, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a ** 2 in let base = a in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1525, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (+) in let base = 3 ** 2 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1526, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+) in let base = 2 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1527, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1528, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a ** 2 in let base = f 2 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1529, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1530, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> [] | x::xs' -> f x xs' in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 2 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1531, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = x * x in let base = f 2 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1532, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> hd * hd in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1533, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f 0 xs) xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1534, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 8 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1535, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 8 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1536, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let rec f a x = match xs with | [] -> a | hd::tl -> f (f a hd) tl in\n  let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 4 | hd::tl -> f (f 2 hd) tl in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1537, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = ((+) a) * a in let base = f 2 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in let base = f 9 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1538, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> xs | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1539, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> (f hd hd) + (f tl tl) in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> (f hd hd) + (f (f hd hd) tl) in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1540, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 4 xs in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1541, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1542, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (x * x) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1543, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1544, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> f 0 [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> f 0 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1545, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f - (1 hd) in\n  List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 1546, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 1547, "problem": "digitalRoot", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n = if n < 10 then n else digHelper (sumList n) in\n  digHelper n;;\n", "fix": "\nlet digitsOfInt n =\n  let rec digitsHelper n l =\n    if n = 0 then l else digitsHelper (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n =\n    if n < 10 then n else digHelper (sumList (digitsOfInt n)) in\n  digHelper n;;\n"}
{"hw": "hw1", "index": 1548, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / (10 s));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1549, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1550, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1551, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1552, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> (listHelper t h) :: l2 in\n  listHelper l [];;\n", "fix": "\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n"}
{"hw": "hw1", "index": 1553, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 1554, "problem": "sumList", "bad": "\nlet rec sumList xs = function | [] -> 0 | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw2", "index": 1555, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match rand depth with | (1,d) -> (d = (d - 1)) && (buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1556, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (1,d) -> (d = (d - 1)) && (buildX ())\n  | (2,d) -> (d = (d - 1)) && (buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1557, "problem": "build", "bad": "\nlet rec build (rand,depth) =\n  match rand depth with | (r,0) -> build (r, 0) | (r,d) -> (r, (d - 1));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1558, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1559, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1560, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (r,depth) ->\n      (match r (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (r, (depth - 1)))\n       | 3 -> buildCosine (build (r, (depth - 1)))\n       | 4 ->\n           buildAverage ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 5 -> buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (r, (depth - 1))), (build (r, (depth - 1))),\n               (build (r, (depth - 1))), (build (r, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1561, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match rand depth with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1562, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1563, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (r,0) -> if (r (0, 1)) = 0 then buildX () else buildY ()\n  | (r,depth) ->\n      let r = rand (0, 7) in\n      (match r with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1564, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine  -> buildSine e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1565, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1566, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1567, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1568, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1569, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1570, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX * 1.0 | VarY  -> buildY * 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1571, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX * 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1572, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> (buildX ()) * 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1573, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x * 1.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n"}
{"hw": "hw2", "index": 1574, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> pi * e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1575, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1576, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x * 1.00\n  | VarY  -> y * 1.00\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1577, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float * x\n  | VarY  -> float * y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1578, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y;;\n"}
{"hw": "hw2", "index": 1579, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y;;\n"}
{"hw": "hw2", "index": 1580, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (float (e1 + e2)) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y;;\n"}
{"hw": "hw2", "index": 1581, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((float_of_int e1) +. (float_of_int e2)) / 2\n  | Times (e1,e2) -> (float_of_int e1) *. (float_of_int e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((float_of_int e1) < (float_of_int e2 ?float_of_int e3) : float_of_int\n                                                                  e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y;;\n"}
{"hw": "hw2", "index": 1582, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1583, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1584, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1585, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1586, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) + (e2 * 1.00)) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1587, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) +. (e2 * 1.00)) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 1588, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. e\n  | Cosine e -> pi *. e\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1589, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, VarX, VarY))\n  | Cosine e -> pi *. (eval (e, VarX, VarY))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, x, y))\n  | Cosine e -> pi *. (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1590, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1591, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1. /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1. /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1592, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY @ (\"/\" @ VarX)\n  | Cosine  -> VarX @ (\"/\" @ VarY);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n"}
{"hw": "hw2", "index": 1593, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY ^ (\"/\" ^ VarX)\n  | Cosine  -> VarX ^ (\"/\" ^ VarY);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n"}
{"hw": "hw2", "index": 1594, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n"}
{"hw": "hw2", "index": 1595, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString VarX\n  | Cosine  -> exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n"}
{"hw": "hw2", "index": 1596, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine  -> exprToString e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine e -> exprToString e;;\n"}
{"hw": "hw2", "index": 1597, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n"}
{"hw": "hw2", "index": 1598, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((\"<\" exprToString e2) ^\n              (\" ? \" ^\n                 ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 1599, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x != b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1600, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x <> b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1601, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x > b) or (x < b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1602, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, y) else if x = b then (x, false)),\n      b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1603, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, true) else if x = b then (x, false)),\n      b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1604, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = ((f b) - 1)) then (b, false) in\n      f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1605, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = (f (b - 1))) then (b, false) in\n      f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1606, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x <> b) && ((x, y) <> (f (b - 1)))))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1607, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x <> b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1608, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1609, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x > b) || (x < b)))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1610, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x < 100))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let a x = let xx = f x in (xx, (x <> b)) in a), b);;\n"}
{"hw": "hw2", "index": 1611, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) (h, seen) then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1612, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1613, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1614, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1615, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1616, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1617, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1618, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1619, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (seen, h)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1620, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1621, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (seen h) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1622, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1623, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1624, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ [seen] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1625, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1626, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1627, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1628, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then (seen []) @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1629, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [seen] @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1630, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n"}
{"hw": "hw2", "index": 1631, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  match f with | (x,true ) -> wwhile (f x) | (x,false ) -> x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n"}
{"hw": "hw2", "index": 1632, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = match f with | (n,boo) -> f b;;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n"}
{"hw": "hw2", "index": 1633, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cos u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1634, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1635, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1636, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1637, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi * (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1638, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> ((pi *. (eval u)) * 1) * 1\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1639, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1640, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1641, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n"}
{"hw": "hw2", "index": 1642, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs (eval (u, x, y))) *. (abs (eval (v, x, y)))) *.\n           (abs (eval (w, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs_float (eval (u, x, y))) *. (abs_float (eval (v, x, y)))) *.\n           (abs_float (eval (w, x, y))));;\n"}
{"hw": "hw2", "index": 1643, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs (eval (u, x, y))) *. (abs (eval (v, x, y)))) *.\n           (abs (eval (w, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs_float (eval (u, x, y))) *. (abs_float (eval (v, x, y)))) *.\n           (abs_float (eval (w, x, y))));;\n"}
{"hw": "hw2", "index": 1644, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs (eval (u, x, y))) *. (abs (eval (v, x, y)))) *.\n           (abs (eval (w, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y)\n  | Halve u -> (eval (u, x, y)) /. 2.0\n  | Wow (u,v,w) ->\n      sqrt\n        (((abs_float (eval (u, x, y))) *. (abs_float (eval (v, x, y)))) *.\n           (abs_float (eval (w, x, y))));;\n"}
{"hw": "hw2", "index": 1645, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> \"x\" | VarY y -> \"y\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n"}
{"hw": "hw2", "index": 1646, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw2", "index": 1647, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw2", "index": 1648, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw2", "index": 1649, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> ((exprToString x) + \"*\") ^ (exprToString y)\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw2", "index": 1650, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"}
{"hw": "hw2", "index": 1651, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Halve x -> \"(\" ^ (exprToString ^ \")/2\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))))\n  | Wow (x,y,z) ->\n      \"sqrt(\" ^\n        (\"abs(\" ^\n           ((exprToString x) ^\n              (\")*\" ^\n                 (\"abs(\" ^\n                    ((exprToString y) ^\n                       (\")*\" ^ (\"abs(\" ^ ((exprToString z) ^ \"))\"))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Halve of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Wow of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Halve x -> \"(\" ^ ((exprToString x) ^ \")/2\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))))\n  | Wow (x,y,z) ->\n      \"sqrt(\" ^\n        (\"abs(\" ^\n           ((exprToString x) ^\n              (\")*\" ^\n                 (\"abs(\" ^\n                    ((exprToString y) ^\n                       (\")*\" ^ (\"abs(\" ^ ((exprToString z) ^ \"))\"))))))));;\n"}
{"hw": "hw2", "index": 1652, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b), ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 1653, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9]\n    [1; 6; 2; 4; 12; 13; 9];;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1654, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 1655, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Sine ^ (exprToString e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n"}
{"hw": "hw2", "index": 1656, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Time (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n"}
{"hw": "hw2", "index": 1657, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun f), b);;\n"}
{"hw": "hw2", "index": 1658, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      ((whilesFun f), b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n"}
{"hw": "hw2", "index": 1659, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b in (fOfB, (fOfB = b)) in whilesFun f),\n      b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n"}
{"hw": "hw2", "index": 1660, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n"}
{"hw": "hw2", "index": 1661, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n"}
{"hw": "hw2", "index": 1662, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (match List.mem h seen with\n         | true  -> h :: seen\n         | false  -> (seen; (let rest' = t in helper (seen', rest')))) in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 1663, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | f::b -> f);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1664, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else (n mod 10) :: (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1665, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let x = [h] in (listReverse t) @ x;;\n\nlet palindrome w =\n  let x = listReverse (explode w) in if x = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 1666, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n"}
{"hw": "hw2", "index": 1667, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3,e4) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 8) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1668, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3,e4) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 1669, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 1670, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 1671, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin ((eval e1), x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval (e1, x, y));;\n"}
{"hw": "hw2", "index": 1672, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) + ((eval (e2, x, y)) / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0);;\n"}
{"hw": "hw2", "index": 1673, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0);;\n"}
{"hw": "hw2", "index": 1674, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1675, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin * (pi (eval (e1, x, y)))\n  | Cosine e1 -> cos * (pi (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin * (pi (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin (pi *. (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1676, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos * (pi (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin * (pi (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin (pi *. (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1677, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin * (pi (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Magic e1 -> sin (pi *. (cos (pi *. (eval (e1, x, y)))))\n  | Weird (e1,e2,e3) ->\n      cos\n        ((pi *. (eval (e1, x, y))) *.\n           ((eval (e2, x, y)) *. (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 1678, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n"}
{"hw": "hw2", "index": 1679, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' = if (f b) = b then (b, true) else (b, false) in wwhile (f', b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' b' = if (f b') = b' then (b', true) else (b', false) in\n  wwhile (f', b);;\n"}
{"hw": "hw2", "index": 1680, "problem": "wwhile", "bad": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (a',b') = f b in if b' = true then wwhile (f, b') else a';;\n"}
{"hw": "hw2", "index": 1681, "problem": "wwhile", "bad": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (a',b') = f b in if b' = true then wwhile (f, b') else a';;\n"}
{"hw": "hw2", "index": 1682, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then depth = (depth - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, depth))\n  | 1 -> buildCosine (build (rand, depth))\n  | 2 -> buildAverage (build (rand, depth))\n  | 3 -> buildTimes (build (rand, depth))\n  | 4 -> buildThresh (build (rand, depth));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1683, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1684, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let d = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1685, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1686, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 1687, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1688, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1689, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 1690, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1691, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Plus (v,w) -> (eval (v, x, y)) +. (eval (w, x, y))\n  | Cube (a,b,c) -> ((eval a) *. (eval b)) *. (eval c)\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Plus (v,w) -> (eval (v, x, y)) +. (eval (w, x, y))\n  | Cube (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 1692, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"X\"\n  | VarY  -> \"Y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ ((\"^\" exprToString y) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"X\"\n  | VarY  -> \"Y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))));;\n"}
{"hw": "hw2", "index": 1693, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus v -> \"(\" ^ ((exprToString v) ^ ((\"+\" exprToString w) ^ \")\"))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n"}
{"hw": "hw2", "index": 1694, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ ((\"+\" exprToString w) ^ \")\"))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n"}
{"hw": "hw2", "index": 1695, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | () -> d | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> let (a,b) = h in if a = k then b else assoc (d, k, t);;\n"}
{"hw": "hw2", "index": 1696, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 -> buildThresh (a, b, a_less, b_less));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1697, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval ((buildX ()), a, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1698, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1699, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1700, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1701, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1702, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2)\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.)\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"}
{"hw": "hw2", "index": 1703, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Foo of expr* expr\n  | Clamp of expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Foo (a,b) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then 0.9 *. (eval (a, x, y))\n      else (eval 0.1) *. (a, x, y)\n  | Clamp (a,b,c) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (b, x, y)\n      else\n        if (eval (a, x, y)) > (eval (c, x, y))\n        then eval (c, x, y)\n        else eval (a, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Foo of expr* expr\n  | Clamp of expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Foo (a,b) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then 0.9 *. (eval (a, x, y))\n      else 0.1 *. (eval (a, x, y))\n  | Clamp (a,b,c) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (b, x, y)\n      else\n        if (eval (a, x, y)) > (eval (c, x, y))\n        then eval (c, x, y)\n        else eval (a, x, y);;\n"}
{"hw": "hw2", "index": 1704, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"A\"\n  | VarY  -> printf \"A\"\n  | Sine  -> printf \"A\"\n  | Cosine  -> printf \"A\"\n  | Average  -> printf \"A\"\n  | Times  -> printf \"A\"\n  | Thresh  -> printf \"A\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"}
{"hw": "hw2", "index": 1705, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> ((Printf.sprintf \"%s<%s?%s:\" x), y, z);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"}
{"hw": "hw2", "index": 1706, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"}
{"hw": "hw2", "index": 1707, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"}
{"hw": "hw2", "index": 1708, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"e*e\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"}
{"hw": "hw2", "index": 1709, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if (f x) = x then (b, false) else (((f x), true), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = b then (b, false) else ((f x), true)), b);;\n"}
{"hw": "hw2", "index": 1710, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = b then (b, false) else (((f x), true), b));;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> if x = b then (b, false) else ((f x), true)), b);;\n"}
{"hw": "hw2", "index": 1711, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1712, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw1", "index": 1713, "problem": "additivePersistence", "bad": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else helperAppend (digitsOfInt (n / 10)) [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n <= 0 then [] else sumList (digitsOfInt n);;\n", "fix": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else helperAppend (digitsOfInt (n / 10)) [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = if n < 10 then 0 else sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 1714, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else 1;;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [1];;\n"}
{"hw": "hw1", "index": 1715, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1716, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [(digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1717, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = (n mod 10) @ [(digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1718, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; (digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1719, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [(digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1720, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1721, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1722, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (listReverse digitsOfInt (n / 10));;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (listReverse [n mod 10]) @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1723, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1724, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse [[n mod 10] @ (digitsOfInt (n / 10))];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1725, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1726, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [(digitsOfInt n) / 10; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1727, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1728, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n10 = n / 10 in [digitsOfInt n10; n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n10 = n / 10 in [n mod 10] @ (digitsOfInt n10));;\n"}
{"hw": "hw1", "index": 1729, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let n2 = [n mod 10] @ ((digitsOfInt n) / 10) in listReverse n2);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let n2 = [n mod 10] @ (digitsOfInt (n / 10)) in listReverse n2);;\n"}
{"hw": "hw1", "index": 1730, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1731, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [(digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1732, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1733, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digit = digitsOfInt (n / 10) in digit @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1734, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digit = digitsOfInt (n / 10) in [digit; n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1735, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1736, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digits = digitsOfInt (n / 10) in digits @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1737, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let l = (digitsOfInt (n / 10)) :: (n mod 10) in listReverse l);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digits = digitsOfInt (n / 10) in digits @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1738, "problem": "digitsOfInt", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let leading = (digitsOfInt (n / 10)) :: (n mod 10) in\n     listReverse leading);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digits = digitsOfInt (n / 10) in digits @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1739, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digits = digitsOfInt (n / 10) in digits @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let digits = digitsOfInt (n / 10) in digits @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1740, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse l);;\n"}
{"hw": "hw1", "index": 1741, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse l);;\n"}
{"hw": "hw1", "index": 1742, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> t :: (listReverse h);;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> t @ [h];;\n"}
{"hw": "hw1", "index": 1743, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse l) h;;\n"}
{"hw": "hw1", "index": 1744, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let rev = listReverse t in [rev; h];;\n", "fix": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> helperAppend (listReverse t) [h];;\n"}
{"hw": "hw1", "index": 1745, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t [h]];;\n", "fix": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> helperAppend (listReverse t) [h];;\n"}
{"hw": "hw1", "index": 1746, "problem": "palindrome", "bad": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> helperAppend (listReverse t) [h];;\n\nlet palindrome w = (listReverse (explode w)) = w;;\n", "fix": "\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> helperAppend (listReverse t) [h];;\n\nlet palindrome w = (listReverse (explode w)) = (explode w);;\n"}
{"hw": "hw3", "index": 1747, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.combine (List.rev l1) (List.rev l2) in\n    let args = List.split base in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1748, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1749, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1750, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1751, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1752, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1753, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1754, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1755, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1756, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          if (i + j) > 9 then a :: (1, ((i + j) - 10)) else a :: (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1757, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1758, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1759, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1760, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1761, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1762, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1763, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1764, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1765, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (s, t) ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1766, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in (((i + j) mod 10), (a :: ((i + j) / 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1767, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1768, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), ((i + j) mod 10)) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1769, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1770, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1771, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t @ (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1772, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      a = ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1773, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1774, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1775, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1776, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1777, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1778, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev [0]) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1779, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mul (i1,l1) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1780, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length + 1) l)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1781, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> []\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> (0, [])\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 1782, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if l1 < l2 then 0;;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1783, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (clone 0 (sec - first)) :: l1\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1784, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then List.append l1 ((clone 0 (first - sec)) :: l2)\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 1785, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f 0 h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1786, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1787, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1788, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1789, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1790, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1791, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base =\n    match fs with | [] -> (fun x  -> x * 1) | h::t -> f (fun x  -> x * 1) h in\n  List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1792, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1793, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = f t in List.fold_left g base x;;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = t in List.fold_left g base l;;\n"}
{"hw": "hw3", "index": 1794, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ ((\";\" b) ^ \"]\")) in\n      let base = f h in List.fold_left m base l;;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ (\";\" ^ (b ^ \"]\"))) in\n      let base = f h in List.fold_left m base l;;\n"}
{"hw": "hw3", "index": 1795, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 1796, "problem": "digitsOfInt", "bad": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y mod 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n", "fix": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n"}
{"hw": "hw1", "index": 1797, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "fix": "\nlet rec reverse (x,y) =\n  match x with | [] -> y | h::t -> reverse (t, (h :: y));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> reverse (l, []);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw1", "index": 1798, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  let absNum = abs num in\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n in l;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n"}
{"hw": "hw1", "index": 1799, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n in l;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n"}
{"hw": "hw1", "index": 1800, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot (abs n) in l;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n"}
{"hw": "hw1", "index": 1801, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n 0) in l;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n"}
{"hw": "hw1", "index": 1802, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n) 0 in l;;\n"}
{"hw": "hw1", "index": 1803, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec digitalRoot n = let (l,r) = additivePersAndRoot abs n 0 in r;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec digitalRoot n = let (l,r) = additivePersAndRoot (abs n) 0 in r;;\n"}
{"hw": "hw1", "index": 1804, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt div (n, 10)) @ [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1805, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1806, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1807, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n % 10)]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1808, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n mod 10)]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1809, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1810, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 1811, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet (l,r) = additivePersAndRoot (abs (-2)) 0;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | r::h -> (listReverse h) @ [r];;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverse ex in ex = revex;;\n"}
{"hw": "hw2", "index": 1812, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n"}
{"hw": "hw2", "index": 1813, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX else buildY)\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0 then (if r < 50 then buildX () else buildY ()) else buildY ();;\n"}
{"hw": "hw2", "index": 1814, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1815, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2.\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1816, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> ((eeval e1) +. (eval e2)) /. 2.\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1817, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100 *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100. *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n"}
{"hw": "hw2", "index": 1818, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsTresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ (s ^ (\":abs(\" ^ ((exprToString e4) ^ \"))\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^ (\"?\" ^ (s ^ (\":abs(\" ^ (s ^ \"))\")))))));;\n"}
{"hw": "hw1", "index": 1819, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList n in num + (additivePersistence num));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n"}
{"hw": "hw1", "index": 1820, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let counter = 0 in\n     counter = ((counter + (1 num)) + (additivePersistence num)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n"}
{"hw": "hw1", "index": 1821, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     1 + (additivePersistence num));;\n"}
{"hw": "hw1", "index": 1822, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     counter = ((additivePersistence num) + 1));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     1 + (additivePersistence num));;\n"}
{"hw": "hw1", "index": 1823, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 1824, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1825, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 1826, "problem": "digitsOfInt", "bad": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n", "fix": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse (append [n mod 10] (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 1827, "problem": "digitsOfInt", "bad": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse (append [n mod 10] digitsOfInt (n / 10));;\n", "fix": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t) [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse (append [n mod 10] (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 1828, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> 0;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [];;\n"}
{"hw": "hw1", "index": 1829, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append t [h]);;\n"}
{"hw": "hw1", "index": 1830, "problem": "listReverse", "bad": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "fix": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append t [h]);;\n"}
{"hw": "hw1", "index": 1831, "problem": "listReverse", "bad": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "fix": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append t [h]);;\n"}
{"hw": "hw1", "index": 1832, "problem": "listReverse", "bad": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "fix": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n"}
{"hw": "hw1", "index": 1833, "problem": "listReverse", "bad": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append [listReverse t; h];;\n", "fix": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append t [h];;\n"}
{"hw": "hw1", "index": 1834, "problem": "listReverse", "bad": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append (t [h]);;\n", "fix": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append t [h];;\n"}
{"hw": "hw1", "index": 1835, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec helper count x =\n    match x with\n    | [] -> count\n    | hd::tl -> helper (count + 1) (sumList (digits n)) in\n  helper 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n"}
{"hw": "hw1", "index": 1836, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper sumList digits x in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n"}
{"hw": "hw1", "index": 1837, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList digits x) in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n"}
{"hw": "hw1", "index": 1838, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) @ (helper (n / 10)) in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  helper n;;\n"}
{"hw": "hw1", "index": 1839, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> xs | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1840, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> [] | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1841, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) (n mod 10) in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1842, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (helper (n / 10)) @ [n mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1843, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append helper (n / 10) [n mod 10] in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) [n mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1844, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> helper (append [m / 10] [m mod 10]) in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1845, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs2 with | [] -> xs1 | hd::tl -> append (xs1 :: hd) tl in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n"}
{"hw": "hw1", "index": 1846, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> tl (hd :: result) in\n  helper xs [];;\n", "fix": "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper l [];;\n"}
{"hw": "hw3", "index": 1847, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1848, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1849, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = (List.length x1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = (List.length l1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1850, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let l1 = List.length l1 in\n  let l2 = List.length l2 in\n  (((clone 0 (l2 - l1)) @ l1), ((clone 0 (l1 - l2)) @ l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n"}
{"hw": "hw3", "index": 1851, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1852, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1853, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base g = g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1854, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base g = g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1855, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base g = g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1856, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base g = g in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 1857, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x g = x (a g) in let base g = g in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 1858, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1859, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 1860, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (exprToString e'))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1861, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (exprToString e'))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1862, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1863, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1864, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 1865, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Accossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi);;\n"}
{"hw": "hw2", "index": 1866, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi);;\n"}
{"hw": "hw2", "index": 1867, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n"}
{"hw": "hw2", "index": 1868, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n"}
{"hw": "hw2", "index": 1869, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> Average (e1, e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval ((Average (e1, e2)), x, y);;\n"}
{"hw": "hw2", "index": 1870, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs e3 else - (abs e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n"}
{"hw": "hw2", "index": 1871, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs_float e3 else - (abs_float e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n"}
{"hw": "hw2", "index": 1872, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if e1 > e2 then abs_float (eval e3) else - (abs_float (eval e3));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n"}
{"hw": "hw2", "index": 1873, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then e3 else - e3;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) *. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1874, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval e1) > (eval e2) then eval e3 else - (eval e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) *. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1875, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else - (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) *. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1876, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) * (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (-1.0) *. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1877, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n"}
{"hw": "hw2", "index": 1878, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan2 res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n"}
{"hw": "hw2", "index": 1879, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n"}
{"hw": "hw2", "index": 1880, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n"}
{"hw": "hw2", "index": 1881, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else (-1.0) *. res3;;\n"}
{"hw": "hw2", "index": 1882, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Asin of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n"}
{"hw": "hw2", "index": 1883, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Asin of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n"}
{"hw": "hw2", "index": 1884, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Asin of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n"}
{"hw": "hw2", "index": 1885, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n"}
{"hw": "hw2", "index": 1886, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n"}
{"hw": "hw2", "index": 1887, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((=) f), b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1888, "problem": "fixpoint", "bad": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1889, "problem": "fixpoint", "bad": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1890, "problem": "fixpoint", "bad": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1891, "problem": "fixpoint", "bad": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1892, "problem": "fixpoint", "bad": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1893, "problem": "fixpoint", "bad": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g (f, b)), b);;\n", "fix": "\nlet g h x = let xx = h x in (xx, (xx = (h x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"hw": "hw2", "index": 1894, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem l seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 1895, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  List.append\n    ((clone 0 (lenl1 - lenl2) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n"}
{"hw": "hw3", "index": 1896, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then\n    ((List.append (clone 0 (lenl1 - lenl2)) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n"}
{"hw": "hw2", "index": 1897, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos (pi *. (eval e))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n"}
{"hw": "hw2", "index": 1898, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n"}
{"hw": "hw2", "index": 1899, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n"}
{"hw": "hw2", "index": 1900, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e -> eval (e ** 2)\n  | Root e -> eval (e ** (1 / 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1901, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> eval (e ** 2)\n  | Root e -> eval (e ** (1 / 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1902, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval e) ** 2\n  | Root e -> (eval e) ** (1 / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1903, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1904, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1905, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1906, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1907, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"}
{"hw": "hw2", "index": 1908, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Flatten (e1,e2,e3) ->\n      ((eval (e1, x, y)) / (eval (e2, x, y))) / (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Flatten (e1,e2,e3) ->\n      ((eval (e1, x, y)) /. (eval (e2, x, y))) /. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 1909, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> printf \"%s\" e\n  | VarY e -> printf \"%s\" e\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1910, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1911, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1912, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" to_string e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1913, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ (e ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1914, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1915, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 1916, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Flatten (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"/\" ^ ((exprToString e2) ^ (\"/\" ^ ((exprToString e3) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Flatten (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^ ((exprToString e2) ^ (\"/\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 1917, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "fix": "\nlet fixpoint (f,b) = f b;;\n"}
{"hw": "hw2", "index": 1918, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "fix": "\nlet fixpoint (f,b) = f b;;\n"}
{"hw": "hw2", "index": 1919, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "fix": "\nlet fixpoint (f,b) = f b;;\n"}
{"hw": "hw2", "index": 1920, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "fix": "\nlet fixpoint (f,b) = f b;;\n"}
{"hw": "hw2", "index": 1921, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet fixpoint (f,b) = f b;;\n"}
{"hw": "hw2", "index": 1922, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = x in wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1923, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != b)) in f wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1924, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1925, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((let f b = b in b), b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1926, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile (g, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1927, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile ((g, true), b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1928, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet (c,b) = f 8;;\n\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f x = (b, (f b)) in wwhile (f, b) else b;;\n"}
{"hw": "hw2", "index": 1929, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then let b = f b in wwhile (f, b) else b;;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1930, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then wwhile (f, (f b)) else b;;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1931, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = (f, true) in wwhile (f, (f b)) else b;;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1932, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = ((f b), true) in wwhile (f, (f b)) else b;;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1933, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, true) in wwhile (f, (f b)) else b;;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1934, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b)\n  then let f b = (b, true) in wwhile (f, (f b))\n  else wwhile (f b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"}
{"hw": "hw2", "index": 1935, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, (f b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, (f b));;\n"}
{"hw": "hw2", "index": 1936, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = (f, (b = (f b))) in wwhile (g, (f b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 1937, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y = ((f b), (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1938, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile ((y b), b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1939, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet (c,b) = f 8;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet (x,y) = f 8;;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1940, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet (c,b) = f 8;;\n\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1941, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet (c,b) = f 8;;\n\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile ((f b), b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1942, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet (c,b) = f 8;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet (x,y) = f 8;;\n\nlet _ =\n  let fixpoint (f,b) = let y x = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n"}
{"hw": "hw2", "index": 1943, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1944, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1945, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, (f b));;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1946, "problem": "fixpoint", "bad": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet (x,y) = f 8;;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, x);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1947, "problem": "fixpoint", "bad": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile ((f b), b);;\n", "fix": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 1948, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1949, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem h seen)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1950, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1951, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1952, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n"}
{"hw": "hw2", "index": 1953, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem seen h\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1954, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1955, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 1956, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: rest in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 1957, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper List.rev (0 :: l) in ans;;\n", "fix": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (List.rev (0 :: l)) in ans;;\n"}
{"hw": "hw3", "index": 1958, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = (mulHelper 0) :: (List.rev l) in ans;;\n", "fix": "\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: (List.rev l)) in ans;;\n"}
{"hw": "hw3", "index": 1959, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1960, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1961, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1962, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1963, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1964, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1965, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1966, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1967, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1968, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1969, "problem": "bigAdd", "bad": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1970, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev x) ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1971, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev t) ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 1972, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat a x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n"}
{"hw": "hw1", "index": 1973, "problem": "additivePersistence", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence sumList digits n);;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 1974, "problem": "additivePersistence", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList digits n));;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 1975, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1976, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1977, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1978, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1979, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1980, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1981, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1982, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1983, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1984, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1985, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10]);;\n"}
{"hw": "hw1", "index": 1986, "problem": "digitsOfInt", "bad": "\nlet rec myAppend list num =\n  match list with | [] -> [num] | h::t -> h :: (myAppend t num);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend digitsOfInt (n / 10) (n mod 10) else [];;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n"}
{"hw": "hw1", "index": 1987, "problem": "digitsOfInt", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend digitsOfInt (n / 10) (n mod 10) else [];;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n"}
{"hw": "hw1", "index": 1988, "problem": "digitsOfInt", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n"}
{"hw": "hw1", "index": 1989, "problem": "palindrome", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listCompare l k =\n  if ((List.hd l) = []) && ((List.hd k) = [])\n  then true\n  else\n    if (List.hd l) != (List.hd k)\n    then false\n    else listCompare (List.tl l) (List.tl k);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = listCompare (explode w) (listReverse (explode w));;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw1", "index": 1990, "problem": "palindrome", "bad": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listCompare l k =\n  if ((List.hd l) = []) && ((List.hd k) = [])\n  then true\n  else\n    if (List.hd l) = (List.hd k)\n    then listCompare (List.tl l) (List.tl k)\n    else false;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = listCompare (explode w) (listReverse (explode w));;\n", "fix": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n"}
{"hw": "hw3", "index": 1991, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (a,b) ->\n          if (a + b) > 9 then 1 :: ((a + b) - 10) :: a else (a + b) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1992, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1993, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n)::[] ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1994, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args = match List.rev ((List.combine l1), l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1995, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev ((List.combine l1), l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1996, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1997, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1998, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in [add x] :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 1999, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = [m + n] in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2000, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2001, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in 0 :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2002, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2003, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let prevN (n1,n2) = n1 in\n      let prev = prevN a in\n      let sumlist (p1,p2) = p2 in\n      let sum = sumlist a in\n      let add (m,n) = m + n in\n      let digit = (add x) + prev in\n      if digit > 10 then (1, ((digit - 10) :: sum)) else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2004, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  let revl = List.rev l in\n  match revl with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 9\n      then [(mulByDigit i t) + (prod / 10); prod mod 10]\n      else [mulByDigit i t; prod];;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd (mulByDigit (i - 1) l) [0];;\n"}
{"hw": "hw3", "index": 2005, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else bigAdd (mulByDigit (i - 1) l) [0];;\n"}
{"hw": "hw3", "index": 2006, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs num =\n  let f a x = x a in let base = num in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2007, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs p = let f a x = x a in let base = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2008, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs p = let f a x = x a in let base = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2009, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs p = let f a x = x a in let base = p in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2010, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2011, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2012, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw3", "index": 2013, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) / 10 in\n    let base = 0 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2014, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2015, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2016, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2017, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2018, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2019, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2020, "problem": "bigMul", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [(mulByDigit x l2) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2021, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [(bigAdd (mulByDigit x l2) h) / 10; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2022, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [bigAdd (mulByDigit x l2) [h / 10]; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2023, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2024, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd List.rev (0 :: (List.rev a)) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd (List.rev (0 :: (List.rev a))) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2025, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2026, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> [x] @ ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2027, "problem": "clone", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone ((x n) - 1));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2028, "problem": "mulByDigit", "bad": "\nlet y f g x = f (g x);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (x * y) :: a\n    | h::t -> [(x * y) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n  List.fold_left f base args;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2029, "problem": "mulByDigit", "bad": "\nlet y f g x = f (g x);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(x * y) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n", "fix": "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n"}
{"hw": "hw3", "index": 2030, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero List.fold_left f base args;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n"}
{"hw": "hw3", "index": 2031, "problem": "padZero", "bad": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> ((((clone 0) - lendiff) @ l1), l2));;\n", "fix": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n"}
{"hw": "hw3", "index": 2032, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw2", "index": 2033, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2034, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2035, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2036, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval (m, x, y))) | _ -> x;;\n"}
{"hw": "hw2", "index": 2037, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval (m, x, y))) | _ -> x;;\n"}
{"hw": "hw2", "index": 2038, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 2039, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"}
{"hw": "hw2", "index": 2040, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"}
{"hw": "hw2", "index": 2041, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n"}
{"hw": "hw2", "index": 2042, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"}
{"hw": "hw2", "index": 2043, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"}
{"hw": "hw2", "index": 2044, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2045, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2046, "problem": "fixpoint", "bad": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2047, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2048, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) < b)) in wwhile (f, b');;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2049, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), ((f b) = b)) in wwhile (f', b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), (b = (f b))) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2050, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' f b = ((f b), (b = (f b))) in wwhile (f', b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f b = ((f b), ((f b) = b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2051, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2052, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (bs,cs) = f b in if cs then f bs else bs;;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2053, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = c then v else helper (a, b, t) in\n  helper (d, k, l);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = b then v else helper (a, b, t) in\n  helper (d, k, l);;\n"}
{"hw": "hw2", "index": 2054, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1..5 -> buildY () | 6..10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 10) in (if x < 5 then buildY () else buildX ())\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2055, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2056, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> float_of_int x\n  | VarX  -> float_of_int y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2057, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2058, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2059, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2060, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * pi)\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2061, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos pi\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2062, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> eval (a, x, y) ( *. ) eval (b, x, y)\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2063, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) ( *. ) (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2064, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2065, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2066, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2067, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"}
{"hw": "hw2", "index": 2068, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y) a) < 0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n"}
{"hw": "hw2", "index": 2069, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n"}
{"hw": "hw2", "index": 2070, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX\n  | None  -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2071, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX\n  | None  -> 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2072, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2073, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2074, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2075, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> ((exprToString Thresh a), b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2076, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (((a * b) * c) * d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2077, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let a = buildThresh (a, b, c, d) in exprToString a\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2078, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n"}
{"hw": "hw2", "index": 2079, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ ((\"+\" exprToString b) ^ \")/20\"))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"x\"\n  | VarX  -> \"y\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/20\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"x\"\n  | VarX  -> \"y\";;\n"}
{"hw": "hw2", "index": 2080, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (b = (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != b))), b);;\n"}
{"hw": "hw2", "index": 2081, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2082, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"tba\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2083, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2084, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2085, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2086, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2087, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2088, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ [List.combine (List.rev l1) (List.rev l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [(0, 0)] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2089, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2090, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (let y = clone l1 ((List.length l1) - (List.length l2)) in (y, l2))\n    else (let z = clone l2 ((List.length l2) - (List.length l1)) in (z, l1));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone (List.hd l1) ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone (List.hd l2) ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n"}
{"hw": "hw3", "index": 2091, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone (List.hd l1) ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone (List.hd l2) ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n"}
{"hw": "hw3", "index": 2092, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2093, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ([List.map (f l)] ^ \"]\"));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2094, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2095, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2096, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map (f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2097, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> VarX\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n"}
{"hw": "hw2", "index": 2098, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX (buildY ())\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildSine (buildX ())\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n"}
{"hw": "hw2", "index": 2099, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ ->\n      buildTimes\n        ((buildCosine (buildSine (buildX ()))),\n          (buildCosine (buildSine (buildX ()))))\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine ()\n  | 4 -> buildSine (buildX ())\n  | 5 -> buildSine (buildX ())\n  | 6 -> buildSine (buildX ())\n  | 7 -> buildSine (buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ ->\n      buildTimes\n        ((buildCosine (buildSine (buildX ()))),\n          (buildCosine (buildSine (buildX ()))))\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine (buildX ())\n  | 4 -> buildSine (buildX ())\n  | 5 -> buildSine (buildX ())\n  | 6 -> buildSine (buildX ())\n  | 7 -> buildSine (buildX ());;\n"}
{"hw": "hw2", "index": 2100, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        (if depth = 0\n         then buildX ()\n         else\n           ((build (rand, (depth - 1))),\n             (if depth = 0 then buildY () else build (rand, (depth - 1)))))\n  | 6 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n  | 7 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n  | 7 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n"}
{"hw": "hw2", "index": 2101, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> Format.printf \"%f\" rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2102, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2103, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildCosine (VarX, VarY)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildCosine VarX\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2104, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildCosine ()\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildAverage (VarX, VarY)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2105, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildTimes VarX\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildThresh (VarX, VarX, VarX, VarX)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2106, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 5) with\n     | 1 -> buildSine ((build (rand, (depth - 1))) * (buildY ()))\n     | 2 -> buildCosine ((build (rand, (depth - 1))) * (buildX ()))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 5) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 2107, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> let vx = x in vx\n  | VarY  -> let vy = y in vy\n  | Average  -> buildAverage (vx, vy);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2108, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2109, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> eval (VarX, a1, a2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2110, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> a1 + a2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2111, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, a1, a2)) + (eval (VarY, a1, a2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2112, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) + (eval (VarY, a1, a2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2113, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, a1, a2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2114, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin s1\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"}
{"hw": "hw2", "index": 2115, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) / 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = (10, 13, 57);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (pi *. (eval (s1, x, y)))\n  | Cosine c1 -> cos (pi *. (eval (c1, x, y)))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (h1,h2,h3,h4) ->\n      if (eval (h1, x, y)) < (eval (h2, x, y))\n      then eval (h3, x, y)\n      else eval (h4, x, y);;\n"}
{"hw": "hw2", "index": 2116, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = (10, 13, 57);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (pi *. (eval (s1, x, y)))\n  | Cosine c1 -> cos (pi *. (eval (c1, x, y)))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2.0\n  | Times (t1,t2) -> (eval (t1, x, y)) *. (eval (t2, x, y))\n  | Thresh (h1,h2,h3,h4) ->\n      if (eval (h1, x, y)) < (eval (h2, x, y))\n      then eval (h3, x, y)\n      else eval (h4, x, y);;\n"}
{"hw": "hw2", "index": 2117, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> sprintf \"%s\" x;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2118, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2119, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.printf \"%s\" s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2120, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%s\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2121, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%VarX\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2122, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2123, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%expr\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2124, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%float\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2125, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.sprintf \"%float\" VarX;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2126, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" Sine;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2127, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2128, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 3.142;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (pi * e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2129, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.142 * e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2130, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2131, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2132, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2133, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2134, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3 * 2));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2135, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n"}
{"hw": "hw2", "index": 2136, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (s ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" 1.0) ^ \")\");;\n"}
{"hw": "hw2", "index": 2137, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" 1.0) ^ \")\");;\n"}
{"hw": "hw2", "index": 2138, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%_\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2139, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2140, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2141, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%f\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2142, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%i\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2143, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%expr\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2144, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%e\" s) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2145, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "fix": "\nlet fixpoint (f,b) = b;;\n"}
{"hw": "hw2", "index": 2146, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2147, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else wwhile (f, (f b)));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2148, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (b, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2149, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2150, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2151, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2152, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then 1 else 0)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2153, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = f x in ((x, (x = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2154, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> x), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2155, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2156, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile ((let f x = let xx = (x * x) * x in (xx, (xx < 100)) in f), b);;\n"}
{"hw": "hw2", "index": 2157, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 2158, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n"}
{"hw": "hw2", "index": 2159, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not l.mem h then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2160, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2161, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2162, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2163, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2164, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2165, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2166, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [2] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2167, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2168, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2169, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = x (a z) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2170, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = x (a z) in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2171, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l; \"]\"];;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) [\"]\"]);;\n"}
{"hw": "hw3", "index": 2172, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l; [\"]\"]];;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) [\"]\"]);;\n"}
{"hw": "hw3", "index": 2173, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) [\"]\"]);;\n"}
{"hw": "hw3", "index": 2174, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2175, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match d k l with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | hd::tl ->\n             (match hd with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  if l = []\n  then d\n  else\n    (match l with\n     | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n"}
{"hw": "hw2", "index": 2176, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | [] -> 0\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n"}
{"hw": "hw2", "index": 2177, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin eval (a, x, y)\n  | Cosine a -> cos eval (a, x, y)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2178, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"}
{"hw": "hw2", "index": 2179, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (eval ((a, x, y) *. (a, x, y))) + ((b, x, y) *. (c, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n"}
{"hw": "hw2", "index": 2180, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n"}
{"hw": "hw2", "index": 2181, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) * (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n"}
{"hw": "hw2", "index": 2182, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        / 2\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n"}
{"hw": "hw2", "index": 2183, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n"}
{"hw": "hw2", "index": 2184, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))))\n  | FunnyTimes (s,t,u) ->\n      \"(floor \" ^ ((ex s) ^ (\"* ceil \" ^ ((ex t) ^ (\"*\" ^ ((ex u) ^ \")\")))))\n  | Sqr s -> \"(\" ^ ((ex s) ^ (\"*\" ^ ((ex s) ^ \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (expr s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2185, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | (Average a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | (Times a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | (Thresh a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2186, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")/cos(pi*\" ^ ((expr a) \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")/cos(pi*\" ^ ((expr a) ^ \")\")));;\n"}
{"hw": "hw2", "index": 2187, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 2188, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n"}
{"hw": "hw2", "index": 2189, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [seen; h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2190, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen cons [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2191, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n"}
{"hw": "hw3", "index": 2192, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res mod 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res mod 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2193, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> [res / 10; res mod 10]\n           | a::b ->\n               let re = a + (res mod 10) in (re / 10) :: (re mod 10) :: b) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + (res mod 10) in\n               (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2194, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd (((mulByDigit d) * (x t)) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in match b with | d::t -> (((d * 10) :: t), t) | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2195, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd ((mulByDigit (d * x) t) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in match b with | d::t -> (((d * 10) :: t), t) | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2196, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2197, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2198, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2199, "problem": "pipe", "bad": "\nlet pipe fs = let f a x j x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x j = x (a j) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2200, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2201, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" sepList.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2202, "problem": "clone", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone ((x n) - 1)) else x;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2203, "problem": "clone", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone (x (n - 1))) else [];;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2204, "problem": "clone", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone (x (n - 1)));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2205, "problem": "mulByDigit", "bad": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd 1 1) (mulByDigit (i - 2) l);;\n", "fix": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2206, "problem": "mulByDigit", "bad": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "fix": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2207, "problem": "mulByDigit", "bad": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "fix": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2208, "problem": "mulByDigit", "bad": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "fix": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2209, "problem": "mulByDigit", "bad": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "fix": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2210, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2211, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2212, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n"}
{"hw": "hw2", "index": 2213, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Power e -> (eval (e, x, y)) *. (eval (e, x, y))\n  | KellysOp (a,b,a_more) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (a_more, x, y)\n      else 0.0;;\n"}
{"hw": "hw2", "index": 2214, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n"}
{"hw": "hw2", "index": 2215, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr\n  | KellysOp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power e11 -> \"((\" ^ ((exprToString e11) ^ \")^2)\")\n  | KellysOp (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^ ((exprToString e2) ^ (\"?\" ^ ((exprToString e3) ^ \":0.0\")))));;\n"}
{"hw": "hw2", "index": 2216, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 2 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 3 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 4 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 5 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 6 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 7 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 8 -> buildX ()\n       | 9 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 13) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> buildSine (build (rand, (depth - 1)))\n       | 7 -> buildCosine (build (rand, (depth - 1)))\n       | 8 -> buildSine (build (rand, (depth - 1)))\n       | 9 -> buildCosine (build (rand, (depth - 1)))\n       | 10 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n"}
{"hw": "hw2", "index": 2217, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (pi *. (eval x))\n  | Cosine x -> cos (pi *. (eval x))\n  | Average (x1,x2) -> ((eval x1) +. (eval x2)) /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 2218, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (eval (pi *. x))\n  | Cosine x -> cos (pi *. (eval x))\n  | Average (x1,x2) -> ((eval x1) +. (eval x2)) /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 2219, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval x1) +. (eval x2)) /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.;;\n"}
{"hw": "hw2", "index": 2220, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n"}
{"hw": "hw2", "index": 2221, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e ** ((- pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n"}
{"hw": "hw2", "index": 2222, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((- pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n"}
{"hw": "hw2", "index": 2223, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) ** 2)) /. 1.6;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) ** 2.)) /. 1.6;;\n"}
{"hw": "hw2", "index": 2224, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^ (x1 ^ (\"*\" ^ (x2 ^ (\")e^(-pi*\" ^ (x3 ^ \"^2)\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"*\" ^\n              ((exprToString x1) ^ (\")e^(-pi*\" ^ ((exprToString x1) ^ \"^2)\")))));;\n"}
{"hw": "hw2", "index": 2225, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile (((f b), (b <> (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2226, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let (b',c) = ((f b), ((f b) <> b)) in wwhile ((b', c), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2227, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile ((b, (b <> (f b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n"}
{"hw": "hw2", "index": 2228, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls ->\n      if k = lk then lv else assoc d k ls uncomment after implementing assoc;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"}
{"hw": "hw2", "index": 2229, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"}
{"hw": "hw2", "index": 2230, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"}
{"hw": "hw2", "index": 2231, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc d k ls;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"}
{"hw": "hw2", "index": 2232, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"}
{"hw": "hw2", "index": 2233, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build rand (depth - 1))\n    | 3 -> buildCosine (build rand (depth - 1))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 2234, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimesMod (e1,e2,e3) = TimesMod (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 ->\n        buildTimesMod\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 1 -> buildTan (mod_float (build (rand, (depth - 1))) 1.0)\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | SineSq of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesModOne of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSineSq e = SineSq e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 1 -> buildSineSq (build (rand, (depth - 1)))\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ -> buildY ()\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ -> buildX ());;\n"}
{"hw": "hw2", "index": 2235, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,x,y,z) -> if (eval w) < (eval x) then eval y else eval z\n  | Times (x,y) -> (eval x) * (eval y)\n  | Average (x,y) -> ((eval x) * (eval y)) / 2\n  | Cosine x -> cos (pi * (eval x))\n  | Sine x -> sin (pi * (eval x))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2236, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) -> if (eval w) < (eval t) then eval u else eval z\n  | Times (t,u) -> (eval t) * (eval u)\n  | Average (t,u) -> ((eval t) * (eval u)) / 2\n  | Cosine t -> cos (pi * (eval t))\n  | Sine t -> sin (pi * (eval t))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2237, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi * (eval (t, x, y)))\n  | Sine t -> sin (pi * (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2238, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2239, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) u)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) (eval (u, x, y)))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2240, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) (eval (u, x, y)))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2241, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) (eval (u, x, y)))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Tan t -> mod_float (tan (pi *. (eval (t, x, y)))) 1\n  | VarX  -> x\n  | VarY  -> y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) (eval (u, x, y)))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | Tan t -> mod_float (tan (pi *. (eval (t, x, y)))) 1.0\n  | VarX  -> x\n  | VarY  -> y;;\n"}
{"hw": "hw2", "index": 2242, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) != b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2243, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2244, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b else f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2245, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2246, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun (f,b)  -> if (f b) = b then b else f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2247, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2248, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2249, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, true) else (b, false)), b);;\n"}
{"hw": "hw2", "index": 2250, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n"}
{"hw": "hw2", "index": 2251, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun a  -> if b = (f b) then (b, false) else ((f b), true)), b);;\n"}
{"hw": "hw2", "index": 2252, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> if (f b) = b then ((f b), false) else ((f b), true)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun a  -> if b = (f b) then (b, false) else ((f b), true)), b);;\n"}
{"hw": "hw2", "index": 2253, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> match f b with | b -> ((f b), false) | _ -> ((f b), true)),\n      b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun a  -> if b = (f b) then (b, false) else ((f b), true)), b);;\n"}
{"hw": "hw2", "index": 2254, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> match f b with | b -> (b, false) | _ -> ((f b), true)),\n      b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun a  -> if b = (f b) then (b, false) else ((f b), true)), b);;\n"}
{"hw": "hw2", "index": 2255, "problem": "fixpoint", "bad": "\nlet fphelper f b = if (f b) = b then (b, false) else ((f b), true);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (fphelper, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun z  -> let b = f z in (b, (b != z))), b);;\n"}
{"hw": "hw2", "index": 2256, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile f b';;\n", "fix": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n"}
{"hw": "hw2", "index": 2257, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 1 -> buildSine build (rand, depth)\n  | _ -> failwith \"rainbow\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}
{"hw": "hw2", "index": 2258, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}
{"hw": "hw2", "index": 2259, "problem": "build", "bad": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"}
{"hw": "hw2", "index": 2260, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               buildTimmy1\n                 ((build (rand, (depth - depth))),\n                   (build (rand, (depth - depth)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n"}
{"hw": "hw2", "index": 2261, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2262, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2263, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2264, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average e -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2265, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2266, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2267, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2268, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n"}
{"hw": "hw2", "index": 2269, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n"}
{"hw": "hw2", "index": 2270, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) / (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n"}
{"hw": "hw2", "index": 2271, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) * (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))));;\n"}
{"hw": "hw2", "index": 2272, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      ((sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))))) / 3;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      ((sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))))) /.\n        3.0;;\n"}
{"hw": "hw2", "index": 2273, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))));;\n"}
{"hw": "hw2", "index": 2274, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 3) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n"}
{"hw": "hw2", "index": 2275, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      ((exprToString a), (exprToString b), (exprToString c),\n        (exprToString d));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2276, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Thresh (a,b,c,d) -> exprToString a b c d;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2277, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> \"x\"\n  | VarY y -> \"y\"\n  | Sine s -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\");;\n"}
{"hw": "hw2", "index": 2278, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Averages  ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times  -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2279, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2280, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")/\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \"))\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")/\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \"))\"))));;\n"}
{"hw": "hw2", "index": 2281, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n"}
{"hw": "hw2", "index": 2282, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n"}
{"hw": "hw2", "index": 2283, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n"}
{"hw": "hw2", "index": 2284, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n"}
{"hw": "hw2", "index": 2285, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != x))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n"}
{"hw": "hw2", "index": 2286, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n"}
{"hw": "hw2", "index": 2287, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2288, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2289, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2290, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2291, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2292, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h @ [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2293, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2294, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2295, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2296, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2297, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2298, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2299, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ((t, (h + x)) :: a) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2300, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = (l1, (h + x)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2301, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in x + h in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2302, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ((x + h), []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2303, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in (0, 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2304, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in 0 :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2305, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [0; 0] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2306, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [[0]; [0]] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2307, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2308, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2309, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [([], 0)] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2310, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], (0 :: a)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2311, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2312, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2313, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, b) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2314, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2315, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2316, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (l1, []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2317, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2318, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3, asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2319, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3 asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2320, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 asd2))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2321, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, ((padZero asd3 asd2) :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2322, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in\n        let (_,asd4) = padZero asd3 (asd2 :: b) in (asd3, asd4)\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2323, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = (((List.rev 0) :: l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev (0 :: l1)), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2324, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((mulByDigit x q), []) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2325, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2326, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x l1)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2327, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [] in if x = 0 then acc else acc :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x n;;\n"}
{"hw": "hw3", "index": 2328, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "fix": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x n;;\n"}
{"hw": "hw3", "index": 2329, "problem": "clone", "bad": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: ((accum n) - 1);;\n", "fix": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x n;;\n"}
{"hw": "hw3", "index": 2330, "problem": "clone", "bad": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "fix": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x n;;\n"}
{"hw": "hw3", "index": 2331, "problem": "clone", "bad": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "fix": "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x (n - 1);;\n"}
{"hw": "hw3", "index": 2332, "problem": "clone", "bad": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: (accum (n - 1));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let helper x n = if n < 1 then accum else x :: accum in helper x (n - 1);;\n"}
{"hw": "hw3", "index": 2333, "problem": "clone", "bad": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let helper x n = if n < 1 then accum else x :: accum in helper x (n - 1);;\n"}
{"hw": "hw3", "index": 2334, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n"}
{"hw": "hw3", "index": 2335, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit (helper i l accum);;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit i (helper i l accum);;\n"}
{"hw": "hw3", "index": 2336, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2));;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2337, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2338, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2339, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2340, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 1) l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2341, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if 1 then List.append (clone 0 1) l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2342, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append (clone 0 1) l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2343, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2344, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2345, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2346, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2347, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2348, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2349, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then clone 0 1;;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2350, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2 else (l1, l2);;\n", "fix": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2351, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2352, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x z = a (x z) in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2353, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = f in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2354, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2355, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2356, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep [] in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2357, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2358, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t then \"\" else \"a\" in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else \"\" in\n      let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2359, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else t in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else h in\n      let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2360, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h ^ sep in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2361, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2362, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = \"\" then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = [] then sep else h in\n      let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2363, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2364, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2365, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2366, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \"\") l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2367, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2368, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map ~l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2369, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (fun x  -> sepConcat \"\" x) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2370, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map (fun x  -> x ^ x) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2371, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2372, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2373, "problem": "stringOfList", "bad": "\nlet stringOfList f l = failwith List.map asd l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2374, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \",\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2375, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.append \"[\") ::\n  ((sepConcat \";\" (List.map f l)) \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2376, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" :: (sepConcat \";\" (List.map f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw1", "index": 2377, "problem": "additivePersistence", "bad": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence sumList digits n);;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 2378, "problem": "additivePersistence", "bad": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 2379, "problem": "additivePersistence", "bad": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList digits n));;\n", "fix": "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n"}
{"hw": "hw1", "index": 2380, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n / 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 2381, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 2382, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 2383, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) mod 10) :: (n / 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2384, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n mod 10)) :: (n / 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2385, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then digitsOfInt ((n mod 10) :: (n / 10)) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2386, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: ((digitsOfInt n) / 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2387, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in k :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in (n mod 10) :: k else [];;\n"}
{"hw": "hw1", "index": 2388, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (digitsOfIntHelper (n / 10) (n mod 10)) :: result\n    else result in\n  digitsOfIntHelper n [];;\n", "fix": "\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then digitsOfIntHelper (n / 10) ((n mod 10) :: result)\n    else result in\n  digitsOfIntHelper n [];;\n"}
{"hw": "hw1", "index": 2389, "problem": "digitsOfInt", "bad": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "fix": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; n mod 10] | false  -> [];;\n"}
{"hw": "hw1", "index": 2390, "problem": "digitsOfInt", "bad": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | 0::[] -> []\n  | 1 -> []\n  | true  -> [digOfIntHelper n; []; n mod 10]\n  | false  -> [];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> digitsOfInt (n mod 10));;\n"}
{"hw": "hw1", "index": 2391, "problem": "digitsOfInt", "bad": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; []; n mod 10] | false  -> [];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> digitsOfInt (n mod 10));;\n"}
{"hw": "hw1", "index": 2392, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> (digitsOfInt n) mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> digitsOfInt (n mod 10));;\n"}
{"hw": "hw1", "index": 2393, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (digitsOfInt (n mod 10)));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (n / 10) :: (digitsOfInt (n mod 10)));;\n"}
{"hw": "hw1", "index": 2394, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (n / 10) :: (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 2395, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with | false  -> n :: (digitsOfInt (n / 10)) | true  -> 1);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [1]);;\n"}
{"hw": "hw1", "index": 2396, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 1);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [1]);;\n"}
{"hw": "hw1", "index": 2397, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 2);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 2398, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [digitsOfInt (n / 10); n mod 10]);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 2399, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "fix": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec digitsOfInt n = digOfInt n;;\n"}
{"hw": "hw1", "index": 2400, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "fix": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec digitsOfInt n = digOfInt n;;\n"}
{"hw": "hw1", "index": 2401, "problem": "digitsOfInt", "bad": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "fix": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec digitsOfInt n = digOfInt n;;\n"}
{"hw": "hw3", "index": 2402, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2403, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2404, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2405, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2406, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((carry + d1) + d2) / 10 in\n          let digit = ((carry + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2407, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((carry + d1) + d2) / 10 in\n          let digit = ((carry + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2408, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match a with\n      | ((d1,d2),sum) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let sum = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match x with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2409, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> 0)\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"}
{"hw": "hw3", "index": 2410, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2411, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x];;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | n -> [x] @ (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2412, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n"}
{"hw": "hw3", "index": 2413, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n"}
{"hw": "hw3", "index": 2414, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10 then (prod mod 10) :: (prod / 10) else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n"}
{"hw": "hw3", "index": 2415, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) :: (mulByDigit i t)]\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2416, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2417, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2418, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) + (mulByDigit i t)]\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2419, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2420, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else (prod mod 10) :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2421, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then ((prod mod 10) :: ((prod / 10) + (mulByDigit i t))) :: t\n      else (prod mod 10) :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2422, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + [mulByDigit i t])\n      else (prod mod 10) :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2423, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: [prod / 10] :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"}
{"hw": "hw3", "index": 2424, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      if prod > 10\n      then [lastDigit; firstDigit + (mulByDigit (i t))]\n      else firstDigit :: t;;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, rest) in\n    let base = (0, []) in\n    let (carryOver,rest) = List.fold_left f base (List.rev l) in carryOver ::\n      rest in\n  removeZero (mult i l);;\n"}
{"hw": "hw3", "index": 2425, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      let ret = mulByDigit (i t) in\n      (match ret with\n       | [] -> 0\n       | h2::t2 ->\n           if h2 > 10\n           then\n             let temp = h2 in\n             (if prod > 10\n              then [lastDigit; firstDigit + temp]\n              else firstDigit :: t));;\n", "fix": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, rest) in\n    let base = (0, []) in\n    let (carryOver,rest) = List.fold_left f base (List.rev l) in carryOver ::\n      rest in\n  removeZero (mult i l);;\n"}
{"hw": "hw3", "index": 2426, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2427, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2428, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine l1 l2;;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2429, "problem": "padZero", "bad": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2430, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2431, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2432, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then 0 :: l1;;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2433, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2434, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (([0] @ l1), l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2435, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2436, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2437, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2438, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (l2 :: 0))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n", "fix": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2439, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone ((0 :: l1), l2)\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2440, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (l1, l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (l1 l2G)), l2))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2441, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0, l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2442, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2443, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1 clone (0 l1G))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append (clone (0 l2G) l2))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2444, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (clone (0 l2G) l1) l2)\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2445, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, ((clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (((clone 0 l2G) l1), l2))\n    else (l1, l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"}
{"hw": "hw3", "index": 2446, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2447, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2448, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2449, "problem": "pipe", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2450, "problem": "pipe", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2451, "problem": "pipe", "bad": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2452, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2453, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2454, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map ((sepConcat \"\") l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2455, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f ((sepConcat \"\") l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2456, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2457, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2458, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"\" l)) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2459, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2460, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2461, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2462, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2463, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (sepConcat \"\" l) List.map (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2464, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map (f l) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2465, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map (f l)) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2466, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ((List.map (f l)) ^ \"]\"));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2467, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2468, "problem": "build", "bad": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2469, "problem": "build", "bad": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2470, "problem": "build", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2471, "problem": "build", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2472, "problem": "build", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2473, "problem": "build", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2474, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2475, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2476, "problem": "build", "bad": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2477, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildCosine (buildhelper 0 (depth - 1) expr)\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2478, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper (depth - 1) (depth - 1) expr)\n        else buildCosine (buildhelper 0 (depth - 1) (depth - 1) expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2479, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"}
{"hw": "hw2", "index": 2480, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2481, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2482, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2483, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi * (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2484, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2485, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (float evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2486, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2487, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2488, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2489, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) / 2 in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) *. (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2490, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) *. (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2491, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> p1 *. p2\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2492, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y\n    | Thresh2 (p1,p2) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y) then 1 else 0\n    | Thresh3 (p1,p2) ->\n        if (evalhelper p1 x y) > (evalhelper p2 x y) then 0 else (-1) in\n  evalhelper e x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y\n    | Thresh2 (p1,p2) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y) then 1.0 else 0.0\n    | Thresh3 (p1,p2) ->\n        if (evalhelper p1 x y) > (evalhelper p2 x y) then 0.0 else (-1.0) in\n  evalhelper e x y;;\n"}
{"hw": "hw2", "index": 2493, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) != x), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2494, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2495, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != b in k b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2496, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2497, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) = x), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2498, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2499, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2500, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2501, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, ((k b) != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2502, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, (b != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2503, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let k x = f x in ((b, (b != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2504, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2505, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2506, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2507, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2508, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) = x in ((g b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2509, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) != x in ((g b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2510, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2511, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2512, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b), ((g b) != b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2513, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2514, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2515, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2516, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2517, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in g b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2518, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2519, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (b, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2520, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"}
{"hw": "hw2", "index": 2521, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in ((inwwhile b), ((inwwhile b) != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n"}
{"hw": "hw2", "index": 2522, "problem": "fixpoint", "bad": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in (x, ((inwwhile b) != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n"}
{"hw": "hw2", "index": 2523, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = ((wwhile (let helper x = (f x) != (f b) in helper)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2524, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = (f x) != (f b) in helper b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2525, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) != (f b))) in helper)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2526, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) = (f b))) in helper)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2527, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2528, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2529, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n"}
{"hw": "hw2", "index": 2530, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n"}
{"hw": "hw2", "index": 2531, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "fix": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f x))) in helper), b);;\n"}
{"hw": "hw2", "index": 2532, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n"}
{"hw": "hw2", "index": 2533, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n"}
{"hw": "hw2", "index": 2534, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n"}
{"hw": "hw2", "index": 2535, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = hd :: seen in let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2536, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2537, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [hd]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2538, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2539, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [2]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 2540, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let x = n / 10\n        and y = n mod 10 in (digitsOfInt x) @ y);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let x = n / 10\n        and y = n mod 10 in (digitsOfInt x) @ [y]);;\n"}
{"hw": "hw1", "index": 2541, "problem": "digitsOfInt", "bad": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = reverseInt n in\n     let x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n 0) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2542, "problem": "digitsOfInt", "bad": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n 0) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2543, "problem": "digitsOfInt", "bad": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n 0) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2544, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = int_of_string reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2545, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet x = \"123\";;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2546, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0 then [] else if z = 0 then (let n2 = reverse n in z = (z + 1));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2547, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z = (z + 1));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2548, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if z = 0 then (let n2 = reverse (string_of_int n) in z + 1);;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2549, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2);;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2550, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then\n      (let n2 = reverse (string_of_int n)\n       and z = 1 in\n       digitsOfInt n2;\n       (let x = n2 / 10\n        and y = n2 mod 10 in\n        if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x)));;\n", "fix": "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2551, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let s = string_of_int n in\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s2.[i] in s2.[i] <- s2.[(n - i) - 1]; s2.[(n - i) - 1] <- c)\n  done;\n  int_of_string s2;;\n", "fix": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2552, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = true\n    then (let n2 = reverse (string_of_int n)\n          and z = false in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = true;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z\n    then (let n2 = reverse (string_of_int n)\n          and z = false in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2553, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2554, "problem": "digitsOfInt", "bad": "\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2 0)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"}
{"hw": "hw1", "index": 2555, "problem": "digitsOfInt", "bad": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (10 ** s)) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n) in\n       let rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in head\n         :: (digitsOfInt rest));;\n"}
{"hw": "hw1", "index": 2556, "problem": "digitsOfInt", "bad": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = (float_of_int n) - (1. * (10. ** (float_of_int s))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n) in\n       let rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in head\n         :: (digitsOfInt rest));;\n"}
{"hw": "hw1", "index": 2557, "problem": "digitsOfInt", "bad": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (int_of_float (10 ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "fix": "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n) in\n       let rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in head\n         :: (digitsOfInt rest));;\n"}
{"hw": "hw1", "index": 2558, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2559, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse [l']) @ [x];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2560, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') :: x;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2561, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::l' -> [listReverse l'; x];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2562, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse x];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2563, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse xl];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2564, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> 0 | head::tail -> tail;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2565, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ head;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n"}
{"hw": "hw1", "index": 2566, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> [listReverse tail; head];;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> head :: (listReverse tail);;\n"}
{"hw": "hw1", "index": 2567, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with\n  | _ -> []\n  | x -> [x]\n  | head::tail -> (listReverse tail) :: head;;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> head :: tail :: t :: s;;\n"}
{"hw": "hw1", "index": 2568, "problem": "listReverse", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | x::[] -> x | head::tail -> [listReverse tail; head];;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> head :: tail :: t :: s;;\n"}
{"hw": "hw1", "index": 2569, "problem": "listReverse", "bad": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> s :: t :: tail :: head;;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> [head; tail];;\n"}
{"hw": "hw1", "index": 2570, "problem": "listReverse", "bad": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s::l -> s :: t :: tail :: head;;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> [head; tail];;\n"}
{"hw": "hw1", "index": 2571, "problem": "listReverse", "bad": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> head :: tail;;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> [head; tail];;\n"}
{"hw": "hw1", "index": 2572, "problem": "listReverse", "bad": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::third::fourth -> [fourth; third; tail; head];;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::third::fourth::fifth -> [fourth; third; tail; head];;\n"}
{"hw": "hw1", "index": 2573, "problem": "listReverse", "bad": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> head :: (listReverse tail) :: tail;;\n", "fix": "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> head :: (listReverse tail);;\n"}
{"hw": "hw1", "index": 2574, "problem": "palindrome", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse explode w) = w then true else false;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 2575, "problem": "palindrome", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then true else false;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 2576, "problem": "palindrome", "bad": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then 1 else 0;;\n", "fix": "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw3", "index": 2577, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2578, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = ([], []) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2579, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2580, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2581, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2582, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2583, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2584, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2585, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = 0. in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2586, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2587, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2588, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2589, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let a = l1 in let b = l2 in ([a + 1], [a + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let a = List.hd l1 in let b = List.hd l2 in ([a + 1], [a + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2590, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = (l1, l2) in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2591, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2592, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (a,b) = List.hd x in ([a + 1], [b + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2593, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in ([(List.hd a) + 1], [(List.hd b) + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2594, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([(List.hd x) + 1], [(List.hd x) + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2595, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in (((List.hd a) + 1), ((List.hd b) + 2)) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2596, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2597, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2598, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x :: a], [x :: a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 1]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2599, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let y = l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2600, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2601, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split\n        (List.combine (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2602, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2603, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine\n        (List.split (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2604, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> (a + b) mod 10 in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ([], ((fir + sec) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2605, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else (((fir + sec) / 10), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2606, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else (((fir + sec) / 10), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then (b1, ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2607, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then (b1, ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2608, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (\"\", []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then (b1, ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2609, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then (b1, ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2610, "problem": "clone", "bad": "\nlet rec clone x n = if n > 0 then clone [x] (n - 1) else [];;\n", "fix": "\nlet rec clone x n = if n > 0 then clone x (n - 1) else [];;\n"}
{"hw": "hw3", "index": 2611, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "fix": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x @ acc) (n - 1) else [];;\n"}
{"hw": "hw3", "index": 2612, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: x) (n - 1) else [];;\n", "fix": "\nlet rec clone x n = let acc = [x] in if n > 0 then clone x (n - 1) else [];;\n"}
{"hw": "hw3", "index": 2613, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [x] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "fix": "\nlet rec clone x n = let acc = [0] in if n > 0 then clone x (n - 1) else [];;\n"}
{"hw": "hw3", "index": 2614, "problem": "clone", "bad": "\nlet rec clone x n =\n  let acc = [0] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "fix": "\nlet rec clone x n = let acc = [0] in if n > 0 then clone x (n - 1) else [];;\n"}
{"hw": "hw3", "index": 2615, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else acc in\n  helper i l 0;;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else acc in\n  helper i l [];;\n"}
{"hw": "hw3", "index": 2616, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in\n  if l_diff < 0 then ((to_append @ l1), l2) else (l1, (to_append @ l2));;\n"}
{"hw": "hw3", "index": 2617, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then ((clone 0 ((l_diff * (-1)) @ l1)), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n", "fix": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n"}
{"hw": "hw3", "index": 2618, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x + a in let base = \"\" in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2619, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2620, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2621, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2622, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2623, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2624, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2625, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base z = z in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2626, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = [] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2627, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ t in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2628, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2629, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2630, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2631, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0.0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw2", "index": 2632, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2633, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' x y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2634, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2635, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2636, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2637, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2638, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2639, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc = if x = 0 then acc else factorial (x - 1) (x * acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) + (eval e2)) + (eval e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2640, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc = if x = 0 then acc else factorial (x - 1) (x * acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2641, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2642, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval e'), 1)\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2643, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval (e', x, y)), 1)\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval (e', x, y)) 1.0\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2644, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial eval (e', x, y) 1\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval (e', x, y)) 1.0\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 2645, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> x | VarY y -> y | Sine s -> Sine (exprToString s);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2646, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Sine (exprToString s);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2647, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2648, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2649, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2650, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2651, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2652, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf \"sin(pi*%s)\" exprToString e'\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2653, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf (\"sin(pi*%s)\" exprToString e')\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 2654, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))))\n  | Factorial e' -> (Format.sprintf \"((\") ^ ((exprToString e') ^ \")!)\")\n  | Sum3 (e1,e2,e3) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString e1) ^\n           (\"+\" ^ (((exprToString e2) \"+\") ^ ((exprToString e3) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf \"\") ^ ((exprToString e1) ^ (\"*\" ^ (exprToString e2)))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))))\n  | Factorial e' -> (Format.sprintf \"((\") ^ ((exprToString e') ^ \")!)\")\n  | Sum3 (e1,e2,e3) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2655, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b' = b then b' else wwhile (f, b') in\n  wwhile (f, b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2656, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2657, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, ((f b) = b))), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2658, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, (b, ((f b) = b)))), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2659, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2660, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2661, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((b' = b), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2662, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 512)) in\n     ((wwhile (f, 2)), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2663, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f x = (x * x) * x in ((xx, (xx < 512)), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2664, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2665, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2666, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile (f, (b' = b), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2667, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, (b' = b)), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2668, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f', (b' = b)), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2669, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2670, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (b = (f b))), b);;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2671, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), f'));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2672, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, ((f b) = b)) in ((f b), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2673, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2674, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b = (f, ((f b) = b)) in ((f b), b));;\n", "fix": "\nlet h x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (h, b);;\n"}
{"hw": "hw2", "index": 2675, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f' b' = let bb = f b in (bb, (bb = (f b))) in ((wwhile (f', b)), b));;\n", "fix": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n"}
{"hw": "hw2", "index": 2676, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, ((f b) = b)), b));;\n", "fix": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n"}
{"hw": "hw2", "index": 2677, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = f b in ((f', ((f b) = b)), b));;\n", "fix": "\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n"}
{"hw": "hw2", "index": 2678, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h t) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2679, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | _ ->\n        let seen' = if List.mem 0 seen then seen else 0 :: seen in\n        let rest' = 0 in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | _ ->\n        let seen' = if List.mem 0 seen then seen else 0 :: seen in\n        let rest' = [0] in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2680, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "fix": "\nlet rec wwhile (f,b) = let (a,b) = f b in 5;;\n"}
{"hw": "hw2", "index": 2681, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile (f a) else a;;\n", "fix": "\nlet rec wwhile (f,b) = let (a,b) = f b in 5;;\n"}
{"hw": "hw2", "index": 2682, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2683, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f b') else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2684, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "fix": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n"}
{"hw": "hw2", "index": 2685, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  let temp = l in\n  let rec helper acc (d,k,l) =\n    match temp with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper (d, k, l) t) in\n  helper (d, k, l) acc;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n"}
{"hw": "hw2", "index": 2686, "problem": "assoc", "bad": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper (d, k, l) acc;;\n", "fix": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n"}
{"hw": "hw2", "index": 2687, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((exprToString a) * (exprToString a)) * (exprToString a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y));;\n"}
{"hw": "hw2", "index": 2688, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval a) * (eval a)) * (eval a);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y));;\n"}
{"hw": "hw2", "index": 2689, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) * (eval (a, x, y))) * (eval (a, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y));;\n"}
{"hw": "hw2", "index": 2690, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. eval;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n"}
{"hw": "hw2", "index": 2691, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sin_Avg (a,b,c) ->\n      eval\n        ((eval (a, (sin (pi * x)), (sin (pi * y)))),\n          (eval (b, (sin (pi * x)), (sin (pi * y)))),\n          (eval (c, (sin (pi * x)), (sin (pi * y)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2692, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      eval\n        ((eval (a, (sin (pi * x)), (sin (pi * y)))),\n          (eval (b, (sin (pi * x)), (sin (pi * y)))),\n          (eval (c, (sin (pi * x)), (sin (pi * y)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2693, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (eval\n         ((eval (a, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (b, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (c, (sin (pi *. x)), (sin (pi *. y))))))\n        /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2694, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         + (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2695, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ ((\"*\" (exprToString a)) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 2696, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) \")\")));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n"}
{"hw": "hw2", "index": 2697, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) -> \"sin(pi*\" ^ ((exprToString a (b, c)) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n"}
{"hw": "hw2", "index": 2698, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) -> \"sin(pi*\" ^ ((exprToString (a (b, c))) ^ \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n"}
{"hw": "hw2", "index": 2699, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n"}
{"hw": "hw1", "index": 2700, "problem": "additivePersistence", "bad": "\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> h + (additivePersistence t);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 2701, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> t + (digitsOfInt (additivePersistence h));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 2702, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence sumList (digitsOfInt n));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n"}
{"hw": "hw1", "index": 2703, "problem": "digitalRoot", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in\n  if n < 10 then n + sum else sum = (digitalRoot (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 2704, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2705, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2706, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (n / 10) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2707, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2708, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2709, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [[(digitsOfInt n) / 10]; n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2710, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2711, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2712, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2713, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2714, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2715, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2716, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse l];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2717, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n"}
{"hw": "hw1", "index": 2718, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"}
{"hw": "hw1", "index": 2719, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10); n mod 10] else 0;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n"}
{"hw": "hw1", "index": 2720, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n"}
{"hw": "hw3", "index": 2721, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2722, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2723, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x = if x < 10 then x else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2724, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2725, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2726, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2727, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), ((bigAdd bigMul x l2) @ (c a))) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2728, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((bigMul x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2729, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2730, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], [0]) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2731, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone (x (n - 1))) @ [x]);;\n", "fix": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n"}
{"hw": "hw3", "index": 2732, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2733, "problem": "clone", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2734, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else \"bye\";;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then (l1, (clone 0 a)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2735, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then (l1, (clone 0 a)) else (l1, l2);;\n"}
{"hw": "hw3", "index": 2736, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else List.append (clone 0 (0 - a)) l2;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a)) l1), l2);;\n"}
{"hw": "hw3", "index": 2737, "problem": "padZero", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a))), l2);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a)) l1), l2);;\n"}
{"hw": "hw3", "index": 2738, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2739, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2740, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2741, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2742, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> g a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2743, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> g x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2744, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> g (x a) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2745, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> g x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> g in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2746, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> a (x g) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2747, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> a (g x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> a (x g) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2748, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = function | g -> x (g a) in\n  let base = function | b -> b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x = function | g -> x (a g) in\n  let base = function | b -> b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2749, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sep in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2750, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) < 2 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2751, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) < 2 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2752, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) < 2 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2753, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length ()) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2754, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) > 2 then a ^ (x ^ sep) else x ^ x in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) > 2 then a ^ (x ^ sep) else x ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2755, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun a  -> a l) sepConcat;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2756, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\";\", l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2757, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2758, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> c l)));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2759, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> c l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2760, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2761, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun f  -> f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2762, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map (fun f  -> f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2763, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2764, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n"}
{"hw": "hw3", "index": 2765, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2766, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \" (List.map f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2767, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \", (List.map f l))) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2768, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then buildAverage (build (rand, (depth - 1)))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2769, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2770, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then\n            buildTimes\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if (rand mod 5) = 4\n            then\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2771, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2772, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand mod 2) = 0 then buildX ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2773, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((makeRand (0, 6)), (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2774, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 6)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 6)), (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2775, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 5)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 5)), (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand (0, 4) with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 2))), (build (rand, (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 4))), (build (rand, (depth - 4))),\n             (build (rand, (depth - 4))), (build (rand, (depth - 4))))\n     | _ -> buildY ());;\n"}
{"hw": "hw2", "index": 2776, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (eval e0)\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2777, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi * (eval e0))\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2778, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval e0))\n  | Cosine e1 -> cos (eval e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2779, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. e0)\n  | Cosine e1 -> cos (pi *. e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2780, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. e1)\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2781, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval e2) + (eval e3)) / 2\n  | Times (e4,e5) -> (eval e4) * (eval e5)\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval e6) < (eval e7) then eval e8 else eval e9;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2782, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) + (eval (e3, x, y))) / 2\n  | Times (e4,e5) -> (eval (e4, x, y)) * (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2783, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) / 2\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2784, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2785, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | _ -> \"ya dun f*cked up\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y);;\n"}
{"hw": "hw2", "index": 2786, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) + ((eval (g, x, y)) *. (eval (h, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) +. ((eval (g, x, y)) *. (eval (h, x, y)));;\n"}
{"hw": "hw2", "index": 2787, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2788, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2789, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2790, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2791, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e -> \"%s\" e\n  | Cosine e -> \"%s\" e\n  | Average (e,e) -> \"%s\" e\n  | Times (e,e) -> \"%s\" e\n  | Thresh (e,e,e,e) -> \"%s\" e;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2792, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2793, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2794, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2795, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2796, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2797, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.printf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2798, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%d\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2799, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%x\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2800, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2801, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2802, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2803, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2804, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2805, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2806, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2807, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2808, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2809, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2810, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2811, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" :: e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2812, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2813, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"}
{"hw": "hw2", "index": 2814, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (wwhile (f, (f b)))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2815, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2816, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2817, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2818, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2819, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f :: ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2820, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (f, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2821, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then ((f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2822, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2823, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2824, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (((f b), b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2825, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2826, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) = b))), b);;\n"}
{"hw": "hw2", "index": 2827, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> (f, ((f b) != b))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), ((f b) != b))), b);;\n"}
{"hw": "hw2", "index": 2828, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((f b), ((f b) != b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), (b != (f b)))), b);;\n"}
{"hw": "hw2", "index": 2829, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (fun b  -> ((f b), (b != (f b))))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((fun b  -> ((f b), (b != (f b)))), b);;\n"}
{"hw": "hw2", "index": 2830, "problem": "wwhile", "bad": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f, b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n"}
{"hw": "hw3", "index": 2831, "problem": "mulByDigit", "bad": "\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2832, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then l else mulByDigit ((i - 1), (bigAdd l l));;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2833, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then mulByDigit ((i - 1), (bigAdd l l)) else l;;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2834, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i - 1) l);;\n", "fix": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n"}
{"hw": "hw3", "index": 2835, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f \"; \" l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2836, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f (\"; \" l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 2837, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map (f \"; \") l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 2838, "problem": "digitalRoot", "bad": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "fix": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n"}
{"hw": "hw1", "index": 2839, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n"}
{"hw": "hw1", "index": 2840, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helper xs l =\n    match l with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"hw": "hw1", "index": 2841, "problem": "sumList", "bad": "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "fix": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n"}
{"hw": "hw1", "index": 2842, "problem": "sumList", "bad": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then 0;;\n", "fix": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n"}
{"hw": "hw1", "index": 2843, "problem": "sumList", "bad": "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then xs = 0;;\n", "fix": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n"}
{"hw": "hw1", "index": 2844, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "fix": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n"}
{"hw": "hw1", "index": 2845, "problem": "sumList", "bad": "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "fix": "\nlet rec sum list = match list with | [] -> 0 | head::tail -> head;;\n\nlet rec sumList xs = sum xs;;\n"}
{"hw": "hw1", "index": 2846, "problem": "sumList", "bad": "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw1", "index": 2847, "problem": "sumList", "bad": "\nlet rec sumList xs = match sumList with | h::t -> h + (sumList t);;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw2", "index": 2848, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}
{"hw": "hw2", "index": 2849, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"}
{"hw": "hw2", "index": 2850, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildTangent (e1,e2) = Tangent (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      if (rand (0, 1)) = 1\n      then\n        ((buildTangent (build (rand, (depth - 1)))),\n          (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildTangent (e1,e2) = Tangent (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      if (rand (0, 1)) = 1\n      then\n        buildTangent\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2851, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | _ when r < 20 ->\n           buildAverage\n             ((buildCosine (build (rand, (depth - 1)))),\n               (buildSine (build (rand, (depth - 1)))))\n       | _ when (r < 30) && (r > 20) ->\n           buildThresh\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1)))))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | _ when r < 20 ->\n           buildAverage\n             ((buildCosine (build (rand, (depth - 1)))),\n               (buildSine (build (rand, (depth - 1)))))\n       | _ when (r < 30) && (r > 20) ->\n           buildThresh\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1)))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2852, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | r when r < 5 ->\n           buildAverage\n             ((buildCosine (rand, (depth - 1))),\n               (buildSine (build (rand, (depth - 1)))))\n       | r when (r < 20) && (r > 10) ->\n           buildThresh\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1)))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | r when r < 5 ->\n           buildAverage\n             ((buildCosine (build (rand, (depth - 1)))),\n               (buildSine (build (rand, (depth - 1)))))\n       | r when (r < 20) && (r > 10) ->\n           buildThresh\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1)))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2853, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | r when r < 5 ->\n           ((buildAverage (build (rand, (depth - 1)))),\n             (build (rand, (depth - 1))))\n       | r when (r < 10) && (r > 5) ->\n           buildThresh\n             ((buildCosine (build (rand, (depth - 1)))),\n               (buildCosine (build (rand, (depth - 1)))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (3, 100) in\n      (match r with\n       | r when r < 5 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 10) && (r > 5) ->\n           buildThresh\n             ((buildCosine (build (rand, (depth - 1)))),\n               (buildCosine (build (rand, (depth - 1)))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2854, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 150) in\n      (match r with\n       | r when r < 5 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 10) && (r > 5) ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | r when (r > 25) && (r < 35) ->\n           buildTimes (buildCosine (buildSine (build (rand, (depth - 1)))))\n       | r when (r > 35) && (r < 40) ->\n           buildCosine (buildSine (build (rand, (depth - 1))))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 1 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 150) in\n      (match r with\n       | r when r < 5 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 10) && (r > 5) ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | r when (r < 25) && (r > 20) -> buildSine (build (rand, (depth - 1)))\n       | r when (r > 25) && (r < 35) ->\n           buildTimes\n             ((buildCosine (buildSine (build (rand, (depth - 1))))),\n               (buildSine (build (rand, (depth - 1)))))\n       | r when (r > 35) && (r < 40) ->\n           buildCosine (buildSine (build (rand, (depth - 1))))\n       | _ -> buildCosine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 2855, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | PowerUp (e1,e2) -> (abs (eval (e1, x, y))) ** (abs (eval (e2, x, y)))\n  | Square2 (e1,e2,e3) ->\n      (sqrt\n         ((((eval (e1, x, y)) ** 2.) +. ((eval (e2, x, y)) ** 2.)) +.\n            ((eval (e3, x, y)) ** 2.)))\n        /. 2.\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Square2 (e1,e2,e3) ->\n      (sqrt\n         ((((eval (e1, x, y)) ** 2.) +. ((eval (e2, x, y)) ** 2.)) +.\n            ((eval (e3, x, y)) ** 2.)))\n        /. 2.\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2856, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Tangent of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Tangent (e1,e2) ->\n      if (eval (e1, x, y)) = 0\n      then Nil\n      else (eval (e1, x, y)) /. (eval (e1, x, y))\n  | Square2 (e1,e2,e3) ->\n      (sqrt\n         ((((eval (e1, x, y)) ** 2.) +. ((eval (e2, x, y)) ** 2.)) +.\n            ((eval (e3, x, y)) ** 2.)))\n        /. 2.\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Diff2 of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Diff2 (e1,e2) -> ((eval (e1, x, y)) -. (eval (e2, x, y))) /. 2.\n  | Square2 (e1,e2,e3) ->\n      (sqrt\n         ((((eval (e1, x, y)) ** 2.) +. ((eval (e2, x, y)) ** 2.)) +.\n            ((eval (e3, x, y)) ** 2.)))\n        /. 2.\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n"}
{"hw": "hw2", "index": 2857, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in let rest' = List.mem h l in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2858, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [h] in let rest' = List.mem h l in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 2859, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 2860, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if (List.length ((digitsOfInt (n / 10)) @ [n mod 10])) = 0 then [];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 2861, "problem": "digitsOfInt", "bad": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "fix": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"hw": "hw1", "index": 2862, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "fix": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n"}
{"hw": "hw3", "index": 2863, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2864, "problem": "clone", "bad": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1) in\n  helper n;;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2865, "problem": "clone", "bad": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: (clone x (n - 1)) in\n  helper n;;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2866, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2867, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2868, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec helper n = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2869, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2870, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2871, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2872, "problem": "pipe", "bad": "\nlet pipe fs p =\n  let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x p = x (a p) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2873, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ h in\n      let base = h in let l = sepConcat t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ h in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2874, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sepConcat sep t) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2875, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2876, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi * (eval e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n"}
{"hw": "hw2", "index": 2877, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi *. (eval e));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n"}
{"hw": "hw2", "index": 2878, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0, 0)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0.0, 0.0)));;\n"}
{"hw": "hw2", "index": 2879, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) * (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2880, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2881, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2882, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n"}
{"hw": "hw2", "index": 2883, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n"}
{"hw": "hw2", "index": 2884, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AlternateSign of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AlternateSign e1 -> (eval (e1, x, y)) *. (-1);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Negate e1 -> (eval (e1, x, y)) *. (-1.0);;\n"}
{"hw": "hw2", "index": 2885, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1 then log b else 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0;;\n"}
{"hw": "hw2", "index": 2886, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0;;\n"}
{"hw": "hw2", "index": 2887, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2) + ((eval (e2, x, y)) ** 2)) +\n        ((eval (e3, x, y)) ** 2);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n"}
{"hw": "hw2", "index": 2888, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) + ((eval (e2, x, y)) ** 2.0)) +\n        ((eval (e3, x, y)) ** 2.0);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n        ((eval (e3, x, y)) ** 2.0);;\n"}
{"hw": "hw2", "index": 2889, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2890, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ModF of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10.0) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n"}
{"hw": "hw2", "index": 2891, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" exprToString s;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" ^ (exprToString s);;\n"}
{"hw": "hw2", "index": 2892, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" + (exprToString s);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" ^ (exprToString s);;\n"}
{"hw": "hw2", "index": 2893, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat [\"pi* \"; exprToString s];;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" ^ (exprToString s);;\n"}
{"hw": "hw2", "index": 2894, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> (String.concat \"pi* \") ^ (exprToString s);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" ^ (exprToString s);;\n"}
{"hw": "hw2", "index": 2895, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (exprToString s \")\");;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((exprToString s) ^ \")\");;\n"}
{"hw": "hw2", "index": 2896, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Threshold (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 2897, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 2898, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" exprToString e4)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" ^ (exprToString e4))))));;\n"}
{"hw": "hw2", "index": 2899, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile ((fun a  -> ((f a), ((f a) != a))), b);;\n"}
{"hw": "hw2", "index": 2900, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 2901, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 2902, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2903, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2904, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if t1 + t2 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2905, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (t1 + t2) > 9 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2906, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [h1 + h2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2907, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2908, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2909, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then false in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2910, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then 9 in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2911, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2912, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2913, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2914, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2915, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0 :: a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2916, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> 0 | h::t -> if h > 9 then 8 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2917, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (x * x) in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2918, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2919, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2920, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2921, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2922, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2923, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2924, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)::t2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2925, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | (h::t,(x1,x2)::t2) -> if ((x1 + x2) + h) > 9 then 9 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2926, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2927, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2928, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h1) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2929, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2930, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h2, h1) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2931, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2932, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2933, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2934, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g)::t ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2935, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2936, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::[]) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2937, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit =\n        match x with | (f,g) -> ((f + g) + carry) mod 10 | [] -> carry in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2938, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2939, "problem": "bigMul", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd a x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd y x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 2940, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); h];;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x];;\n"}
{"hw": "hw3", "index": 2941, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); x];;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x];;\n"}
{"hw": "hw3", "index": 2942, "problem": "clone", "bad": "\nlet rec clone x n = match n with | 0 -> [] | 1 -> [clone x (n - 1); x];;\n", "fix": "\nlet rec clone x n = match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x];;\n"}
{"hw": "hw3", "index": 2943, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else\n    (let a = [i] in bigAdd ((mulByDigit i) - (1 l)) ((mulByDigit i) - (1 l)));;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else (let a = [i] in bigAdd (mulByDigit (i - 1) l) (mulByDigit (i - 1) l));;\n"}
{"hw": "hw3", "index": 2944, "problem": "mulByDigit", "bad": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then 0 else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "fix": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then [0]\n  else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n"}
{"hw": "hw3", "index": 2945, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2946, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2947, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2948, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2949, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base b = b in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 2950, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2951, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 2952, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2953, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2954, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a ^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2955, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = a ^^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 2956, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \";\") l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw2", "index": 2957, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2958, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) / 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1 x y) < (eval e2 x y) then eval e3 x y else eval e4 x y;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2959, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' (e', x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw2", "index": 2960, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"}
{"hw": "hw1", "index": 2961, "problem": "additivePersistence", "bad": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence help n) else 0;;\n", "fix": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence (help n)) else 0;;\n"}
{"hw": "hw1", "index": 2962, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [2] else [1];;\n"}
{"hw": "hw1", "index": 2963, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [2] else [1];;\n"}
{"hw": "hw1", "index": 2964, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [2] else [1];;\n"}
{"hw": "hw1", "index": 2965, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [5] @ (digitsOfInt (n / 10)) else [1];;\n"}
{"hw": "hw1", "index": 2966, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 0 then [5] @ ((digitsOfInt n) / 10) else [1];;\n", "fix": "\nlet rec digitsOfInt n = if n > 0 then [5] @ (digitsOfInt (n / 10)) else [1];;\n"}
{"hw": "hw1", "index": 2967, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 10 then (n mod 10) :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n > 10 then (n mod 10) :: (digitsOfInt (n / 10)) else [n];;\n"}
{"hw": "hw1", "index": 2968, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "fix": "\nlet rec digitsOfInt n = if n >= 100 then [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2969, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n > 10 then [n; n mod 10] else n;;\n", "fix": "\nlet rec digitsOfInt n = if n >= 100 then [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2970, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2971, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2972, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2973, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2974, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2975, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2976, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2977, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2978, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2979, "problem": "digitsOfInt", "bad": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n", "fix": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2980, "problem": "digitsOfInt", "bad": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (help n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "fix": "\nlet rec helpFac a b = if (10 * a) > b then a else helpFac (10 * a) b;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (helpFac n 1)) :: (digitsOfInt (n / 10)) else [n];;\n"}
{"hw": "hw1", "index": 2981, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n = if n >= 10 then app [5] [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2982, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n = if n >= 10 then app [5] [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2983, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n = if n >= 10 then app [5] [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2984, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n = if n >= 10 then app [5] [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2985, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2986, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else app [3] [8];;\n"}
{"hw": "hw1", "index": 2987, "problem": "digitsOfInt", "bad": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "fix": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n"}
{"hw": "hw1", "index": 2988, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  if List.length > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "fix": "\nlet rec listReverse l = if (List.length l) > 0 then [List.hd l] else [];;\n"}
{"hw": "hw1", "index": 2989, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "fix": "\nlet rec listReverse l = if (List.length l) > 0 then [List.hd l] else [];;\n"}
{"hw": "hw1", "index": 2990, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList List.tl xs) else 0;;\n", "fix": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n"}
{"hw": "hw1", "index": 2991, "problem": "additivePersistence", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList digitOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 2992, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else n = (sumList (digitsOfInt n));;\n", "fix": "\nlet a = int_of_char '3';;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then a else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 2993, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else n = (sumList (digitsOfInt n)) in\n  match n with | 0 -> 0 | _ -> n;;\n", "fix": "\nlet a = int_of_char '3';;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then a else additivePersistence (sumList (digitsOfInt n));;\n"}
{"hw": "hw1", "index": 2994, "problem": "digitsOfInt", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n"}
{"hw": "hw3", "index": 2995, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2996, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,_) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ a))\n          else (0, (((arg1 + arg2) + 1) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,acc) ->\n          if (arg1 + arg2) > 9\n          then (1, (((arg1 + arg2) mod 10) :: acc))\n          else (0, ((arg1 + arg2) :: acc))\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,acc) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ((((arg1 + arg2) + 1) mod 10) :: acc))\n          else (0, (((arg1 + arg2) + 1) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 2997, "problem": "clone", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n"}
{"hw": "hw3", "index": 2998, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else ((((clone 0) - diff) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 2999, "problem": "padZero", "bad": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 abs diff) @ l1), l2);;\n", "fix": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n"}
{"hw": "hw3", "index": 3000, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3001, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = 0 in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3002, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (1, 2) in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3003, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3004, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3005, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, 2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3006, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3007, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, 0) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3008, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3009, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3010, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 (List.length l1))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = clone 0 (List.length l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3011, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((0 :: ((List.rev l1), 0)), []) in\n    let args = 0 :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((0 :: (List.rev l1)), 0), []) in\n    let args = 0 :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3012, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((((List.rev 0) :: l1), 0), []) in\n    let args = (List.rev 0) :: l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev (0 :: l1)), 0), []) in\n    let args = List.rev (0 :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3013, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev (0 :: l1)), 0), []) in\n    let args = List.rev (0 :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulByDigit_RT i acc =\n    if i = 0 then acc else mulByDigit_RT (i - 1) (bigAdd acc l) in\n  mulByDigit_RT i [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,acc) = a in\n    let digmul = mulByDigit (i * x) l2 in ((i * 10), (bigAdd digmul acc)) in\n  let base = (1, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3014, "problem": "clone", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n"}
{"hw": "hw3", "index": 3015, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2)\n  else List.append ((List.append ((clone 0 diff), len2)), len1);;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else ((List.append (clone 0 diff) l2), l1);;\n"}
{"hw": "hw3", "index": 3016, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2);;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else ((List.append (clone 0 diff) l2), l1);;\n"}
{"hw": "hw3", "index": 3017, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append ((clone 0 (- diff)), len1)), len2)\n  else ((List.append ((clone 0 diff), len2)), len1);;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else ((List.append (clone 0 diff) l2), l1);;\n"}
{"hw": "hw3", "index": 3018, "problem": "padZero", "bad": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) len1), len2)\n  else ((List.append (clone 0 diff) len2), len1);;\n", "fix": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else ((List.append (clone 0 diff) l2), l1);;\n"}
{"hw": "hw3", "index": 3019, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3020, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3021, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3022, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3023, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3024, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3025, "problem": "pipe", "bad": "\nlet pipe fs = let f a x _ = x a in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3026, "problem": "pipe", "bad": "\nlet pipe fs = let f a x _ = x a in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3027, "problem": "pipe", "bad": "\nlet pipe fs = let f a x _ = a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x x = x in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3028, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x y = x y in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3029, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3030, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y = y a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3031, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y = a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3032, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3033, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3034, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3035, "problem": "pipe", "bad": "\nlet pipe fs = let f a x z = z a in let base y = y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x z = a z in let base y = y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3036, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l = (^) sep in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in\n      let l = [(fun x  -> x ^ sep)] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3037, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l x = x ^ sep in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in\n      let l = [(fun x  -> x ^ sep)] in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3038, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in\n      let l = [(fun x  -> x ^ sep)] in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3039, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left f base xs;;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left g base xs;;\n"}
{"hw": "hw3", "index": 3040, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  let g a x = a ^ (\"; \" ^ (f x)) in \"[\" ^ ((List.map g l) \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3041, "problem": "stringOfList", "bad": "\nlet stringOfList f l = let g x = (f x) ^ \"; \" in \"[\" ^ ((List.map g l) \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3042, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map (fun x  -> x ^ \"; \") l) \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3043, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map \";\" sepConcat) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3044, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\") ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3045, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat l) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3046, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (sepConcat \"; \") l) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3047, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3048, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3049, "problem": "stringOfList", "bad": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList (List.map f l)) ^ \"]\");;\n", "fix": "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3050, "problem": "stringOfList", "bad": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n"}
{"hw": "hw2", "index": 3051, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then let base = rand 0 2 in match base with | 0 -> buildX | 1 -> buildY;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 5) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then build (rand, (depth - 1))\n         else build (rand, (depth - 1)));;\n"}
{"hw": "hw2", "index": 3052, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 5) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (rand, (depth - 1))\n         else buildSine (rand, (depth - 1)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 5) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (build (rand, (depth - 1)))\n         else buildSine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3053, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr* expr\n  | Special2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSpecial1 (e1,e2,e3) = Special1 (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 6) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildSpecial1\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (build (rand, (depth - 1)))\n         else buildSine (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr* expr\n  | Special2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSpecial1 (e1,e2,e3) = Special1 (e1, e2, e3);;\n\nlet buildSpecial2 (e1,e2) = Special2 (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 6) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildSpecial1\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 6 ->\n         buildSpecial2\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (build (rand, (depth - 1)))\n         else buildSine (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3054, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi * (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi * (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n"}
{"hw": "hw2", "index": 3055, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n"}
{"hw": "hw2", "index": 3056, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n"}
{"hw": "hw2", "index": 3057, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y)\n  | Special1 (var11,var12) ->\n      ((sin (pi *. (eval (var11, x, y)))) *.\n         (cos (pi *. (eval (var12, x, y)))))\n        /. 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y)\n  | Special1 (var11,var12) ->\n      ((sin (pi *. (eval (var11, x, y)))) *.\n         (cos (pi *. (eval (var12, x, y)))))\n        /. 2.0;;\n"}
{"hw": "hw2", "index": 3058, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\" b\n  | Sine var1 -> (\"sin (pi*\" + (exprToString var1)) + \")\"\n  | Cosine var2 -> (\"cos (pi*\" + (exprToString var2)) + \")\"\n  | Average (var3,var4) ->\n      (((\"((\" exprToString var3) + \" + \") + (exprToString var4)) + \")/2)\"\n  | Times (var5,var6) -> ((exprToString var5) + \" * \") + (exprToString var6)\n  | Thresh (var7,var8,var9,var0) ->\n      (((((((\"(\" exprToString var7) + \"<\") + (exprToString var8)) + \" ? \") +\n           (exprToString var9))\n          + \" : \")\n         + (exprToString var0))\n        + \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\" ? \" ^\n                    ((exprToString var9) ^\n                       (\" : \" ^ ((exprToString var0) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3059, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> (\"sin (pi*\" + (exprToString var1)) + \")\"\n  | Cosine var2 -> (\"cos (pi*\" + (exprToString var2)) + \")\"\n  | Average (var3,var4) ->\n      (((\"((\" exprToString var3) + \" + \") + (exprToString var4)) + \")/2)\"\n  | Times (var5,var6) -> ((exprToString var5) + \" * \") + (exprToString var6)\n  | Thresh (var7,var8,var9,var0) ->\n      (((((((\"(\" exprToString var7) + \"<\") + (exprToString var8)) + \" ? \") +\n           (exprToString var9))\n          + \" : \")\n         + (exprToString var0))\n        + \")\";;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\" ? \" ^\n                    ((exprToString var9) ^\n                       (\" : \" ^ ((exprToString var0) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3060, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      (\"(\" exprToString var7) ^\n        (\"<\" ^\n           ((exprToString var8) ^\n              (\" ? \" ^\n                 ((exprToString var9) ^ (\" : \" ^ ((exprToString var0) ^ \")\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\" ? \" ^\n                    ((exprToString var9) ^\n                       (\" : \" ^ ((exprToString var0) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3061, "problem": "removeDuplicates", "bad": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append_new h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3062, "problem": "removeDuplicates", "bad": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append_new h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 3063, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l else l;;\n"}
{"hw": "hw1", "index": 3064, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l;;\n", "fix": "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l else l;;\n"}
{"hw": "hw1", "index": 3065, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 3066, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [digitsOfInt n];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 3067, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"hw": "hw1", "index": 3068, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "fix": "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 3069, "problem": "digitsOfInt", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (fun help  ->\n       fun n  -> match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10));;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n"}
{"hw": "hw1", "index": 3070, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t l) :: h;;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n"}
{"hw": "hw1", "index": 3071, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat l h) :: t;;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n"}
{"hw": "hw1", "index": 3072, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t h) :: l;;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n"}
{"hw": "hw1", "index": 3073, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse ((cat l h) :: t);;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n"}
{"hw": "hw1", "index": 3074, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (t :: (cat l h));;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (cat l h);;\n"}
{"hw": "hw1", "index": 3075, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat h (listReverse t);;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse t) h;;\n"}
{"hw": "hw1", "index": 3076, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat l (listReverse t h);;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse t) h;;\n"}
{"hw": "hw1", "index": 3077, "problem": "listReverse", "bad": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> cat listReverse t h;;\n", "fix": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat (listReverse t) h;;\n"}
{"hw": "hw1", "index": 3078, "problem": "sumList", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "fix": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n"}
{"hw": "hw3", "index": 3079, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3080, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [l1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3081, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3082, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3083, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3084, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3085, "problem": "bigAdd", "bad": "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3086, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3087, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3088, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3089, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3090, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3091, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3092, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3093, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3094, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3095, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3096, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3097, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3098, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3099, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3100, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3101, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3102, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3103, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3104, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3105, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3106, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3107, "problem": "bigAdd", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3108, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> a @ b in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3109, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3110, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3111, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3112, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3113, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3114, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3115, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3116, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = (0, []) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3117, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [[(h, l2)]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3118, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [[(h, l2)]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3119, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3120, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3121, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [1]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3122, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3123, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3124, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3125, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (d :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3126, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (d :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3127, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (d :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3128, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (d :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3129, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, t) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3130, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, t) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3131, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, t) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3132, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, t) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3133, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3134, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3135, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3136, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3137, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3138, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3139, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3140, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3141, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3142, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3143, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3144, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3145, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3146, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3147, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3148, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3149, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3150, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3151, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3152, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3153, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3154, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3155, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3156, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3157, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3158, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3159, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          ((d1 + d2), ((d1 + d2) :: ((match a with | (a1,a2) -> a2)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3160, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3161, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3162, "problem": "bigAdd", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3163, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l = let h::t = List.rev l in (mulByDigit h) * i;;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 3164, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l = let h::t = List.rev l in mulByDigit (h * i);;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 3165, "problem": "mulByDigit", "bad": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n", "fix": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) (bigAdd l l);;\n"}
{"hw": "hw3", "index": 3166, "problem": "padZero", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 3167, "problem": "padZero", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 3168, "problem": "padZero", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 3169, "problem": "padZero", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"hw": "hw3", "index": 3170, "problem": "padZero", "bad": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "fix": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n"}
{"hw": "hw3", "index": 3171, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3172, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3173, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3174, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3175, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3176, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3177, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3178, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3179, "problem": "pipe", "bad": "\nlet pipe fs = let f a x f = f x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3180, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3181, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3182, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3183, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3184, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3185, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3186, "problem": "pipe", "bad": "\nlet x _ f = f;;\n\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3187, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3188, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3189, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3190, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3191, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = t in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3192, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = h in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3193, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3194, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep :: (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3195, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3196, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3197, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat (sep t) in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3198, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3199, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sepConcat (h ^ (sep t)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3200, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat h) ^ (sep t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3201, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x f _ = a * a in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3202, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = () in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3203, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\";;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3204, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat l \"\") f;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3205, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) f;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3206, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3207, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3208, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3209, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) (f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw3", "index": 3210, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" (List.map f l);;\n"}
{"hw": "hw2", "index": 3211, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3212, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3213, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3214, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3215, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3216, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> VarX\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  match case with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3217, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 ->\n        buildFiboPlus\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 ->\n        buildFiboPlus\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 3218, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSixtyNine e1 = SixtyNine e1;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildSixtyNine (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 3219, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSixtyNine e1 = SixtyNine e1;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildSixtyNine (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"}
{"hw": "hw2", "index": 3220, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3221, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3222, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3223, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3224, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3225, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex x y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)));;\n"}
{"hw": "hw2", "index": 3226, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3227, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3228, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      ((exprToString (ex1, x, y)) +. (exprToString (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3229, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3230, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3231, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3232, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3233, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3234, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((exprToString ex1) * ((exprToString ex1) + (exprToString ex2))) *\n          (((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)))\n         *\n         ((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4)))\n        *\n        (((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4))\n           + (exprToString ex5));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)));;\n"}
{"hw": "hw2", "index": 3235, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) * ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)));;\n"}
{"hw": "hw2", "index": 3236, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) *. ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)));;\n"}
{"hw": "hw2", "index": 3237, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) + (eval (ex2, x, y)))) *\n          (((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))))\n         *\n         ((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y))))\n        *\n        (((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y)))\n           + (eval (ex5, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)));;\n"}
{"hw": "hw2", "index": 3238, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) * (sin (pi * (eval (ex2, x, y))))) *\n         (cos (pi * (eval (ex3, x, y)))))\n        / 2;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n"}
{"hw": "hw2", "index": 3239, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n        (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3) ->\n      ((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n        (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n"}
{"hw": "hw2", "index": 3240, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      (eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2) ->\n      (eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n"}
{"hw": "hw2", "index": 3241, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | SixtyNine ex1 -> (eval (ex1, x, y)) *. 69.\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | SixtyNine ex1 -> (eval (ex1, x, y)) *. 69.\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) *. (sin (pi *. (eval (ex2, x, y))))) *.\n         (cos (pi *. (eval (ex3, x, y)))))\n        /. 2.;;\n"}
{"hw": "hw2", "index": 3242, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> ex1 ^ (\"*\" ^ ex2)\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3243, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2 \"+\") ^\n                                   ((exprToString ex3) ^\n                                      (\")*(\" ^\n                                         ((exprToString ex1) ^\n                                            (\"+\" ^\n                                               ((exprToString ex2 \"+\") ^\n                                                  ((exprToString ex3 \"+\") ^\n                                                     ((exprToString ex4) ^\n                                                        (\")*(\" ^\n                                                           ((exprToString ex1)\n                                                              ^\n                                                              (\"+\" ^\n                                                                 ((exprToString\n                                                                    ex2 \"+\")\n                                                                    ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex3 \"+\")\n                                                                    ^\n                                                                    ((exprToString\n                                                                    ex4 \"+\")\n                                                                    ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))));;\n"}
{"hw": "hw2", "index": 3244, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^ ((\")*cos(\" exprToString ex3) ^ (\")\" \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^ (\")*cos(\" ^ ((exprToString ex3) ^ \"))\")))));;\n"}
{"hw": "hw2", "index": 3245, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(\" ^ ((exprToString ex3) ^ (\")\" \")\"))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^ (\")*cos(\" ^ ((exprToString ex3) ^ \"))\")))));;\n"}
{"hw": "hw2", "index": 3246, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^ ((exprToString ex3) ^ \"))\")))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\"*sin(pi*\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(pi*\" ^ ((exprToString ex3) ^ \"))/2)\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^ ((exprToString ex3) ^ \"))\")))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\"*sin(pi*\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(pi*\" ^ ((exprToString ex3) ^ \"))/2)\")))));;\n"}
{"hw": "hw2", "index": 3247, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | SixtyNine ex1 -> \"((\" ^ ((exprToString ex1) ^ \"*69))\")\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex3) ^\n           (\"=\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex1) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | SixtyNine ex1 -> \"((\" ^ ((exprToString ex1) ^ \"*69))\")\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex3) ^\n           (\"=\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex1) ^ \")\")))))));;\n"}
{"hw": "hw3", "index": 3248, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3249, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3250, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3251, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3252, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x,y) -> x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3253, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = match a with | (x,y) -> x in carry in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3254, "problem": "bigAdd", "bad": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3255, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3256, "problem": "pipe", "bad": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3257, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3258, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = let existing = a in let next = x in existing next in\n  let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3259, "problem": "sepConcat", "bad": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3260, "problem": "sepConcat", "bad": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a else a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3261, "problem": "sepConcat", "bad": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then a ^ x in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3262, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a = \"a\" then a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3263, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> 1 in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (h * h) + (sqsum t) in\n  let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3264, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x x = x * x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3265, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x _ x = x * x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3266, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3267, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3268, "problem": "stringOfList", "bad": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n", "fix": "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let nl = List.map f l in sepConcat \"\" nl;;\n"}
{"hw": "hw3", "index": 3269, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = List.rev l1 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3270, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3271, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3272, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2)) List.combine (padZero [9; 9] [1; 0; 0; 2]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3273, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h1 + h2) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3274, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> ((h1 + h2), a) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3275, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3276, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3277, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (a, (h1 + h2)) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3278, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3279, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1) + v2) + h2) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3280, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1), (v2 + h2))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3281, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> [((v1 + h1), (v2 + h2))]) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match list1 with\n           | [] -> (match x with | (h1,h2) -> (((h1 + h2) :: list1), list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3282, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match x with\n           | (h1,h2) -> (((h1 + h2) / 10), (((h1 + h2) mod 10) :: list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) ->\n          (match x with\n           | (h1,h2) ->\n               ((((h1 + h2) / 10) :: list1), (((h1 + h2) mod 10) :: list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3283, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (list1,list2) -> list1 in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (list1,list2) -> (list1, list2) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3284, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) -> (match (list1, list2) with | [] -> ([], [])) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | ([],[]) -> ([], []) | (list1,list2) -> (list1, list2) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3285, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> (list1, list2)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3286, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3287, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> ([], [])\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3288, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | ([],[]) -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3289, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (((((h1 + h2) + lh1) / 10) :: lt1),\n                 ((((h1 + h2) + lh1) mod 10) :: lt2))\n           | ([],[]) ->\n               (match x with\n                | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ([v1], [v2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3290, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))\n                     | ([],[]) ->\n                         (match x with\n                          | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ([v1], [v2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3291, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ([v1], [v2]) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3292, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ((v1 :: a), (v2 :: a)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (h1::t1,h2::t2) -> ((v1 :: h1 :: t1), (v2 :: h2 :: t2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3293, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) -> (match a with | ([],[]) -> ((v1 :: a), (v2 :: a))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((v1 :: list1), (v2 :: list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3294, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               ((List.append list1 v1), (List.append list2 v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((v1 :: list1), (v2 :: list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3295, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((list1 @ v1), (list2 @ v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((v1 :: list1), (v2 :: list2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3296, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = (List.rev (List.combine l1 l2)) :: (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3297, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2) (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3298, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3299, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> (c, (bigAdd d (mulByDigit k v)))) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3300, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> (c, (bigAdd d (mulByDigit k v)))) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3301, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> (c, (bigAdd d (mulByDigit k v)))) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3302, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> ([k], v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3303, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> ([k], v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3304, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> ([k], v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3305, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3306, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3307, "problem": "bigMul", "bad": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (mulByDigit k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"hw": "hw3", "index": 3308, "problem": "clone", "bad": "\nlet rec clone x n = let i = 0 in if i < n then x :: ((clone x n) - 1) else [];;\n", "fix": "\nlet rec clone x n = let i = 0 in if i < n then x :: (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 3309, "problem": "clone", "bad": "\nlet rec clone x n = let i = 0 in if i < n then [(clone x n) - 1; x] else [];;\n", "fix": "\nlet rec clone x n = let i = 0 in if i < n then x :: (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 3310, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (List.rev i t);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3311, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3312, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [(h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3313, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [mulByDigit i t; (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> List.append (mulByDigit i t) [(h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3314, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((h * i) mod 10) :: (((h * i) / 10) + h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [(h * i) mod 10; ((h * i) / 10) + h];;\n"}
{"hw": "hw3", "index": 3315, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [(mulByDigit i t) ((h * i) mod 10)];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> List.append (mulByDigit i t) [h * i];;\n"}
{"hw": "hw3", "index": 3316, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::t -> h * i;;\n", "fix": "\nlet rec mulByDigit i l = match l with | [] -> [] | h::m::t -> t;;\n"}
{"hw": "hw3", "index": 3317, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t -> ((h * i) mod 10) :: (((h * i) / 10) + (m * i));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t -> [(h * i) mod 10; ((h * i) / 10) + (m * i)];;\n"}
{"hw": "hw3", "index": 3318, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      [(mulByDigit m)\n      ::\n      t;\n      ((h * i) / 10) + ((m * i) mod 10);\n      (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3319, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3320, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit i m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3321, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | []::[] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | _::[] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"}
{"hw": "hw3", "index": 3322, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev l); h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> (mulByDigit i (List.rev l)) @ [h * i];;\n"}
{"hw": "hw3", "index": 3323, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) @ [0]) @ [h * i];;\n"}
{"hw": "hw3", "index": 3324, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) @ 0) @ [h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) @ [0]) @ [h * i];;\n"}
{"hw": "hw3", "index": 3325, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) @ [h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> (mulByDigit i (List.rev t)) @ [h * i];;\n"}
{"hw": "hw3", "index": 3326, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3327, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3328, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> [x * 10]) t))) @ [h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3329, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper lst =\n             match lst with | [] -> [] | h1::t1 -> [helper t1; h1 mod 10] in\n           helper [h]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper lst =\n             match lst with | [] -> [] | h1::t1 -> (helper t1) @ [h1 mod 10] in\n           helper [h]);;\n"}
{"hw": "hw3", "index": 3330, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = ((helper v) / 10) @ [h1 mod 10] in helper h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = (helper (v / 10)) @ [v mod 10] in helper h);;\n"}
{"hw": "hw3", "index": 3331, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [(helper v) / 10; h1 mod 10] in helper h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = (helper (v / 10)) @ [v mod 10] in helper h);;\n"}
{"hw": "hw3", "index": 3332, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [helper (v / 10); h1 mod 10] in helper h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = (helper (v / 10)) @ [v mod 10] in helper h);;\n"}
{"hw": "hw3", "index": 3333, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] h);;\n"}
{"hw": "hw3", "index": 3334, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}
{"hw": "hw3", "index": 3335, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> 0\n       | h::t -> h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}
{"hw": "hw3", "index": 3336, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = v = 0 in helper [] h1);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 ->\n           let rec helper acc v = if v = 0 then [1] else [0] in helper [] h1);;\n"}
{"hw": "hw3", "index": 3337, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> false\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = [v] = [0] in helper [] h1);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3338, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      (helper ((mulByDigit i (List.rev t)) * 10)) + (h * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3339, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3340, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3341, "problem": "mulByDigit", "bad": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [((mulByDigit i (List.rev t)) * 10) + (h * i)] with\n       | x::y ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] x);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3342, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((mulByDigit i (List.rev t)) * 10) + (h * i)];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3343, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3344, "problem": "mulByDigit", "bad": "\nlet rec helper acc v =\n  if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10);;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper [] h;;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3345, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper [] h;;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3346, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3347, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3348, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        ((helper [] (h * i)) @ []);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3349, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3350, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3351, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> h in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3352, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> [] | h::t -> [bigAdd h (adder t)] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3353, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (match [adder\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [helper [] (h * i)])]\n       with\n       | h::t -> h);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3354, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3355, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           ((helper [] (h * i)) @ []));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        ((helper [] (h * i)) @ []);;\n"}
{"hw": "hw3", "index": 3356, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        (helper [] (h * i));;\n"}
{"hw": "hw3", "index": 3357, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        (helper [] (h * i));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        (helper [] (h * i));;\n"}
{"hw": "hw3", "index": 3358, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               (helper [] (h * i))\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3359, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3360, "problem": "mulByDigit", "bad": "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y -> x);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3361, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3362, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) + (h * i);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3363, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) @ [h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3364, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3365, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3366, "problem": "mulByDigit", "bad": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      sqsum\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i]);;\n", "fix": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      [sqsum\n         ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i])];;\n"}
{"hw": "hw3", "index": 3367, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((mulByDigit i (List.rev t)) * 10) + (h * i)];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3368, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with | n -> [n]);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3369, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3370, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               (helper [] (h * i))\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3371, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i];;\n"}
{"hw": "hw3", "index": 3372, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> [h]);;\n"}
{"hw": "hw3", "index": 3373, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v = if v = 0 then acc else v mod 10 in\n           helper [] h);;\n", "fix": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v = if v = 0 then acc else [v mod 10] in\n           helper [] h);;\n"}
{"hw": "hw3", "index": 3374, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        match v with | [] -> [] | h::t -> if h = 0 then acc else 0 :: acc in\n      (helper [] mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [h * i];;\n", "fix": "\nlet rec mulByDigit i l = match l with | [] -> [];;\n"}
{"hw": "hw3", "index": 3375, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n", "fix": "\nlet rec mulByDigit i l = match l with | [] -> [];;\n"}
{"hw": "hw3", "index": 3376, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper []);;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] h);;\n"}
{"hw": "hw3", "index": 3377, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in List.fold_left f base (h :: t));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in [List.fold_left f base (h :: t)]);;\n"}
{"hw": "hw3", "index": 3378, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in\n           (match [List.fold_left f base (h :: t)] with\n            | [] -> []\n            | a::b ->\n                let rec helper acc v =\n                  if v = 0\n                  then acc\n                  else ((v / 10) mod 10) :: ((v mod 10) :: acc) :: acc in\n                helper [] a));;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in\n           (match [List.fold_left f base (h :: t)] with\n            | [] -> []\n            | a::b ->\n                let rec helper acc v =\n                  if v = 0\n                  then acc\n                  else ((v / 10) mod 10) :: (v mod 10) :: acc in\n                helper [] a));;\n"}
{"hw": "hw3", "index": 3379, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper []\n        (List.hd\n           [List.fold_left f base\n              ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                 [h * i])]);;\n"}
{"hw": "hw3", "index": 3380, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper []\n        (List.hd\n           [List.fold_left f base\n              ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                 [h * i])]);;\n"}
{"hw": "hw3", "index": 3381, "problem": "mulByDigit", "bad": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper h;;\n", "fix": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper [] h;;\n"}
{"hw": "hw3", "index": 3382, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) helper\n        [] (h * i);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n"}
{"hw": "hw3", "index": 3383, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n"}
{"hw": "hw3", "index": 3384, "problem": "padZero", "bad": "\nlet padZero l1 l2 =\n  let length_diff = (List.length l1) - (List.length l2) in\n  if length_diff < 0\n  then length_diff = ((List.length l1) - (List.length l2))\n  else length_diff;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n"}
{"hw": "hw3", "index": 3385, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3386, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3387, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3388, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> h x in\n  let base = 3 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3389, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3390, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3391, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = List.map x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3392, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3393, "problem": "pipe", "bad": "\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3394, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3395, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3396, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" ^ x)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3397, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" ^ x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" ^ x)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3398, "problem": "sqsum", "bad": "\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs = let f a x = a * a in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3399, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3400, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3401, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3402, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw3", "index": 3403, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3404, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3405, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = ((List.length l1), []) in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3406, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: a)))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3407, "problem": "bigAdd", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3408, "problem": "clone", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n"}
{"hw": "hw3", "index": 3409, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then (helper 0 num) :: (xs' xs)\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "fix": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else helper 1 (((num / 10) mod 10) :: (num mod 10) :: xs') xs)\n        else\n          (let num = x * i in\n           if num < 10\n           then helper 0 (num :: accum) xs\n           else helper 1 (((num / 10) mod 10) :: (num mod 10) :: accum) xs) in\n  helper 0 [] lre;;\n"}
{"hw": "hw3", "index": 3410, "problem": "mulByDigit", "bad": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "fix": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else helper 1 (((num / 10) mod 10) :: (num mod 10) :: xs') xs)\n        else\n          (let num = x * i in\n           if num < 10\n           then helper 0 (num :: accum) xs\n           else helper 1 (((num / 10) mod 10) :: (num mod 10) :: accum) xs) in\n  helper 0 [] lre;;\n"}
{"hw": "hw3", "index": 3411, "problem": "padZero", "bad": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n", "fix": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n"}
{"hw": "hw3", "index": 3412, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x fs in let base = 0 in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3413, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x fs in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3414, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3415, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3416, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3417, "problem": "pipe", "bad": "\nlet pipe fs = let f a x x = a in let base q = q in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3418, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3419, "problem": "pipe", "bad": "\nlet pipe fs = let f a x a = a x in let base a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3420, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x w = x (a w) in let base a = a in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3421, "problem": "stringOfList", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f \"\" l)) ^ \"]\");;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n"}
{"hw": "hw1", "index": 3422, "problem": "digitalRoot", "bad": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList n);;\n", "fix": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList (digits n));;\n"}
{"hw": "hw1", "index": 3423, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = (n mod 10) :: (if n <> [] then digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n"}
{"hw": "hw1", "index": 3424, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = (n mod 10) :: (if n > 0 then digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n"}
{"hw": "hw1", "index": 3425, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let int list digInt = (n mod 10) :: digInt in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 3426, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let int list digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 3427, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> (listReverse l) :: x;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l);;\n"}
{"hw": "hw1", "index": 3428, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l x);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l);;\n"}
{"hw": "hw1", "index": 3429, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  let h::t = l in match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 3430, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "fix": "\nlet rec listReverse l =\n  let h::t = l in match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 3431, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 3432, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  if l <> [] then match l with | [] -> l | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse2 l dest =\n  match l with | [] -> [] | h::t -> listReverse2 t (h :: dest);;\n\nlet rec listReverse l = listReverse2 l [];;\n"}
{"hw": "hw1", "index": 3433, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (hd xs));;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n"}
{"hw": "hw1", "index": 3434, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (List.hd xs));;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n"}
{"hw": "hw1", "index": 3435, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.hd xs));;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n"}
{"hw": "hw1", "index": 3436, "problem": "sumList", "bad": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n"}
{"hw": "hw1", "index": 3437, "problem": "sumList", "bad": "\nlet rec sumList xs = let x::t = xs in if t != [] then x + (sumList t);;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n"}
{"hw": "hw1", "index": 3438, "problem": "sumList", "bad": "\nlet rec sumList xs = let x::t = xs in if x != [] then x + (sumList t);;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n"}
{"hw": "hw1", "index": 3439, "problem": "sumList", "bad": "\nlet rec sumList xs = let x::t = xs in x + (if t != [] then sumList t);;\n", "fix": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n"}
{"hw": "hw1", "index": 3440, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | h::t -> h + t;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 3441, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList (digitsOfInt n);;\n"}
{"hw": "hw1", "index": 3442, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}
{"hw": "hw1", "index": 3443, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}
{"hw": "hw1", "index": 3444, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}
{"hw": "hw1", "index": 3445, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"}
{"hw": "hw1", "index": 3446, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}
{"hw": "hw1", "index": 3447, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}
{"hw": "hw1", "index": 3448, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}
{"hw": "hw1", "index": 3449, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}
{"hw": "hw1", "index": 3450, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else x;;\n"}
{"hw": "hw1", "index": 3451, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n"}
{"hw": "hw1", "index": 3452, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  [1; 2];\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n"}
{"hw": "hw1", "index": 3453, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else 1 :: x;\n  sumList x;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n"}
{"hw": "hw1", "index": 3454, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList [x]);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n"}
{"hw": "hw1", "index": 3455, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\" print_newline ();\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\";\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n"}
{"hw": "hw1", "index": 3456, "problem": "additivePersistence", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    ((print_string \"going into then\") / (print_newline ());\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\";\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n"}
{"hw": "hw1", "index": 3457, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else n mod 10;;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n"}
{"hw": "hw1", "index": 3458, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod (10 n)];;\n", "fix": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n];;\n"}
{"hw": "hw1", "index": 3459, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3460, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) @ myList;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3461, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "fix": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [] else [];;\n"}
{"hw": "hw1", "index": 3462, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "fix": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [] else [];;\n"}
{"hw": "hw1", "index": 3463, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3464, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3465, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3466, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else (n mod 10) :: ((myList n) mod 100) :: myList;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3467, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else n = (n - (n mod 10)); (n :: myList) :: digitsOfInt;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3468, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n", "fix": "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) :: myList;;\n"}
{"hw": "hw1", "index": 3469, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 3470, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((n mod 10) :: (digitsOfInt (n / 10))) List.rev;;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"hw": "hw1", "index": 3471, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "fix": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev (digitsOfInt (n / 10)));;\n"}
{"hw": "hw1", "index": 3472, "problem": "listReverse", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [];;\n"}
{"hw": "hw1", "index": 3473, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 3474, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> t :: (listReverse t);;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 3475, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n"}
{"hw": "hw1", "index": 3476, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | (h::t)::t -> [];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 3477, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::h::t -> [];;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n"}
{"hw": "hw1", "index": 3478, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t; [h]);;\n"}
{"hw": "hw1", "index": 3479, "problem": "listReverse", "bad": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [(listReverse t) h];;\n", "fix": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t; [h]);;\n"}
{"hw": "hw1", "index": 3480, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w =\n  let explosion = explode w in\n  if explosion = (listReverse explosion) then true else false;;\n"}
{"hw": "hw2", "index": 3481, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 -> buildAverage (build (rand, (depth - 1)))\n       | 3 -> buildTimes (build (rand, (depth - 1)))\n       | 4 -> buildThresh (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"}
{"hw": "hw2", "index": 3482, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n"}
{"hw": "hw2", "index": 3483, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n"}
{"hw": "hw2", "index": 3484, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr) ^ \")/2)\")))\n  | Times (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"*\" ^ ((exprToString expr) ^ \")\")))\n  | Thresh (expr,expr,expr,expr) ->\n      \"(\" ^ (expr ^ (\"<\" ^ (expr ^ (\"?\" ^ (expr ^ (\":\" ^ (expr ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3485, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        (expr0 ^ (\"<\" ^ (expr1 ^ (\"?\" ^ (expr2 ^ (\":\" ^ (expr3 ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3486, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "fix": "\nlet fixpoint (f,b) = 0;;\n"}
{"hw": "hw2", "index": 3487, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "fix": "\nlet fixpoint (f,b) = 0;;\n"}
{"hw": "hw2", "index": 3488, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x) = b), b));;\n", "fix": "\nlet fixpoint (f,b) = 0;;\n"}
{"hw": "hw2", "index": 3489, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((((f x) = b), b), b));;\n", "fix": "\nlet fixpoint (f,b) = 0;;\n"}
{"hw": "hw2", "index": 3490, "problem": "fixpoint", "bad": "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3491, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b) = b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3492, "problem": "fixpoint", "bad": "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3493, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then true else (false, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3494, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((b, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3495, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((b, ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3496, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3497, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b) <> b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3498, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (match (f, b) with | (b',c') -> (((f b') <> b'), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3499, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not f), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3500, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3501, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not f), ((f b) = b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3502, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (fun x  -> ((not x), ((f b) = b)))), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3503, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3504, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3505, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3506, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3507, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let x = not f in ((x, ((f b) = b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3508, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f) b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3509, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f b) b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3510, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((not (f b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3511, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3512, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) <> b)), b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3513, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3514, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (fun func  -> fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3515, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x y = (x, ((x y) <> y)) in ((func f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3516, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with | true  -> (x, true) | false  -> (x, false) in\n     ((func f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3517, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with\n       | true  -> ((x, true), b)\n       | false  -> ((x, false), b) in\n     func f b);;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3518, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x y x y = (y, true) in ((func f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3519, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func f b), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3520, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), (not ((f b) = b))), b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n"}
{"hw": "hw2", "index": 3521, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in (func, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x = ((f x), ((f x) = x)) in (func, b));;\n"}
{"hw": "hw2", "index": 3522, "problem": "fixpoint", "bad": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f x), ((f x) = x)) in (func, b));;\n", "fix": "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x = ((f x), ((f x) = x)) in (func, b));;\n"}
{"hw": "hw2", "index": 3523, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw1", "index": 3524, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 3525, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) mod 10;;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 3526, "problem": "digitsOfInt", "bad": "\nlet rec digitsOfInt n = if n < 0 then [] else [(digitsOfInt (n / 10)) mod 10];;\n", "fix": "\nlet rec digitsOfInt n = if n < 0 then [] else digitsOfInt (n / 10);;\n"}
{"hw": "hw1", "index": 3527, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l);;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 3528, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l');;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 3529, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 3530, "problem": "listReverse", "bad": "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "fix": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n"}
{"hw": "hw1", "index": 3531, "problem": "palindrome", "bad": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "fix": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n"}
{"hw": "hw2", "index": 3532, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let newRand = rand (0, 4) in\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (newRand, (depth - 1)))\n      else Sine (build (newRand, (depth - 1)))\n  | 2 ->\n      Average\n        ((build (newRand, (depth - 1))), (build (newRand, (depth - 1))))\n  | 3 ->\n      Times ((build (newRand, (depth - 1))), (build (newRand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3533, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3534, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = makeRand (0, 2) in\n      if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3535, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 -> let halff = rand in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3536, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3537, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3538, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3539, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (0, 7) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3540, "problem": "build", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (a, b) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"}
{"hw": "hw2", "index": 3541, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3542, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> let ex1 = eval (ex, x, y) in sin (pi * ex1)\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3543, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3544, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3545, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3546, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3547, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"}
{"hw": "hw2", "index": 3548, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 3549, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) - (eval (e3, x, y));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 3550, "problem": "eval", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      (eval (e1, x, y)) +. ((eval (e2, x, y)) *. (eval (e3, x, y)));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y));;\n"}
{"hw": "hw2", "index": 3551, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToSring ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Tresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\" * \" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\" ? \" ^\n                    ((exprToString ex3) ^\n                       (\" : \" ^ ((exprToString ex4) ^ \")\")))))));;\n"}
{"hw": "hw2", "index": 3552, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((\">\" exprToString e2) ^\n              ((\"?\" exprToString e1) ^ (\":\" exprToString e2))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3553, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 ((\"?\" exprToString e1) ^ (\":\" exprToString e2)))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3554, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" exprToString e2))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3555, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3556, "problem": "exprToString", "bad": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e1) ^\n                       (\":\" ^ ((exprToString e2) ^ (\")\" s))))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n", "fix": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e1) ^ (\":\" ^ ((exprToString e2) ^ \")\")))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"}
{"hw": "hw2", "index": 3557, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen\n          then helper (seen, t)\n          else helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3558, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          if List.mem h seen\n          then helper (seen, t)\n          else helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3559, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw2", "index": 3560, "problem": "removeDuplicates", "bad": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "fix": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"hw": "hw3", "index": 3561, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = (0, 0) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3562, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = ([], []) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match (a, x) with | ((b,c),(d,e)) -> (b, ((d + e) :: c)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3563, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3564, "problem": "bigAdd", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine (0 :: l1) 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"hw": "hw3", "index": 3565, "problem": "clone", "bad": "\nlet rec clone x n = if n > 0 then x :: ((clone x n) - 1) else [];;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n"}
{"hw": "hw3", "index": 3566, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 bigAdd l l);;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n"}
{"hw": "hw3", "index": 3567, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) bigAdd l l;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n"}
{"hw": "hw3", "index": 3568, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l = if i > 0 then helper i (bigAdd acc l) l else acc in\n  helper i [] l;;\n"}
{"hw": "hw3", "index": 3569, "problem": "mulByDigit", "bad": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then (helper i) - (1 (bigAdd acc l) l) else acc in\n  helper i [] l;;\n", "fix": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i acc l =\n    if i > 0 then helper (i - 1) (bigAdd acc l) l else acc in\n  helper i [] l;;\n"}
{"hw": "hw3", "index": 3570, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3571, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3572, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3573, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs = let f a x = x in let base x y = x y in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3574, "problem": "pipe", "bad": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3575, "problem": "pipe", "bad": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "fix": "\nlet pipe fs =\n  let f a x y = a (x y) in let base x = x in List.fold_left f base fs;;\n"}
{"hw": "hw3", "index": 3576, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3577, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3578, "problem": "sepConcat", "bad": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base x = h ^ x in let l = t in List.fold_left f base l;;\n", "fix": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n"}
{"hw": "hw3", "index": 3579, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3580, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ** 2.) + x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
{"hw": "hw3", "index": 3581, "problem": "sqsum", "bad": "\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0 in List.fold_left f base xs;;\n", "fix": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n"}
