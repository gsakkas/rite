
let rec mulByDigit i l =
  let f a x =
    match a with
    | (carry,rest) ->
        let new_carry = ((i * x) + carry) / 10 in
        let result = (((i * x) + carry) mod 10) :: rest in
        if ((List.length result) = (List.length l)) && (new_carry > 0)
        then (0, (new_carry :: result))
        else (new_carry, result) in
  let base = (0, []) in let (_,res) = List.fold_right f base l in res;;


(* fix

let rec mulByDigit i l =
  let f a x =
    match a with
    | (carry,rest) ->
        let new_carry = ((i * x) + carry) / 10 in
        let result = (((i * x) + carry) mod 10) :: rest in
        if ((List.length result) = (List.length l)) && (new_carry > 0)
        then (0, (new_carry :: result))
        else (new_carry, result) in
  let base = (0, []) in
  let (_,res) = List.fold_left f base (List.rev l) in res;;

*)

(* changed spans
(11,38)-(11,53)
(11,61)-(11,62)
*)

(* type error slice
(3,2)-(11,69)
(3,8)-(10,32)
(3,10)-(10,32)
(4,4)-(10,32)
(6,8)-(10,32)
(6,25)-(6,32)
(6,30)-(6,31)
(7,8)-(10,32)
(8,8)-(10,32)
(10,13)-(10,32)
(11,38)-(11,53)
(11,38)-(11,62)
(11,54)-(11,55)
*)

(* all spans
(2,19)-(11,69)
(2,21)-(11,69)
(3,2)-(11,69)
(3,8)-(10,32)
(3,10)-(10,32)
(4,4)-(10,32)
(4,10)-(4,11)
(6,8)-(10,32)
(6,24)-(6,46)
(6,24)-(6,41)
(6,25)-(6,32)
(6,26)-(6,27)
(6,30)-(6,31)
(6,35)-(6,40)
(6,44)-(6,46)
(7,8)-(10,32)
(7,21)-(7,55)
(7,21)-(7,47)
(7,22)-(7,39)
(7,23)-(7,30)
(7,24)-(7,25)
(7,28)-(7,29)
(7,33)-(7,38)
(7,44)-(7,46)
(7,51)-(7,55)
(8,8)-(10,32)
(8,11)-(8,70)
(8,11)-(8,51)
(8,12)-(8,32)
(8,13)-(8,24)
(8,25)-(8,31)
(8,35)-(8,50)
(8,36)-(8,47)
(8,48)-(8,49)
(8,55)-(8,70)
(8,56)-(8,65)
(8,68)-(8,69)
(9,13)-(9,39)
(9,14)-(9,15)
(9,17)-(9,38)
(9,18)-(9,27)
(9,31)-(9,37)
(10,13)-(10,32)
(10,14)-(10,23)
(10,25)-(10,31)
(11,2)-(11,69)
(11,13)-(11,20)
(11,14)-(11,15)
(11,17)-(11,19)
(11,24)-(11,69)
(11,38)-(11,62)
(11,38)-(11,53)
(11,54)-(11,55)
(11,56)-(11,60)
(11,61)-(11,62)
(11,66)-(11,69)
*)
